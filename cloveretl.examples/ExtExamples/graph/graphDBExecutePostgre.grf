<?xml version="1.0" encoding="UTF-8"?>
<Graph author="avackova" created="Tue Dec 04 10:38:50 CET 2007" guiVersion="0.0.0.devel" id="1196767470169" licenseType="Evaluation Devel" modified="Mon May 02 11:40:04 CEST 2011" modifiedBy="avackova" name="TestingDB2" revision="1.324" showComponentDetails="true">
<Global>
<Metadata id="Metadata0">
<Record fieldDelimiter=";" name="city" recordDelimiter="\n" recordSize="-1" type="delimited">
<Field name="id" nullable="true" shift="0" skipFirstLine="false" type="integer"/>
<Field name="city" nullable="true" shift="0" skipFirstLine="false" type="string"/>
<Field name="country" nullable="true" shift="0" skipFirstLine="false" type="string"/>
</Record>
</Metadata>
<Metadata id="Metadata2" previewAttachmentCharset="ISO-8859-1">
<Record fieldDelimiter="|" name="errorInfo" previewAttachmentCharset="ISO-8859-1" recordDelimiter="\n" type="delimited">
<Field auto_filling="ErrCode" name="errCode" type="integer"/>
<Field auto_filling="ErrText" name="errMess" type="string"/>
</Record>
</Metadata>
<Metadata id="Metadata1">
<Record fieldDelimiter="|" name="id" recordDelimiter="\n" type="delimited">
<Field name="id" type="integer"/>
</Record>
</Metadata>
<Connection dbConfig="${CONN_DIR}/postgre.cfg" id="Connection0" type="JDBC"/>
<Property fileURL="workspace.prm" id="GraphParameter0"/>
<Sequence cached="0" fileURL="${SEQ_DIR}/seq.txt" id="Sequence0" name="sequence" start="1" step="1" type="SIMPLE_SEQUENCE"/>
<Note alignment="1" backgroundColorB="225" backgroundColorG="255" backgroundColorR="255" folded="false" height="308" id="Note0" textColorB="0" textColorG="0" textColorR="0" textFontSize="8" title="Use of the DBExecute Component (Procedure Usage)" titleColorB="0" titleColorG="0" titleColorR="0" titleFontSize="10" width="651" x="365" y="-141">
<attr name="text"><![CDATA[
This graph shows how a DBExecute component can be used to define a procedure in one phase and to call it in another. 

Note that the query creating the procedure includes the "CREATE OR REPLACE" expression. If this "OR REPLACE" was removed, during each run of this graph (except the first one), an error code with the error message would be sent to Trash connected to the optional second output port of DBExecute.  

Just in case an error happens, the Error actions attribute is set to MIN_INT=CONTINUE. That ensures that graph may continue even when an error occurs.

In addition, the definition of the procedure is written to Console (Print statements is true).

In phase 3, DataGenerator uses a sequence to generate ID-s for this procedure that is subsequently called in the DBExecute of the phase 3. This sequence is always reset in the init() function of DataGenerator transformation. The generated ids are used to select cities and countries stored in the database table specified in phase 0. This DBExecute only includes a call of the previously defined stored procedure. The Call as stored procedure attribute must be set to true, otherwise, the graph would fail.

Both the input parameters and the fields for the result output set are specified.

]]></attr>
</Note>
<Dictionary/>
</Global>
<Phase number="0">
<Node dbConnection="Connection0" enabled="enabled" errorActions="MIN_INT=CONTINUE;" guiHeight="98" guiName="Table creation" guiWidth="132" guiX="36" guiY="-144" id="DB_EXECUTE0" sqlQuery="drop table IF EXISTS city CASCADE;&#13;&#10;create table city (&#13;&#10; id INTEGER,&#13;&#10; city VARCHAR(80),&#13;&#10; country VARCHAR(80)&#13;&#10;);&#13;&#10;" sqlStatementDelimiter=";" type="DB_EXECUTE">
<attr name="guiDescription"><![CDATA[Db table is created. If it already exists, it is deleted. In either case, the Error actions attribute value (MIN_INT=CONTINUE) ensures that graph successfully runs even when an attempt to drop a non-existing table or create an existing one is made.]]></attr>
</Node>
</Phase>
<Phase number="1">
<Node enabled="enabled" fileURL="${DATAIN_DIR}/delimited/citytable.txt" guiHeight="98" guiName="Data for table" guiWidth="131" guiX="37" guiY="-40" id="DATA_READER0" type="DATA_READER">
<attr name="guiDescription"><![CDATA[Data from a flat file.]]></attr>
</Node>
<Node dbConnection="Connection0" enabled="enabled" guiHeight="81" guiName="Table filling" guiWidth="128" guiX="217" guiY="-40" id="DB_OUTPUT_TABLE0" sqlQuery="INSERT INTO city (id, city, country) &#13;&#10;VALUES ($id, $city, $country)" type="DB_OUTPUT_TABLE">
<attr name="guiDescription"><![CDATA[Load to database.]]></attr>
</Node>
<Edge debugMode="true" fromNode="DATA_READER0:0" guiBendpoints="" guiRouter="Manhattan" id="Edge2" inPort="Port 0 (in)" metadata="Metadata0" outPort="Port 0 (output)" toNode="DB_OUTPUT_TABLE0:0"/>
</Phase>
<Phase number="2">
<Node dbConnection="Connection0" enabled="enabled" errorActions="MIN_INT=CONTINUE;" guiHeight="98" guiName="Procedure creation" guiWidth="166" guiX="37" guiY="68" id="DB_EXECUTE1" printStatements="true" sqlQuery="CREATE OR REPLACE FUNCTION myfunc(int)&#13;&#10;RETURNS SETOF city&#13;&#10;AS&#13;&#10;$$ &#13;&#10;  SELECT * FROM city WHERE id = $1;&#13;&#10;$$&#13;&#10;LANGUAGE 'sql' VOLATILE;" sqlStatementDelimiter="#" type="DB_EXECUTE">
<attr name="guiDescription"><![CDATA[Procedure is created and it is stored in database.]]></attr>
</Node>
<Node debugPrint="true" enabled="enabled" guiHeight="64" guiName="Error info" guiWidth="128" guiX="217" guiY="68" id="TRASH0" type="TRASH"/>
<Edge debugMode="true" fromNode="DB_EXECUTE1:1" guiBendpoints="" guiRouter="Manhattan" id="Edge0" inPort="Port 0 (in)" metadata="Metadata2" outPort="Port 1 (error output)" toNode="TRASH0:0"/>
</Phase>
<Phase number="3">
<Node enabled="enabled" guiHeight="98" guiName="ID-s generator" guiWidth="134" guiX="38" guiY="178" id="DATA_GENERATOR3" recordsNumber="100" type="DATA_GENERATOR">
<attr name="generate"><![CDATA[//#TL

// Generates output record.
function generate() {
	$0.id := sequence(Sequence0).next;
}

// Called during component initialization.
 function init() {
 	sequence(Sequence0).reset;
 }

// Called after the component finishes.
// function finished() {}
]]></attr>
<attr name="guiDescription"><![CDATA[DataGenerator uses a sequence to generate ID-s.]]></attr>
</Node>
<Node enabled="enabled" fileURL="${DATAOUT_DIR}/cities.txt" guiHeight="98" guiName="Procedure output" guiWidth="157" guiX="398" guiY="178" id="DATA_WRITER0" type="DATA_WRITER"/>
<Node callStatement="true" dbConnection="Connection0" enabled="enabled" guiHeight="98" guiName="Procedure call" guiWidth="132" guiX="218" guiY="178" id="DB_EXECUTE2" inParameters="1:=$id;" outputFields="id;city;country" sqlQuery="{call myfunc2(?)}" type="DB_EXECUTE">
<attr name="guiDescription"><![CDATA[Procedure is subsequently called for each input record.]]></attr>
</Node>
<Edge debugMode="true" fromNode="DATA_GENERATOR3:0" guiBendpoints="" guiRouter="Manhattan" id="Edge5" inPort="Port 0 (input parameters)" metadata="Metadata1" outPort="Port 0 (out)" toNode="DB_EXECUTE2:0"/>
<Edge debugMode="true" fromNode="DB_EXECUTE2:0" guiBendpoints="" guiRouter="Manhattan" id="Edge4" inPort="Port 0 (in)" metadata="Metadata0" outPort="Port 0 (procedure output)" toNode="DATA_WRITER0:0"/>
</Phase>
</Graph>
