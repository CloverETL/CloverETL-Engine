/*
*    jETeL/Clover - Java based ETL application framework.
*    Copyright (C) 2002-04  David Pavlis <david_pavlis@hotmail.com>
*    
*    This library is free software; you can redistribute it and/or
*    modify it under the terms of the GNU Lesser General Public
*    License as published by the Free Software Foundation; either
*    version 2.1 of the License, or (at your option) any later version.
*    
*    This library is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    
*    Lesser General Public License for more details.
*    
*    You should have received a copy of the GNU Lesser General Public
*    License along with this library; if not, write to the Free Software
*    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*/
package org.jetel.component;

import java.io.IOException;
import java.sql.BatchUpdateException;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Arrays;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jetel.connection.ConnectionAction;
import org.jetel.connection.DBConnection;
import org.jetel.connection.QueryAnalyzer;
import org.jetel.connection.SQLCloverStatement;
import org.jetel.connection.SQLUtil;
import org.jetel.data.DataRecord;
import org.jetel.data.Defaults;
import org.jetel.database.IConnection;
import org.jetel.exception.ComponentNotReadyException;
import org.jetel.exception.ConfigurationProblem;
import org.jetel.exception.ConfigurationStatus;
import org.jetel.exception.JetelException;
import org.jetel.exception.XMLConfigurationException;
import org.jetel.graph.InputPort;
import org.jetel.graph.Node;
import org.jetel.graph.OutputPort;
import org.jetel.graph.Result;
import org.jetel.graph.TransformationGraph;
import org.jetel.metadata.DataFieldMetadata;
import org.jetel.metadata.DataRecordMetadata;
import org.jetel.util.SynchronizeUtils;
import org.jetel.util.file.FileUtils;
import org.jetel.util.property.ComponentXMLAttributes;
import org.jetel.util.string.StringUtils;
import org.w3c.dom.Element;

/**
 *  <h3>DatabaseOutputTable Component</h3>
 * <!-- This component performs DML operation on specified database table (insert/update/delete). -->
 *
 * <table border="1">
 * <th>Component:</th>
 * <tr><td><h4><i>Name:</i></h4></td>
 * <td>DBOutputTable</td></tr>
 * <tr><td><h4><i>Category:</i></h4></td>
 * <td></td></tr>
 * <tr><td><h4><i>Description:</i></h4></td>
 * <td>This component performs specified DML operation (insert/update/delete) on specified database table.<br>
 *   Parameter placeholder in DML statement is [?] - question mark</td></tr>
 * <tr><td><h4><i>Inputs:</i></h4></td>
 * <td>[0]- input records</td></tr>
 * <tr><td><h4><i>Outputs:</i></h4></td>
 * <td>[0] <i>optional</i> - records rejected by database. If in this metadata there is more fields then in input metadata
 * and last field is of type string, this field is filled by error message<br>
 * 	   [1] <i>optional</i> - autogenerated columns (supported only for INSERT statement to Oracle, MySQL, Db2 and Informix
 *  databases, not supported in batch mode at all). Key record is generated for <b>each</b> input record. In case that
 *  statement execution fails, requested fields are not filled.</td></tr>
 * <tr><td><h4><i>Comment:</i></h4></td>
 * <td></td></tr>
 * </table>
 *  <br>
 *  <table border="1">
 *  <th>XML attributes:</th>
 *  <tr><td><b>type</b></td><td>"DB_OUTPUT_TABLE"</td></tr>
 *  <tr><td><b>id</b></td><td>component identification</td></tr>
 *  <tr><td><b>dbConnection</b></td><td>id of the Database Connection object to be used to access the database</td>
 *  <tr><td><b>dbTable</b><br><i>optional</i></td><td>name of the DB table to populate data with</td>
 *  <tr><td><b>sqlQuery</b><br><i>optional</i></td><td>allows specification of SQL query/DML statement to be executed against
 *  database. It can consist of more then one query separated by semicolon [;]. Question marks [?] in the query text 
 *  are placeholders which are filled with values from input fields specified in <b>cloverFields</b>
 *  attribute. If you have query in this form, <i>cloverFields</i> must be specified as well - it determines which input fields will
 *  be used/mapped onto target fields. You can write query with direct mapping too: instead of placeholders use clover field's names 
 *  predated by dollar char [$]. In such form you can use mapping between generated keys and output record with this keys too.
 *  Complete query should appear as follows:<br><ul>
 *  <li><code>insert into mytable [(f1,f2,...,fn)] values (val1, $field2, ...,$fieldm ) returning $key := dbfield1, $field := dbfield2</code> - 
 *  where <i>f1,f2,...,fn,dbfield1,dbfield2</i> are database fields; <i>field2,.., fieldm</i> are input record fields 
 *  and <i>key, field</i> are key record fields. <b>This is valid for databases which can return more then 
 *  one columns in <i>getGeneratedKeys()</i> method (Oracle and db2 for the time beeing). </b> </li>
 *  <li><code>insert into mytable [(f1,f2,...,fn)] values (val1, $field2, ...,$fieldm ) returning $key := auto_generated, $field := infield</code> - 
 *  where <i>f1,f2,...,fn</i> are database fields; <i>field2,.., fieldm, infield</i> are input record fields, 
 *  <i>auto_generated</i>  is auto genereted column value returned by database and <i>key, field</i> are key record 
 *  fields. <b>This is valid for databases which returns one auto generated column in <i>getGeneratedKeys()</i> method 
 *  (MySql and Informix for the time being). </b> </li>
 *  <li><code>delete from mytable where f1 = $field1 and ... fn = $fieldn</code> - where <i>f1,..,fn</i> are database
 *  fields and <i>field1,...,fieldn</i> are input record fields</li>
 *  <li><code>update mytable set f1 = $field1,...,fn=$fieldn</code> - where <i>f1,..,fn</i> are database
 *  fields and <i>field1,...,fieldn</i> are input record fields</li></ul>
 *  <tr><td><b>url</b><br><i>optional</i></td><td>url location of the query. The query will be loaded from file referenced by the url. 
 *  Rules for extern query are the same as for <i>sqlQuery</i> parameter.</td>
 *  <tr><td><b>charset </b><i>optional</i></td><td>encoding of extern query</td></tr>
 * <tr><td>&lt;SQLCode&gt;<br><i>optional<small>!!XML tag!!</small></i></td><td>This tag allows for embedding large SQL statement directly into graph.. See example below.</td></tr>
 *  <tr><td><b>fieldMap</b><br><i>optional</i></td><td>Pairs of clover fields and db fields (cloverField=dbField) separated by :;| {colon, semicolon, pipe}.<br>
 *  It specifies mapping from source (Clover's) fields to DB table fields if it isn't specified in <i>sqlQuery</i>. It should be used instead of <i>cloverFields</i> and <i>dbFields</i>
 *  attributes, because it provides more clear mapping. If <i>fieldMap</i> attribute is found <i>cloverFields</i> and <i>dbFields</i> attributes are ignored.
 *  <tr><td><b>dbFields</b><br><i>optional</i></td><td>delimited list of target table's fields to be populated<br>
 *  Input fields are mapped onto target fields (listed) in the order they are present in Clover's record.</td>
 *  <tr><td><b>commit</b><br><i>optional</i></td><td>determines how many records are in one db commit. Minimum 1, DEFAULT is 100.<br>If
 * MAX_INT is specified, it is considered as NEVER COMMIT - i.e. records are send to DB without every issuing commit. It can
 * be called later from within other component - for example DBExecute.</td>
 *  <tr><td><b>cloverFields</b><br><i>optional</i></td><td>delimited list of input record's fields.<br>Only listed fields (in the order
 *  they appear in the list) will be considered for mapping onto target table's fields. Combined with <b>dbFields</b> option you can
 *  specify mapping from source (Clover's) fields to DB table fields. If no <i>dbFields</i> are specified, then #of <i>cloverFields</i> must
 *  correspond to number of target DB table fields.</td>
 *   <tr><td><b>autoGeneratedColumns</b><br><i>deprecated</i> - use <i>sqlQuery</i> extended form</td><td>
 *   This attribute can be used for obtaining auto generated columns, but only in case that <i>sqlQuery</i> consist
 *   of only <b>one</b> query. In other case construct queries with direct mapping. 
 *   <ul><li>For Oracle or Db2 database: names of database columns to be returned (for Db2 - entity columns)</li>
 *   <li>For MySQL or Informix database: names of input record fields plus special field called "AUTO_GENERATED" to be returned</td></tr>
 *  <tr><td><b>batchMode</b><br><i>optional</i></td><td>[Yes/No] determines whether to use batch mode for sending statements to DB, DEFAULT is No.<br>
 *  <i>Note:If your database/JDBC driver supports this feature, switch it on as it significantly speeds up table population.</i></td>
 *  </tr>
 * <tr><td><b>batchSize</b><br><i>optional</i></td><td>number - determines how many records will be sent to database in one batch update. Default is 25.
 * </td>
 *  </tr> 
 *   <tr><td><b>maxErrors</b><br><i>optional</i></td><td>maximum number of allowed SQL errors. Default: 0 (zero). If exceeded, component stops with error. If set to <b>-1</b>(minus one) all errors are ignored.</td></tr>
 *   <tr><td><b>errorAction</b><br><i>optional</i></td><td>ROLLBACK or COMMIT (case sensitive!!!). Default: COMMIT. 
 *   Action performed when exceeded maximum number of records or execution of the component is aborted.</td></tr>
 *  </table>
 *
 *  <h4>Example:</h4>
 *  <pre>&lt;Node id="OUTPUT" type="DB_OUTPUT_TABLE" dbConnection="NorthwindDB" dbTable="employee_z"/&gt;</pre>
 *  <br>
 *  <pre>&lt;Node id="OUTPUT" type="DB_OUTPUT_TABLE" dbConnection="NorthwindDB" dbTable="employee_z" dbFields="f_name;l_name;phone"/&gt;</pre>
 *  <i>Example above shows how to populate only selected fields within target DB table. It can be used for skipping target fields which
 *  are automatically populated by DB (such as autoincremented fields).</i>
 *  <br>
 *  <pre>&lt;Node id="OUTPUT" type="DB_OUTPUT_TABLE" dbConnection="NorthwindDB" dbTable="employee_z"
 *	   dbFields="f_name;l_name" cloverFields="LastName;FirstName"/&gt;</pre>
 *  <i>Example shows how to simply map Clover's LastName and FirstName fields onto f_name and l_name DB table fields. The order
 *  in which these fields appear in Clover data record is not important.</i>
 *  <br>
 *   <pre>&lt;Node id="OUTPUT" type="DB_OUTPUT_TABLE" dbConnection="NorthwindDB" sqlQuery="insert into myemployee2 (FIRST_NAME,LAST_NAME,DATE,ID) values (?,?,sysdate,123)"
 *	   cloverFields="FirstName;LastName"/&gt;</pre>
 *  <br>
 * <pre>&lt;Node id="OUTPUT" type="DB_OUTPUT_TABLE" dbConnection="NorthwindDB" cloverFields="FirstName;LastName"&gt;
 *  &lt;SQLCode&gt;
 *	insert into myemployee2 (FIRST_NAME,LAST_NAME,DATE,ID) values (?,?,sysdate,123)
 *  &lt;/SQLCode&gt;
 *  &lt;/Node&gt;</pre>
 *  <i>Example below shows how to delete records in table using DBOutputTable component</i>
 *  <pre>&lt;Node id="OUTPUT" type="DB_OUTPUT_TABLE" dbConnection="NorthwindDB" cloverFields="FirstName;LastName"&gt;
 *  &lt;SQLCode&gt;
 *  delete from myemployee2 where FIRST_NAME = ? and LAST_NAME = ?
 *  &lt;/SQLCode&gt;
 *  &lt;/Node&gt;</pre>
 * <br>
 *  <i>Example below shows usage of "fieldMap" attribute </i>
 * <pre>&lt;Node dbConnection="DBConnection0" dbTable="employee_tmp" fieldMap=
 * "EMP_NO=emp_no;FIRST_NAME=first_name;LAST_NAME=last_name;PHONE_EXT=phone_ext"
 * id="OUTPUT" type="DB_OUTPUT_TABLE"/&gt;</pre>
 * <br>
 * <i>Examples below show how to get aoutogenerated columns</i>
 * <pre>
 * &lt;Node dbConnection="Connection1" id="OUTPUT" maxErrors="10" sqlQuery=
 * "INSERT INTO CLOVER_USER (U_ID,NAME ,CREATED) values ($EMP_NO, $FULL_NAME,  $HIRE_DATE);
 *  INSERT INTO MYEMPLOYEE (EMP_NO, FIRST_NAME, LAST_NAME,COUNTRY, SALARY, FULL_NAME) VALUES 
 *                         ($EMP_NO, $FIRST_NAME, $LAST_NAME, $COUNTRY, $SALARY, $FULL_NAME) 
 *                         RETURNING $id:=auto_generated, $Field2:=full_name;" type="DB_OUTPUT_TABLE"/&gt;
 * 
 * &lt;Node dbConnection="Connection1" id="OUTPUT" maxErrors="10" sqlQuery=
 * "DELETE FROM CLOVER_USER WHERE U_ID = $EMP_NO;
 *  INSERT INTO MYEMPLOYEE (ID, EMP_NO, FIRST_NAME, LAST_NAME,COUNTRY, SALARY, FULL_NAME) VALUES 
 *                         (id_seq.nextval, $EMP_NO, $FIRST_NAME, $LAST_NAME, $COUNTRY, $SALARY, $FULL_NAME) 
 *                         RETURNING $id:=ID, $Field2:=FIRST_NAME;" type="DB_OUTPUT_TABLE" errorAction="ROLLBACK"/&gt;
 * 
 *&lt;Node autoGeneratedColumns="AUTO_GENERATED;FIRST_NAME;" dbConnection="DBConnection2" id="OUTPUT" maxErrors="10" 
 *	sqlQuery="INSERT INTO myemployee (EMP_NO, FIRST_NAME, LAST_NAME, PHONE_EXT, HIRE_DATE, DEPT_NO, JOB_CODE, JOB_GRADE, JOB_COUNTRY, SALARY, FULL_NAME) 
 *	VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)" type="DB_OUTPUT_TABLE"/&gt;
 *
 *&lt;Node autoGeneratedColumns="ID;FIRST_NAME;" batchMode="false" dbConnection="DBConnection1" 
 *	dbTable="MYEMPLOYEE" id="OUTPUT" maxErrors="10" sqlQuery="INSERT INTO myemployee VALUES (id_seq.nextval, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)" 
 *	type="DB_OUTPUT_TABLE"/&gt;
 *
 * @author      dpavlis, avackova (agata.vackova@javlinconsulting.cz)
 * @since       September 27, 2002
 * @revision    $Revision$
 * @created     22. July 2003
 * @see         org.jetel.database.AnalyzeDB
 */
public class DBOutputTable extends Node {
	
	public static final String XML_MAXERRORS_ATRIBUTE = "maxErrors";
	public static final String XML_BATCHMODE_ATTRIBUTE = "batchMode";
	public static final String XML_COMMIT_ATTRIBUTE = "commit";
	public static final String XML_FIELDMAP_ATTRIBUTE = "fieldMap";
	public static final String XML_CLOVERFIELDS_ATTRIBUTE = "cloverFields";
	public static final String XML_DBFIELDS_ATTRIBUTE = "dbFields";
	public static final String XML_SQLCODE_ELEMENT = "SQLCode";
	public static final String XML_DBTABLE_ATTRIBUTE = "dbTable";
	public static final String XML_DBCONNECTION_ATTRIBUTE = "dbConnection";
	public static final String XML_SQLQUERY_ATRIBUTE = "sqlQuery";
	public static final String XML_BATCHSIZE_ATTRIBUTE = "batchSize";
	public static final String XML_URL_ATTRIBUTE = "url";
	public static final String XML_CHARSET_ATTRIBUTE = "charset";
	public static final String XML_AUTOGENERATEDCOLUMNS_ATTRIBUTE = "autoGeneratedColumns";
	public static final String XML_ACTION_ON_ERROR = "errorAction";
	
	public static final String STATEMENT_SEPARATOR = ";";
	
	private static final Pattern CLOVER_FIELDS_PATTERN = Pattern.compile("\\$(\\w+)");//$cloverField

	private DBConnection dbConnection;
	private String dbConnectionName;
	private String dbTableName;
	private SQLCloverStatement[] statement;
	private String[] cloverFields;
	private String[] dbFields;
	private String[] sqlQuery;
	private int recordsInCommit;
	private int maxErrors;
	private boolean useBatch;
	private int batchSize;
	private boolean fillError = false;
    private int countError=0;
	private String[] autoGeneratedColumns = null;
	private boolean returnKey = true;
	private ConnectionAction errorAction = ConnectionAction.COMMIT;
	
	private InputPort inPort;
	private OutputPort rejectedPort, keysPort;
	private DataRecord inRecord, rejectedRecord, keysRecord;
	private boolean queryInCloverFormat = false;//true if any of queries contains "$field" pattern 
	private int recCount = 0;
	
	/**  Description of the Field */
	public final static String COMPONENT_TYPE = "DB_OUTPUT_TABLE";
	private final static int SQL_FETCH_SIZE_ROWS = 100;
	private final static int READ_FROM_PORT = 0;
	private final static int WRITE_REJECTED_TO_PORT = 0;
	private final static int WRITE_AUTO_KEY_TO_PORT = 1;
	private final static int RECORDS_IN_COMMIT = 100;
	private final static int RECORDS_IN_BATCH = 25;
	private final static int MAX_ALLOWED_ERRORS = 0;
	private final static int MAX_WARNINGS = 3;
	
	static Log logger = LogFactory.getLog(DBOutputTable.class);

	/**
	 *  Constructor for the DBInputTable object
	 *
	 * @param  id                Unique ID of component
	 * @param  dbConnectionName  Name of Clover's database connection to be used for communicating with DB
	 * @param  dbTableName       Name of target DB table to be populated with data
	 * @since                    September 27, 2002
	 */
	public DBOutputTable(String id, String dbConnectionName, String dbTableName) {
		this(id,dbConnectionName);
		this.dbTableName = dbTableName;
	}

	/**
	 * @param id Unique ID of component
	 * @param dbConnectionName Name of Clover's database connection to be used for communicating with DB
	 * @param sqlQuery set of sql queries
	 */
	public DBOutputTable(String id, String dbConnectionName, String[] sqlQuery) {
		this(id,dbConnectionName);
		this.sqlQuery=sqlQuery;
		Matcher cloverFieldMatcher;
		for (String string : sqlQuery) {
			cloverFieldMatcher = CLOVER_FIELDS_PATTERN.matcher(string);
			if (cloverFieldMatcher.find()) {
				queryInCloverFormat = true;
				break;
			}
		}
	}
	
	/**
	 * Constructor for the DBInputTable object
	 * @param id				Unique ID of component
	 * @param dbConnectionName	Name of Clover's database connection to be used for communicating with DB
	 * @param sqlQuery			SQL query to be executed against DB - can be any DML command (INSERT, UPDATE, DELETE)
	 * @param cloverFields		Array of Clover field names (the input data) which should substitute DML command parameters (i.e. "?")
	 */
	@Deprecated
	public DBOutputTable(String id, String dbConnectionName, String sqlQuery, String[] cloverFields) {
		this(id, dbConnectionName, new String[]{sqlQuery});
		setCloverFields(cloverFields);
	}
	
	/**
	 * Constructor for the DBInputTable object
	 */
	DBOutputTable(String id, String dbConnectionName){
		super(id);
		this.dbConnectionName = dbConnectionName;
		this.dbTableName = null;
		cloverFields = null;
		dbFields = null;
		recordsInCommit = RECORDS_IN_COMMIT;
		maxErrors=MAX_ALLOWED_ERRORS;
		useBatch=false;
		batchSize=RECORDS_IN_BATCH;
	}
	
	/**
	 *  Sets the dBFields attribute of the DBOutputTable object
	 *
	 * @param  dbFields  The new dBFields value
	 */
	public void setDBFields(String[] dbFields) {
		this.dbFields = dbFields;
	}


	/**
	 *  Sets the useBatch attribute of the DBOutputTable object
	 *
	 * @param  batchMode  The new useBatch value
	 */
	public void setUseBatch(boolean batchMode) {
		this.useBatch = batchMode;
	}

	/**
	 * Sets batch size - how many records are in batch which is sent
	 * to DB at once.
	 * @param batchSize
	 */
	public void setBatchSize(int batchSize){
	    this.batchSize=batchSize;
	}

	/**
	 *  Sets the cloverFields attribute of the DBOutputTable object
	 *
	 * @param  cloverFields  The new cloverFields value
	 */
	public void setCloverFields(String[] cloverFields) {
		this.cloverFields = cloverFields;
	}


	/**
	 *  Description of the Method
	 *
	 * @exception  ComponentNotReadyException  Description of Exception
	 * @since                                  September 27, 2002
	 */
	public void init() throws ComponentNotReadyException {
		super.init();
		// get dbConnection from graph
        IConnection conn = getGraph().getConnection(dbConnectionName);
        if(conn == null) {
            throw new ComponentNotReadyException("Can't find DBConnection ID: " + dbConnectionName);
        }
        if(!(conn instanceof DBConnection)) {
            throw new ComponentNotReadyException("Connection with ID: " + dbConnectionName + " isn't instance of the DBConnection class.");
        }
        dbConnection = (DBConnection) conn;
		dbConnection.init();
        //fill error if exist port for rejected records & input and rejected metadata are different
        //	& last field of rejected metadata is of type string 
        fillError = (getOutputPort(WRITE_REJECTED_TO_PORT) != null && 
        		!getOutputPort(WRITE_REJECTED_TO_PORT).getMetadata().equals(getInputPort(READ_FROM_PORT).getMetadata())) && 
        		getOutputPort(WRITE_REJECTED_TO_PORT).getMetadata().getField(
        				getOutputPort(WRITE_REJECTED_TO_PORT).getMetadata().getNumFields() - 1).
        				getType() == DataFieldMetadata.STRING_FIELD;
        //prepare inRecord, rejectedRecord and keysRecord
        inPort = getInputPort(READ_FROM_PORT);
		inRecord = new DataRecord(inPort.getMetadata());
		inRecord.init();
		rejectedPort=getOutputPort(WRITE_REJECTED_TO_PORT);
		rejectedRecord = rejectedPort != null ? new DataRecord(rejectedPort.getMetadata()) : null;
		if (rejectedRecord != null) {
			rejectedRecord.init();
		}		
		keysPort = getOutputPort(WRITE_AUTO_KEY_TO_PORT);
		returnKey = keysPort != null;
		keysRecord = returnKey ? new DataRecord(keysPort.getMetadata()) : null;
		if (returnKey) {
			keysRecord.init();
			keysRecord.reset();
		}
		
		// first check that what we require is supported
		try {
			if (useBatch && !dbConnection.getConnection(getId()).getMetaData().supportsBatchUpdates()){
				logger.warn("DB indicates no support for batch updates -> switching it off !");
				useBatch=false;
			}
		} catch (SQLException e) {
			ComponentNotReadyException ex = new ComponentNotReadyException(this, e);
			ex.setAttributeName(XML_DBCONNECTION_ATTRIBUTE);
			throw ex;
		}
		try {
			if (keysPort != null && !dbConnection.getConnection(getId()).getMetaData().supportsGetGeneratedKeys()){
				logger.warn("DB indicates no support for getting generated keys -> switching it off !");
				returnKey = false;
			}
		} catch (SQLException e) {
			ComponentNotReadyException ex = new ComponentNotReadyException(this, e);
			ex.setAttributeName(XML_DBCONNECTION_ATTRIBUTE);
			throw ex;
		}
		if (useBatch && returnKey){
			logger.warn("Getting generated keys in batch mode is not supported -> switching it off !");
			returnKey = false;
			int index;
			for (int i = 0; i < sqlQuery.length; i++) {
				index = sqlQuery[i].toLowerCase().indexOf(QueryAnalyzer.RETURNING_KEY_WORD);
				if (index > -1) {
					sqlQuery[i] = sqlQuery[i].substring(0, index);
				}
			}
		}
		

		// it is probably wise to have COMMIT size multiplication of BATCH size
		// except situation when commit size is MAX_INTEGER -> we never commit in this situation;
		if (useBatch && recordsInCommit!=Integer.MAX_VALUE && (recordsInCommit % batchSize != 0)){
			int multiply= recordsInCommit/batchSize;
			recordsInCommit=(multiply+1) * batchSize;
		}
		
		//prepare set of statements
		statement = new SQLCloverStatement[sqlQuery != null ? sqlQuery.length: 1];
		if (queryInCloverFormat) {
			for (String query : sqlQuery) {
				if (query.contains("?"))
					throw new ComponentNotReadyException(this, XML_SQLQUERY_ATRIBUTE, 
							"Can't be both mapping and question mark in query");
			}
			//if autogeneratedColumns attribute used, correct query or throw exception
			if (returnKey && autoGeneratedColumns != null) {
				if (statement.length == 1 && !sqlQuery[0].toLowerCase().contains(QueryAnalyzer.RETURNING_KEY_WORD)) {
					StringBuilder query = new StringBuilder(sqlQuery[0] + " " + QueryAnalyzer.RETURNING_KEY_WORD + " ");
					DataRecordMetadata keyMetadata = keysPort.getMetadata();
					for (int i = 0; i < keyMetadata.getNumFields(); i++) {
						query.append('$');
						query.append(keyMetadata.getField(i).getName());
						query.append(QueryAnalyzer.ASSIGN_SIGN);
						query.append(autoGeneratedColumns[i]);
						query.append(',');
					}
					query.setLength(query.length() - 1);
					sqlQuery[0] = query.toString();
				}else if (statement.length == 1){
					logger.warn("Autogenerated columns defined in both " + XML_SQLQUERY_ATRIBUTE + " and "
							+ XML_AUTOGENERATEDCOLUMNS_ATTRIBUTE + " attributes --> getting value from "
							+ XML_SQLQUERY_ATRIBUTE + " attribute (" + sqlQuery[0] + ").");
					autoGeneratedColumns = null;
				}else{
					logger.warn("Found more then one sql query and " + XML_AUTOGENERATEDCOLUMNS_ATTRIBUTE +
							" parameter. The last one will be ignored");
					autoGeneratedColumns = null;
				}
			}
			//prepare statement for each query
			for (int i=0; i < statement.length; i++) {
				statement[i] = new SQLCloverStatement(dbConnection.getConnection(getId()),	sqlQuery[i], inRecord);
			}
		}else{
			if (sqlQuery != null) {//query with placeholders
				int start = 0;
				int end;
				String[] tmpCloverFields = null;
				//Split clover fields for proper statements and prepare each statement
				for (int i=0; i < statement.length; i++) {
					if (cloverFields != null) {
						end = StringUtils.count(sqlQuery[i], '?');
						tmpCloverFields = new String[end - start];
						for (int j = 0; j < tmpCloverFields.length; j++) {
							tmpCloverFields[j] = cloverFields[start + j];
						}
						start = end;
					}
					if (returnKey) {
						if (statement.length == 1) {
							statement[i] = new SQLCloverStatement(dbConnection.getConnection(getId()),	sqlQuery[i], 
									inRecord, tmpCloverFields,	null, autoGeneratedColumns);
						}else{
							logger.error("For more than one statement and getting auto generated keys write query with direct mapping");
							throw new ComponentNotReadyException(this, XML_SQLQUERY_ATRIBUTE, 
									"For more than one statement and getting auto generated keys write query with direct mapping");
						}
					}else{
						statement[i] = new SQLCloverStatement(dbConnection.getConnection(getId()),	sqlQuery[i],
								inRecord, tmpCloverFields, null);
					}
				}
			}else{//sqlQuery == null
				sqlQuery = new String[1];
				if (dbFields != null) {
					sqlQuery[0] = SQLUtil.assembleInsertSQLStatement(dbTableName, dbFields);
				}else{
					sqlQuery[0] = SQLUtil.assembleInsertSQLStatement(inPort.getMetadata(), dbTableName);
				}
				statement[0] = new SQLCloverStatement(dbConnection.getConnection(getId()),	sqlQuery[0], inRecord, 
						cloverFields, dbFields);
				statement[0].setTableName(dbTableName);
			}
		}
		//init statements
		for (SQLCloverStatement eachStatement : statement) {
			eachStatement.setLogger(logger);
			try {
				if (!eachStatement.prepareUpdateStatement() && returnKey) {
					returnKey = false;
				}
			} catch (Exception e) {
				throw new ComponentNotReadyException(this, e.getMessage());
			} 
		}
	
	}

	/**
	 * @param dbTableName The dbTableName to set.
	 */
	public void setDBTableName(String dbTableName) {
		this.dbTableName = dbTableName;
	}
	
	/**
	 *  Sets the recordsInCommit attribute of the DBOutputTable object
	 *
	 * @param  nRecs  The new recordsInCommit value
	 */
	public void setRecordsInCommit(int nRecs) {
		if (nRecs > 0) {
			recordsInCommit = nRecs;
		}
	}

	@Override
	public Result execute() throws Exception {
		// this does not work for some drivers
		try {
			dbConnection.getConnection(getId()).setAutoCommit(false);
		} catch (SQLException ex) {
			recordsInCommit = Integer.MAX_VALUE;
			logger.warn("Can't disable AutoCommit mode for DB: " + dbConnection + " > possible slower execution...");
		}
		/*
		 * Run main processing loop
		 */
		try{
			if (useBatch){
				runInBatchMode();
			}else{
				runInNormalMode();
			}
		}catch (InterruptedException e) {
			if (errorAction == ConnectionAction.ROLLBACK) {
				errorAction.perform(dbConnection.getConnection(getId()));
				if (errorAction == ConnectionAction.ROLLBACK) {
					logger.info("Rollback performed.");
					logger.info("Number of commited records: " + (recCount / recordsInCommit)*recordsInCommit);
				}else{
					logger.info("Number of commited records: " + recCount);
				}
				logger.info("Rollback performed.");
				logger.info("Number of commited records: " + (recCount / recordsInCommit)*recordsInCommit);
			}else if (recordsInCommit!=Integer.MAX_VALUE){
				errorAction.perform(dbConnection.getConnection(getId()));
				logger.info("Number of commited records: " + recCount);
			}
		} finally {
			broadcastEOF();
			for (SQLCloverStatement eachStatement : statement) {
				eachStatement.close();
			}
		}
        return runIt ? Result.FINISHED_OK : Result.ABORTED;
	}
	
	@Override
	public synchronized void free() {
		super.free();
		dbConnection.free();
	}

	private void runInNormalMode() throws SQLException,InterruptedException,IOException, JetelException{
		String errmes = "";
		SQLException exception = null;
		while ((inRecord = inPort.readRecord(inRecord)) != null && runIt) {
			if (returnKey) {
				keysRecord.reset();
			}
			//execute all statements
			for (int i=0; i<statement.length; i++) {
				try{
					statement[i].executeUpdate();
					if (returnKey) {
						statement[i].fillKeyRecord(keysRecord);
					}
				}catch(SQLException ex) {
					countError++;
					exception = ex;
					errmes = "Exeption thrown by: " + statement[i].getQuery() + ". Message: " + ex.getMessage();
					if (rejectedPort != null) {
						rejectedRecord.copyFrom(inRecord);
						if (fillError) {
							rejectedRecord.getField(rejectedRecord.getNumFields() - 1).setValue(errmes);
						}
						rejectedPort.writeRecord(rejectedRecord);
					}
					if (countError <= MAX_WARNINGS) {
						logger.warn(errmes);
					}else if (countError == MAX_WARNINGS + 1){
						logger.warn("more errors...");
					}
				}
			}
			//send filled key record to output
			if (returnKey) {
				keysPort.writeRecord(keysRecord);
			}
			//if number of errors is greater then allowed throw exception
			if (countError>maxErrors && maxErrors!=-1){
				//Perform commit or rollback
				errorAction.perform(dbConnection.getConnection(getId()));
				if (errorAction == ConnectionAction.ROLLBACK) {
					logger.info("Rollback performed.");
					logger.info("Number of commited records: " + (recCount / recordsInCommit)*recordsInCommit);
//					logger.info("Last " + recCount % recordsInCommit  + " records not commited");
				}else if (errorAction == ConnectionAction.COMMIT){
					logger.info("Number of commited records: " + ++recCount);
				}
				throw new JetelException("Maximum # of errors exceeded when inserting record. "+ errmes, exception);
			}
			//if needed, commit
			if (recordsInCommit!=Integer.MAX_VALUE && ++recCount % recordsInCommit == 0) {
				dbConnection.getConnection(getId()).commit();
			}
			SynchronizeUtils.cloverYield();
		}
 		// end of records stream - final commits;
		 // unless we have option never to commit, commit at the end of processing
	    if (runIt && recordsInCommit!=Integer.MAX_VALUE){
	    	dbConnection.getConnection(getId()).commit();	
	    }else if (!runIt) {//component execution aborted
			errorAction.perform(dbConnection.getConnection(getId()));
			if (errorAction == ConnectionAction.ROLLBACK) {
				logger.info("Rollback performed.");
				logger.info("Number of commited records: " + (recCount / recordsInCommit)*recordsInCommit);
//				logger.info("Last " + recCount % recordsInCommit + " records not commited");
			}else if (errorAction == ConnectionAction.COMMIT){
				logger.info("Number of commited records: " + ++recCount);
			}
	    }
	    
	}


	private void runInBatchMode() throws SQLException,InterruptedException,IOException, JetelException{
	    int batchCount=0;
    	int statementCount=0;
    	String errmes = "";
    	SQLException exception = null;
	    DataRecordMetadata rejectedMetadata = null;
	    if (rejectedPort != null) {
	    	rejectedMetadata = rejectedPort.getMetadata();
	    }
	    DataRecord[][] dataRecordHolder;
	    int holderCount= -1;
		BatchUpdateException[] exceptions = new BatchUpdateException[statement.length];
		boolean exThrown;
	    
        // first, we set transMap to batchUpdateMode
		for (SQLCloverStatement eachStatement : statement) {
			eachStatement.setBatchUpdate(true);
		}
		
	    // if we have rejected records port connected, we will
	    // store and report error records in batch
	    if (rejectedPort!=null){
	        dataRecordHolder=new DataRecord[statement.length][batchSize];
	        for (int i = 0; i < statement.length; i++) {
				for (int j = 0; j < batchSize; j++) {
					dataRecordHolder[i][j] = new DataRecord(rejectedMetadata);
					dataRecordHolder[i][j].init();
				}
			}
	    }else{
	        dataRecordHolder=null;
	    }
	    
	    while ((inRecord = inPort.readRecord(inRecord)) != null && runIt) {
			holderCount++;
			for (statementCount = 0; statementCount < statement.length; statementCount++) {
				try{
					statement[statementCount].addBatch();
					//prepare prospective rejected record
	                if (dataRecordHolder!=null) {
	                	dataRecordHolder[statementCount][holderCount].copyFrom(inRecord);
						if (fillError) {
							dataRecordHolder[statementCount][holderCount].getField(rejectedMetadata.getNumFields() - 1).reset();
						}
	                }
				}catch(SQLException ex){
	               countError++;
	               exception = ex;
	               errmes = "Exeption thrown by: " + statement[statementCount].getQuery() + ". Message: " + ex.getMessage();
	               //for this record statement won't be executed 
	               dataRecordHolder[statementCount][holderCount] = null;
					if (rejectedPort != null) {
						rejectedRecord.copyFrom(inRecord);
						if (fillError) {
							rejectedRecord.getField(rejectedRecord.getNumFields() - 1).setValue(errmes);
						}
						rejectedPort.writeRecord(rejectedRecord);
					}
					if (countError <= MAX_WARNINGS) {
						logger.warn(errmes);
					}else if (countError == MAX_WARNINGS + 1){
						logger.warn("more errors...");
					}
				}
			}
			if (countError>maxErrors && maxErrors!=-1){
				logger.info("Number of commited records: " + recCount);
                throw new JetelException("Maximum # of errors exceeded when inserting record. "+ errmes, exception);
            }
			
            // shall we commit ?
	        if (++batchCount % batchSize == 0) {
	        	exThrown = false;
				for (statementCount = 0; statementCount < statement.length; statementCount++) {
		            try {
							statement[statementCount].executeBatch();
							statement[statementCount].clearBatch();
		            } catch (BatchUpdateException ex) {
		                statement[statementCount].clearBatch();
		                exceptions[statementCount] = ex;
		                exception = ex;
		                errmes = "Exeption thrown by: " + statement[statementCount].getQuery() + ". Message: " + ex.getMessage();
		                exThrown = true;
		            }
		        }
				//all statements executed, some of them could fail
				if (exThrown) {
					flushErrorRecords(dataRecordHolder, holderCount, exceptions, rejectedPort);
					if (countError>maxErrors && maxErrors!=-1){
						errorAction.perform(dbConnection.getConnection(getId()));
						if (errorAction == ConnectionAction.ROLLBACK) {
							logger.info("Rollback performed.");
							logger.info("Number of commited records: " + (recCount / recordsInCommit)*recordsInCommit);
//							logger.info("Last " + batchCount + " records not commited");
						}else if (errorAction == ConnectionAction.COMMIT){
							logger.info("Number of commited records: " + ++recCount);
						}
	                    throw new JetelException("Maximum # of errors exceeded when executing batch. " + errmes, exception);
	                }
				}
	            batchCount = 0;
	            holderCount=-1;
			}
	        if (++recCount % recordsInCommit == 0) {
	            if (batchCount!=0){
	            	exThrown = false;
					for (statementCount = 0; statementCount < statement.length; statementCount++) {
			            try {
							statement[statementCount].executeBatch();
							statement[statementCount].clearBatch();
			            } catch (BatchUpdateException ex) {
			                statement[statementCount].clearBatch();
			                exceptions[statementCount] = ex;
			                exception = ex;
			                errmes = "Exeption thrown by: " + statement[statementCount].getQuery() + ". Message: " + ex.getMessage();
			                exThrown = true;
			            }
			        }
					//all statements executed, some of them could fail
					if (exThrown){
						flushErrorRecords(dataRecordHolder, holderCount, exceptions, rejectedPort);
						if (countError>maxErrors && maxErrors!=-1){
							errorAction.perform(dbConnection.getConnection(getId()));
							if (errorAction == ConnectionAction.ROLLBACK) {
								logger.info("Rollback performed.");
								logger.info("Number of commited records: " + (recCount / recordsInCommit)*recordsInCommit);
//								logger.info("Last " + recCount % recordsInCommit + " records not commited");
							}else if (errorAction == ConnectionAction.COMMIT){
								logger.info("Number of commited records: " + recCount);
							}
		                    throw new JetelException("Maximum # of errors exceeded when executing batch. " + errmes, 
		                    		exception);
		                }
					}
		            batchCount = 0;
		            holderCount=-1;
	            }
	            dbConnection.getConnection(getId()).commit();
		    }
            SynchronizeUtils.cloverYield();
	    }
	    
		// final commit (if anything is left in batch)
	    exThrown = false;
	    for (statementCount = 0; statementCount < statement.length; statementCount++) {
			try {
				statement[statementCount].executeBatch();
			} catch (BatchUpdateException ex) {
                exceptions[statementCount] = ex;
                exception = ex;
                errmes = "Exeption thrown by: " + statement[statementCount].getQuery() + ". Message: " + ex.getMessage();
                exThrown = true;
			}
		}
		//all statements executed, some of them could fail
		if (exThrown) {
			flushErrorRecords(dataRecordHolder, holderCount, exceptions, rejectedPort);
			if (countError > maxErrors && maxErrors != -1) {
//			    if (dataRecordHolder!=null) {
//			        Arrays.fill(dataRecordHolder,null);
//		        	Arrays.fill(exeptions, null);
//			    }
				errorAction.perform(dbConnection.getConnection(getId()));
				if (errorAction == ConnectionAction.ROLLBACK) {
					logger.info("Rollback performed.");
					logger.info("Number of commited records: " + (recCount / recordsInCommit)*recordsInCommit);
//					logger.info("Last " + recCount % recordsInCommit + " records not commited");
				}else if (errorAction == ConnectionAction.COMMIT){
					logger.info("Number of commited records: " + recCount);
				}
				throw new JetelException("Maximum # of errors exceeded when executing batch. " + errmes, exception);
			}
		}
		// unless we have option never to commit, commit at the end of processing
	    if (runIt && recordsInCommit!=Integer.MAX_VALUE){
	    	dbConnection.getConnection(getId()).commit();
	    }else if (!runIt) {
			errorAction.perform(dbConnection.getConnection(getId()));
			if (errorAction == ConnectionAction.ROLLBACK) {
				logger.info("Rollback performed.");
				logger.info("Number of commited records: " + (recCount / recordsInCommit)*recordsInCommit);
//				logger.info("Last " + recCount % recordsInCommit + " records not commited");
			}else if (errorAction == ConnectionAction.COMMIT){
				logger.info("Number of commited records: " + recCount);
			}
	    }
//	    if (dataRecordHolder!=null) {
//	        Arrays.fill(dataRecordHolder,null);
//        	Arrays.fill(exeptions, null);
//	    }
	}
	
    
    /**
     * This method sends error records to output and counts errors. If array <i>records</i> is null, only counting of errors is performed  
     * 
     * @param records potential rejected records
     * @param recCount number of records in batch
     * @param ex thrown exception
     * @param port rejected Port
     * @throws IOException
     * @throws InterruptedException
     */
    private void flushErrorRecords(DataRecord[][] records,int recCount, BatchUpdateException[] ex, OutputPort port) 
    throws IOException,InterruptedException {

//        if (records==null) return;
        
        int[] updateCounts;
        int count;
        SQLException exception;
        StringBuilder message = new StringBuilder();
        int lastField = records != null ? port.getMetadata().getNumFields() - 1 : -1;

        //for each statement exception has occurred
        for (int i=0; i < ex.length; i++) {
			if (ex[i] != null) {
				exception = ex[i];
				updateCounts = ex[i].getUpdateCounts();
				count = 0;
		        while(count<updateCounts.length){
					if (updateCounts[count] == Statement.EXECUTE_FAILED) {
						//increase error counter, fill rejected record and log error message
						countError++;
						if (records != null && records[i][count] != null) {
							if (exception != null && fillError) {
								records[i][count].getField(lastField).setValue("Exeption thrown by: " + 
										statement[i].getQuery() + ". Message: " + exception.getMessage());
							}
							if (exception != null && countError <= MAX_WARNINGS) {
								logger.warn("Exeption thrown by: " + statement[i].getQuery() + 
										". Message: " + exception.getMessage());
							} else if (exception == null && countError <= MAX_WARNINGS) {
								logger.warn("Record not inserted to database");
							} else if (countError == MAX_WARNINGS + 1) {
								logger.warn("more errors...");
							}
							port.writeRecord(records[i][count]);
							if (exception != null) {
								exception = exception.getNextException();
							}
						}else if (records != null){//records[i][count] == null - it wasn't added to batch, prepare for next batch
							records[i][count] = new DataRecord(port.getMetadata());
							records[i][count].init();
						}
					}
					count++;
		        }
		        // flush rest of the records for which we don't have update counts
		        message.setLength(0);
		    	while (exception != null) {
		    		message.append(exception.getMessage());
		    		exception = exception.getNextException();
		    	}
		        while(count<recCount){
		    		if (records != null && records[i][count] != null) {
						if (message.length() > 0 && countError <= MAX_WARNINGS) {
							logger.warn(message);
						} else if (message.length() > 0
								&& countError == MAX_WARNINGS + 1) {
							logger.warn("more errors...");
						}
						if (message.length() > 0 && fillError && i < recCount) {
							records[i][count].getField(lastField).setValue(message);
						}
						message = new StringBuilder("Record not inserted to database");
						countError++;
						port.writeRecord(records[i][count]);
					}else if (records != null){
						records[i][count] = new DataRecord(port.getMetadata());
						records[i][count].init();
					}
					count++;
		        }
			}
		}

        //clear errors
        Arrays.fill(ex, null);
    }
	
	/**
	 *  Description of the Method
	 *
	 * @return    Description of the Returned Value
	 * @since     September 27, 2002
	 */
	@Override public void toXML(Element xmlElement) {
		super.toXML(xmlElement);
		if (dbConnectionName != null) {
			xmlElement.setAttribute(XML_DBCONNECTION_ATTRIBUTE, dbConnectionName);
		}
		if (sqlQuery != null) {
			xmlElement.setAttribute(XML_SQLQUERY_ATRIBUTE, StringUtils.stringArraytoString(sqlQuery, Defaults.Component.KEY_FIELDS_DELIMITER.charAt(0)));
		}
		if (dbTableName != null) {
			xmlElement.setAttribute(XML_DBTABLE_ATTRIBUTE, dbTableName);
		}
		
		if (dbFields != null) {
			StringBuffer buf = new StringBuffer(dbFields[0]);
			for (int i=1; i< dbFields.length; i++ ) {
				buf.append(Defaults.Component.KEY_FIELDS_DELIMITER + dbFields[i]);
			}
			xmlElement.setAttribute(XML_DBFIELDS_ATTRIBUTE, buf.toString());
		}
		
		if (cloverFields != null) {
			StringBuffer buf = new StringBuffer(cloverFields[0]);
			for (int i=1; i< cloverFields.length; i++ ) {
				buf.append(Defaults.Component.KEY_FIELDS_DELIMITER + cloverFields[i]);
			}
			xmlElement.setAttribute(XML_DBFIELDS_ATTRIBUTE, buf.toString());
		}
		if (recordsInCommit > 0) {
			xmlElement.setAttribute(XML_COMMIT_ATTRIBUTE,String.valueOf(recordsInCommit));
		}
		
		xmlElement.setAttribute(XML_BATCHMODE_ATTRIBUTE, String.valueOf(useBatch));
		
		xmlElement.setAttribute(XML_BATCHSIZE_ATTRIBUTE, String.valueOf(batchSize));
		
		xmlElement.setAttribute(XML_MAXERRORS_ATRIBUTE, String.valueOf(maxErrors));
		
		if (autoGeneratedColumns != null) {
			StringBuilder tmp = new StringBuilder(autoGeneratedColumns[0]);
			for (int i = 1; i < autoGeneratedColumns.length; i++) {
				tmp.append(Defaults.Component.KEY_FIELDS_DELIMITER + autoGeneratedColumns[i]);
			}
			xmlElement.setAttribute(XML_AUTOGENERATEDCOLUMNS_ATTRIBUTE, tmp.toString());
		}
		
		xmlElement.setAttribute(XML_ACTION_ON_ERROR, errorAction.toString());
	}
	
	/**
	 *  Description of the Method
	 *
	 * @param  nodeXML  Description of Parameter
	 * @return          Description of the Returned Value
	 * @since           September 27, 2002
	 */
     public static Node fromXML(TransformationGraph graph, Element xmlElement) throws XMLConfigurationException {
		ComponentXMLAttributes xattribs = new ComponentXMLAttributes(xmlElement, graph);
		ComponentXMLAttributes xattribsChild;
		org.w3c.dom.Node childNode;
		DBOutputTable outputTable;

		try {
			// allows specifying parameterized SQL (with ? - question marks)
			if (xattribs.exists(XML_SQLQUERY_ATRIBUTE)) {
					outputTable = new DBOutputTable(xattribs.getString(XML_ID_ATTRIBUTE),
					xattribs.getString(XML_DBCONNECTION_ATTRIBUTE),
					xattribs.getString(XML_SQLQUERY_ATRIBUTE).split(STATEMENT_SEPARATOR));
			}else if(xattribs.exists(XML_URL_ATTRIBUTE)){
				outputTable = new DBOutputTable(xattribs.getString(XML_ID_ATTRIBUTE),
						xattribs.getString(XML_DBCONNECTION_ATTRIBUTE),
						xattribs.resolveReferences(FileUtils.getStringFromURL(graph.getRuntimeParameters().getProjectURL(), 
								xattribs.getString(XML_URL_ATTRIBUTE), xattribs.getString(XML_CHARSET_ATTRIBUTE, null))).split(STATEMENT_SEPARATOR));
			}else if(xattribs.exists(XML_DBTABLE_ATTRIBUTE)){
				outputTable = new DBOutputTable(xattribs.getString(XML_ID_ATTRIBUTE),
						xattribs.getString(XML_DBCONNECTION_ATTRIBUTE),
						xattribs.getString(XML_DBTABLE_ATTRIBUTE));
			}else{
			    childNode = xattribs.getChildNode(xmlElement, XML_SQLCODE_ELEMENT);
                if (childNode == null) {
                    throw new XMLConfigurationException(COMPONENT_TYPE + ":" + xattribs.getString(XML_ID_ATTRIBUTE," unknown ID ") + ": Can't find <SQLCode> node !");
                }
                xattribsChild = new ComponentXMLAttributes((Element)childNode, graph);
                outputTable = new DBOutputTable(xattribs.getString(XML_ID_ATTRIBUTE),
    					xattribs.getString(XML_DBCONNECTION_ATTRIBUTE),
    					xattribsChild.getText(childNode).split(STATEMENT_SEPARATOR));
			}
			
			
			if (xattribs.exists(XML_DBTABLE_ATTRIBUTE)) {
				outputTable.setDBTableName(xattribs.getString(XML_DBTABLE_ATTRIBUTE));
			}
			if (xattribs.exists(XML_FIELDMAP_ATTRIBUTE)){
				String[] pairs = xattribs.getString(XML_FIELDMAP_ATTRIBUTE).split(Defaults.Component.KEY_FIELDS_DELIMITER_REGEX);
				String[] cloverFields = new String[pairs.length];
				String[] dbFields = new String[pairs.length];
				int equalIndex;
				for (int i=0;i<pairs.length;i++){
					equalIndex = pairs[i].indexOf('=');
					cloverFields[i] = pairs[i].substring(0,equalIndex);
					dbFields[i] = (pairs[i].substring(equalIndex +1));
				}
				outputTable.setCloverFields(cloverFields);
				outputTable.setDBFields(dbFields);
			}else {
				if (xattribs.exists(XML_DBFIELDS_ATTRIBUTE)) {
					outputTable.setDBFields(xattribs.getString(XML_DBFIELDS_ATTRIBUTE).split(Defaults.Component.KEY_FIELDS_DELIMITER_REGEX));
				}
	
				if (xattribs.exists(XML_CLOVERFIELDS_ATTRIBUTE)) {
					outputTable.setCloverFields(xattribs.getString(XML_CLOVERFIELDS_ATTRIBUTE).split(Defaults.Component.KEY_FIELDS_DELIMITER_REGEX));
				}
			}
			if (xattribs.exists(XML_COMMIT_ATTRIBUTE)) {
				outputTable.setRecordsInCommit(xattribs.getInteger(XML_COMMIT_ATTRIBUTE));
			}
			
			if (xattribs.exists(XML_BATCHMODE_ATTRIBUTE)) {
				outputTable.setUseBatch(xattribs.getBoolean(XML_BATCHMODE_ATTRIBUTE));
			}
			if (xattribs.exists(XML_BATCHSIZE_ATTRIBUTE)) {
				outputTable.setBatchSize(xattribs.getInteger(XML_BATCHSIZE_ATTRIBUTE));
			}
			if (xattribs.exists(XML_MAXERRORS_ATRIBUTE)){
				outputTable.setMaxErrors(xattribs.getInteger(XML_MAXERRORS_ATRIBUTE));
			}
			if (xattribs.exists(XML_AUTOGENERATEDCOLUMNS_ATTRIBUTE)){
				outputTable.setAutoGeneratedColumns(xattribs.getString(XML_AUTOGENERATEDCOLUMNS_ATTRIBUTE).split(Defaults.Component.KEY_FIELDS_DELIMITER_REGEX));
			}
			if (xattribs.exists(XML_ACTION_ON_ERROR)){
				outputTable.setErrorAction(xattribs.getString(XML_ACTION_ON_ERROR));
			}
			
			return outputTable;
			
		} catch (Exception ex) {
            throw new XMLConfigurationException(COMPONENT_TYPE + ":" + xattribs.getString(XML_ID_ATTRIBUTE," unknown ID ") + ":" + ex.getMessage(),ex);
        }
	}


	/**
	 *  Description of the Method
	 *
	 * @return    Description of the Return Value
	 */
     @Override
     public ConfigurationStatus checkConfig(ConfigurationStatus status) {
         super.checkConfig(status);
         
         checkInputPorts(status, 1, 1);
         checkOutputPorts(status, 0, 2);

    	 boolean isQueryNull = sqlQuery == null;
         try {
             init();
             free();
         } catch (ComponentNotReadyException e) {
             ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
             if(!StringUtils.isEmpty(e.getAttributeName())) {
                 problem.setAttributeName(e.getAttributeName());
             }
             status.add(problem);
         }finally{
             if (isQueryNull) {
            	 sqlQuery = null;
             }        	 
         }
         
         return status;
    }

	public String getType(){
		return COMPONENT_TYPE;
	}
	
	/**
	 * @param maxErrors Maximum number of tolerated SQL errors during component run. Default: 0 (zero)
	 */
	public void setMaxErrors(int maxErrors) {
		this.maxErrors = maxErrors;
	}

	/**
	 * @param autoGeneratedColumns names of db columns to get back from database
	 */
	public void setAutoGeneratedColumns(String[] autoGeneratedColumns) {
		this.autoGeneratedColumns = autoGeneratedColumns;
	}
	
	public String[] getAutoGeneratedColumns() {
		return autoGeneratedColumns;
	}

	public void setErrorAction(ConnectionAction errorAction) {
		this.errorAction = errorAction;
	}
	
	public void setErrorAction(String errorAction) {
		this.errorAction = ConnectionAction.valueOf(errorAction);
	}

}
	
