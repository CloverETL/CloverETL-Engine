/*
*    jETeL/Clover - Java based ETL application framework.
*    Copyright (C) 2002-04  David Pavlis <david_pavlis@hotmail.com>
*    
*    This library is free software; you can redistribute it and/or
*    modify it under the terms of the GNU Lesser General Public
*    License as published by the Free Software Foundation; either
*    version 2.1 of the License, or (at your option) any later version.
*    
*    This library is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    
*    Lesser General Public License for more details.
*    
*    You should have received a copy of the GNU Lesser General Public
*    License along with this library; if not, write to the Free Software
*    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*/
package org.jetel.component;

import java.io.IOException;
import java.sql.BatchUpdateException;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Arrays;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jetel.connection.jdbc.ConnectionAction;
import org.jetel.connection.jdbc.DBConnection;
import org.jetel.connection.jdbc.SQLCloverStatement;
import org.jetel.connection.jdbc.SQLUtil;
import org.jetel.connection.jdbc.SQLCloverStatement.QueryType;
import org.jetel.connection.jdbc.specific.DBConnectionInstance;
import org.jetel.connection.jdbc.specific.JdbcSpecific.OperationType;
import org.jetel.data.DataRecord;
import org.jetel.data.Defaults;
import org.jetel.database.IConnection;
import org.jetel.exception.ComponentNotReadyException;
import org.jetel.exception.ConfigurationProblem;
import org.jetel.exception.ConfigurationStatus;
import org.jetel.exception.JetelException;
import org.jetel.exception.XMLConfigurationException;
import org.jetel.graph.InputPort;
import org.jetel.graph.Node;
import org.jetel.graph.OutputPort;
import org.jetel.graph.Result;
import org.jetel.graph.TransformationGraph;
import org.jetel.metadata.DataFieldMetadata;
import org.jetel.metadata.DataRecordMetadata;
import org.jetel.util.MultiFileReader;
import org.jetel.util.SynchronizeUtils;
import org.jetel.util.file.FileUtils;
import org.jetel.util.joinKey.JoinKeyUtils;
import org.jetel.util.property.ComponentXMLAttributes;
import org.jetel.util.string.StringUtils;
import org.w3c.dom.Element;

/**
 *  <h3>DatabaseOutputTable Component</h3>
 * <!-- This component performs DML operation on specified database table (insert/update/delete). -->
 *
 * <table border="1">
 * <th>Component:</th>
 * <tr><td><h4><i>Name:</i></h4></td>
 * <td>DBOutputTable</td></tr>
 * <tr><td><h4><i>Category:</i></h4></td>
 * <td></td></tr>
 * <tr><td><h4><i>Description:</i></h4></td>
 * <td>This component performs specified DML operation (insert/update/delete) on specified database table.<br>
 *   Parameter placeholder in DML statement is [?] - question mark</td></tr>
 * <tr><td><h4><i>Inputs:</i></h4></td>
 * <td>[0]- input records</td></tr>
 * <tr><td><h4><i>Outputs:</i></h4></td>
 * <td>[0] <i>optional</i> - records rejected by database. If in this metadata there is more fields then in input metadata
 * and last field is of type string, this field is filled by error message<br>
 * 	   [1] <i>optional</i> - autogenerated columns:
 * <ul><li>autogenerated columns for <i>insert</i> statement (supported only for Oracle, MySQL, Db2 and Informix
 *  databases, not supported in batch mode at all)</li>
 *  <li>number of updated records in database and requested input fields for <i>update, delete</i> statement</li></ul>
 *  Key record is generated for <b>each</b> input record. In case that
 *  statement execution fails, requested fields are not filled.</td></tr>
 * <tr><td><h4><i>Comment:</i></h4></td>
 * <td></td></tr>
 * </table>
 *  <br>
 *  <table border="1">
 *  <th>XML attributes:</th>
 *  <tr><td><b>type</b></td><td>"DB_OUTPUT_TABLE"</td></tr>
 *  <tr><td><b>id</b></td><td>component identification</td></tr>
 *  <tr><td><b>dbConnection</b></td><td>id of the Database Connection object to be used to access the database</td>
 *  <tr><td><b>dbTable</b><br><i>optional</i></td><td>name of the DB table to populate data with</td>
 *  <tr><td><b>sqlQuery</b><br><i>optional</i></td><td>allows specification of SQL query/DML statement to be executed against
 *  database. It can consist of more then one query separated by semicolon [;]. Question marks [?] in the query text 
 *  are placeholders which are filled with values from input fields specified in <b>cloverFields</b>
 *  attribute. If you have query in this form, <i>cloverFields</i> must be specified as well - it determines which input fields will
 *  be used/mapped onto target fields. You can write query with direct mapping too: instead of placeholders use clover field's names 
 *  predated by dollar char [$]. In such form you can use mapping between generated keys and output record with this keys too.
 *  Complete query should appear as follows:<br><ul>
 *  <li><code>insert into mytable [(f1,f2,...,fn)] values (val1, $field2, ...,$fieldm ) returning $key := dbfield1, $field := dbfield2</code> - 
 *  where <i>f1,f2,...,fn,dbfield1,dbfield2</i> are database fields; <i>field2,.., fieldm</i> are input record fields 
 *  and <i>key, field</i> are key record fields. <b>This is valid for databases which can return more then 
 *  one columns in <i>getGeneratedKeys()</i> method (Oracle and db2 for the time beeing). </b> </li>
 *  <li><code>insert into mytable [(f1,f2,...,fn)] values (val1, $field2, ...,$fieldm ) returning $key := auto_generated, $field := infield</code> - 
 *  where <i>f1,f2,...,fn</i> are database fields; <i>field2,.., fieldm, infield</i> are input record fields, 
 *  <i>auto_generated</i>  is auto genereted column value returned by database and <i>key, field</i> are key record 
 *  fields. <b>This is valid for databases which returns one auto generated column in <i>getGeneratedKeys()</i> method 
 *  (MySql and Informix for the time being). </b> </li>
 *  <li><code>delete from mytable where f1 = $field1 and ... fn = $fieldn returning $updated:=update_count, $field:=infield</code> - where <i>f1,..,fn</i> are database
 *  fields, <i>field1,...,fieldn, infield</i> are input record fields, <i>updated, field</i> are output record's fields and
 *  <i>update_count</i> means number of updated records in database by current statement</li>
 *  <li><code>update mytable set f1 = $field1,...,fn=$fieldn where db1=$f1 returning $updated:=update_count, $field:=infield</code> - where <i>f1,..,fn, db1</i> are database
 *  fields, <i>field1,...,fieldn, infield</i> are input record fields, <i>updated, field</i> are output record's fields and
 *  <i>update_count</i> means number of updated records in database by current statement</li></ul>
 *  <tr><td><b>url</b><br><i>optional</i></td><td>url location of the query. The query will be loaded from file referenced by the url. 
 *  Rules for extern query are the same as for <i>sqlQuery</i> parameter.</td>
 *  <tr><td><b>charset </b><i>optional</i></td><td>encoding of extern query</td></tr>
 * <tr><td>&lt;SQLCode&gt;<br><i>optional<small>!!XML tag!!</small></i></td><td>This tag allows for embedding large SQL statement directly into graph.. See example below.</td></tr>
 *  <tr><td><b>fieldMap</b><br><i>optional</i></td><td>Pairs of clover fields and db fields (cloverField=dbField) separated by :;| {colon, semicolon, pipe}.<br>
 *  It specifies mapping from source (Clover's) fields to DB table fields if it isn't specified in <i>sqlQuery</i>. It should be used instead of <i>cloverFields</i> and <i>dbFields</i>
 *  attributes, because it provides more clear mapping. If <i>fieldMap</i> attribute is found <i>cloverFields</i> and <i>dbFields</i> attributes are ignored.
 *  <tr><td><b>dbFields</b><br><i>optional</i></td><td>delimited list of target table's fields to be populated<br>
 *  Input fields are mapped onto target fields (listed) in the order they are present in Clover's record.</td>
 *  <tr><td><b>commit</b><br><i>optional</i></td><td>determines how many records are in one db commit. Minimum 1, DEFAULT is 100.<br>If
 * MAX_INT is specified, it is considered as NEVER COMMIT - i.e. records are send to DB without every issuing commit. It can
 * be called later from within other component - for example DBExecute.</td>
 *  <tr><td><b>cloverFields</b><br><i>optional</i></td><td>delimited list of input record's fields.<br>Only listed fields (in the order
 *  they appear in the list) will be considered for mapping onto target table's fields. Combined with <b>dbFields</b> option you can
 *  specify mapping from source (Clover's) fields to DB table fields. If no <i>dbFields</i> are specified, then #of <i>cloverFields</i> must
 *  correspond to number of target DB table fields.</td>
 *   <tr><td><b>autoGeneratedColumns</b><br><i>deprecated</i> - use <i>sqlQuery</i> extended form</td><td>
 *   This attribute can be used for obtaining auto generated columns, but only in case that <i>sqlQuery</i> consist
 *   of only <b>one</b> query. In other case construct queries with direct mapping. 
 *   <ul><li>For Oracle or Db2 database: names of database columns to be returned (for Db2 - entity columns)</li>
 *   <li>For MySQL or Informix database: names of input record fields plus special field called "AUTO_GENERATED" to be returned</td></tr>
 *  <tr><td><b>batchMode</b><br><i>optional</i></td><td>[Yes/No] determines whether to use batch mode for sending statements to DB, DEFAULT is No.<br>
 *  <i>Note:If your database/JDBC driver supports this feature, switch it on as it significantly speeds up table population.</i></td>
 *  </tr>
 * <tr><td><b>batchSize</b><br><i>optional</i></td><td>number - determines how many records will be sent to database in one batch update. Default is 25.
 * </td>
 *  </tr> 
 *   <tr><td><b>maxErrors</b><br><i>optional</i></td><td>maximum number of allowed SQL errors. Default: 0 (zero). If exceeded, component stops with error. If set to <b>-1</b>(minus one) all errors are ignored.</td></tr>
 *   <tr><td><b>errorAction</b><br><i>optional</i></td><td>ROLLBACK or COMMIT (case sensitive!!!). Default: COMMIT. 
 *   Action performed when exceeded maximum number of records or execution of the component is aborted.</td></tr>
 *  </table>
 *
 *  <h4>Example:</h4>
 *  <pre>&lt;Node id="OUTPUT" type="DB_OUTPUT_TABLE" dbConnection="NorthwindDB" dbTable="employee_z"/&gt;</pre>
 *  <br>
 *  <pre>&lt;Node id="OUTPUT" type="DB_OUTPUT_TABLE" dbConnection="NorthwindDB" dbTable="employee_z" dbFields="f_name;l_name;phone"/&gt;</pre>
 *  <i>Example above shows how to populate only selected fields within target DB table. It can be used for skipping target fields which
 *  are automatically populated by DB (such as autoincremented fields).</i>
 *  <br>
 *  <pre>&lt;Node id="OUTPUT" type="DB_OUTPUT_TABLE" dbConnection="NorthwindDB" dbTable="employee_z"
 *	   dbFields="f_name;l_name" cloverFields="LastName;FirstName"/&gt;</pre>
 *  <i>Example shows how to simply map Clover's LastName and FirstName fields onto f_name and l_name DB table fields. The order
 *  in which these fields appear in Clover data record is not important.</i>
 *  <br>
 *   <pre>&lt;Node id="OUTPUT" type="DB_OUTPUT_TABLE" dbConnection="NorthwindDB" sqlQuery="insert into myemployee2 (FIRST_NAME,LAST_NAME,DATE,ID) values (?,?,sysdate,123)"
 *	   cloverFields="FirstName;LastName"/&gt;</pre>
 *  <br>
 * <pre>&lt;Node id="OUTPUT" type="DB_OUTPUT_TABLE" dbConnection="NorthwindDB" cloverFields="FirstName;LastName"&gt;
 *  &lt;SQLCode&gt;
 *	insert into myemployee2 (FIRST_NAME,LAST_NAME,DATE,ID) values (?,?,sysdate,123)
 *  &lt;/SQLCode&gt;
 *  &lt;/Node&gt;</pre>
 *  <i>Example below shows how to delete records in table using DBOutputTable component</i>
 *  <pre>&lt;Node id="OUTPUT" type="DB_OUTPUT_TABLE" dbConnection="NorthwindDB" cloverFields="FirstName;LastName"&gt;
 *  &lt;SQLCode&gt;
 *  delete from myemployee2 where FIRST_NAME = ? and LAST_NAME = ?
 *  &lt;/SQLCode&gt;
 *  &lt;/Node&gt;</pre>
 * <br>
 *  <i>Example below shows usage of "fieldMap" attribute </i>
 * <pre>&lt;Node dbConnection="DBConnection0" dbTable="employee_tmp" fieldMap=
 * "EMP_NO=emp_no;FIRST_NAME=first_name;LAST_NAME=last_name;PHONE_EXT=phone_ext"
 * id="OUTPUT" type="DB_OUTPUT_TABLE"/&gt;</pre>
 * <br>
 * <i>Examples below show how to get aoutogenerated columns</i>
 * <pre>
 * &lt;Node dbConnection="Connection1" id="OUTPUT" maxErrors="10" sqlQuery=
 * "INSERT INTO CLOVER_USER (U_ID,NAME ,CREATED) values ($EMP_NO, $FULL_NAME,  $HIRE_DATE);
 *  INSERT INTO MYEMPLOYEE (EMP_NO, FIRST_NAME, LAST_NAME,COUNTRY, SALARY, FULL_NAME) VALUES 
 *                         ($EMP_NO, $FIRST_NAME, $LAST_NAME, $COUNTRY, $SALARY, $FULL_NAME) 
 *                         RETURNING $id:=auto_generated, $Field2:=full_name;" type="DB_OUTPUT_TABLE"/&gt;
 * 
 * &lt;Node dbConnection="Connection1" id="OUTPUT" maxErrors="10" sqlQuery=
 * "DELETE FROM CLOVER_USER WHERE U_ID = $EMP_NO;
 *  INSERT INTO MYEMPLOYEE (ID, EMP_NO, FIRST_NAME, LAST_NAME,COUNTRY, SALARY, FULL_NAME) VALUES 
 *                         (id_seq.nextval, $EMP_NO, $FIRST_NAME, $LAST_NAME, $COUNTRY, $SALARY, $FULL_NAME) 
 *                         RETURNING $id:=ID, $Field2:=FIRST_NAME;" type="DB_OUTPUT_TABLE" errorAction="ROLLBACK"/&gt;
 * 
 *&lt;Node autoGeneratedColumns="AUTO_GENERATED;FIRST_NAME;" dbConnection="DBConnection2" id="OUTPUT" maxErrors="10" 
 *	sqlQuery="INSERT INTO myemployee (EMP_NO, FIRST_NAME, LAST_NAME, PHONE_EXT, HIRE_DATE, DEPT_NO, JOB_CODE, JOB_GRADE, JOB_COUNTRY, SALARY, FULL_NAME) 
 *	VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)" type="DB_OUTPUT_TABLE"/&gt;
 *
 *&lt;Node autoGeneratedColumns="ID;FIRST_NAME;" batchMode="false" dbConnection="DBConnection1" 
 *	dbTable="MYEMPLOYEE" id="OUTPUT" maxErrors="10" sqlQuery="INSERT INTO myemployee VALUES (id_seq.nextval, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)" 
 *	type="DB_OUTPUT_TABLE"/&gt;
 *
 *<i>Example below show how to get number of updated records in database</i>
 * <pre>
 *&lt;Node batchMode="false" commit="10" dbConnection="Connection1" errorAction="ROLLBACK" id="OUTPUT" maxErrors="10" 
 *	sqlQuery="update customers  set prijmeni =$LAST_NAME  where klient_id_NO=$EMP_NO returning $id:=update_count, $Field2:=FULL_NAME;" 
 *	type="DB_OUTPUT_TABLE"/&gt;
 * </pre>
 * @author      dpavlis, avackova (agata.vackova@javlinconsulting.cz)
 * @since       September 27, 2002
 * @revision    $Revision$
 * @created     22. July 2003
 * @see         org.jetel.database.AnalyzeDB
 */
public class DBOutputTable extends Node {
	
	public static final String XML_MAXERRORS_ATRIBUTE = "maxErrors";
	public static final String XML_BATCHMODE_ATTRIBUTE = "batchMode";
	public static final String XML_COMMIT_ATTRIBUTE = "commit";
	public static final String XML_FIELDMAP_ATTRIBUTE = "fieldMap";
	public static final String XML_CLOVERFIELDS_ATTRIBUTE = "cloverFields";
	public static final String XML_DBFIELDS_ATTRIBUTE = "dbFields";
	public static final String XML_SQLCODE_ELEMENT = "SQLCode";
	public static final String XML_DBTABLE_ATTRIBUTE = "dbTable";
	public static final String XML_DBCONNECTION_ATTRIBUTE = "dbConnection";
	public static final String XML_SQLQUERY_ATRIBUTE = "sqlQuery";
	public static final String XML_BATCHSIZE_ATTRIBUTE = "batchSize";
	public static final String XML_URL_ATTRIBUTE = "url";
	public static final String XML_CHARSET_ATTRIBUTE = "charset";
	public static final String XML_AUTOGENERATEDCOLUMNS_ATTRIBUTE = "autoGeneratedColumns";
	public static final String XML_ACTION_ON_ERROR = "errorAction";
	
	public static final String STATEMENT_SEPARATOR = ";";
	
	private static final Pattern CLOVER_FIELDS_PATTERN = Pattern.compile(Defaults.CLOVER_FIELD_REGEX);//$cloverField

	private DBConnection dbConnection;
	private DBConnectionInstance connection;
	private String dbConnectionName;
	private String dbTableName;
	private SQLCloverStatement[] statement;
	private String[] cloverFields;
	private String[] dbFields;
	private String[] sqlQuery;
	private int recordsInCommit;
	private int maxErrors;
	private boolean useBatch;
	private int batchSize;
    private int countError=0;
	private String[] autoGeneratedColumns = null;
	private boolean[] returnResult;
	private ConnectionAction errorAction = ConnectionAction.COMMIT;
	
	private InputPort inPort;
	private OutputPort rejectedPort, keysPort;
	private DataRecord inRecord, rejectedRecord, keysRecord;
	private int recCount = 0;
	private int errorCodeFieldNum;
	private int errMessFieldNum;
	
	/**  Description of the Field */
	public final static String COMPONENT_TYPE = "DB_OUTPUT_TABLE";
	private final static int SQL_FETCH_SIZE_ROWS = 100;
	private final static int READ_FROM_PORT = 0;
	private final static int WRITE_REJECTED_TO_PORT = 0;
	private final static int WRITE_AUTO_KEY_TO_PORT = 1;
	private final static int RECORDS_IN_COMMIT = 100;
	private final static int RECORDS_IN_BATCH = 25;
	private final static int MAX_BATCH_SIZE = 10000;
	private final static int MAX_ALLOWED_ERRORS = 0;
	private final static int MAX_WARNINGS = 3;
	
	static Log logger = LogFactory.getLog(DBOutputTable.class);

	/**
	 *  Constructor for the DBInputTable object
	 *
	 * @param  id                Unique ID of component
	 * @param  dbConnectionName  Name of Clover's database connection to be used for communicating with DB
	 * @param  dbTableName       Name of target DB table to be populated with data
	 * @since                    September 27, 2002
	 */
	public DBOutputTable(String id, String dbConnectionName, String dbTableName) {
		this(id,dbConnectionName);
		this.dbTableName = dbTableName;
	}

	/**
	 * @param id Unique ID of component
	 * @param dbConnectionName Name of Clover's database connection to be used for communicating with DB
	 * @param sqlQuery set of sql queries
	 */
	public DBOutputTable(String id, String dbConnectionName, String[] sqlQuery) {
		this(id,dbConnectionName);
		this.sqlQuery=sqlQuery;
	}
	
	/**
	 * Constructor for the DBInputTable object
	 * @param id				Unique ID of component
	 * @param dbConnectionName	Name of Clover's database connection to be used for communicating with DB
	 * @param sqlQuery			SQL query to be executed against DB - can be any DML command (INSERT, UPDATE, DELETE)
	 * @param cloverFields		Array of Clover field names (the input data) which should substitute DML command parameters (i.e. "?")
	 */
	@Deprecated
	public DBOutputTable(String id, String dbConnectionName, String sqlQuery, String[] cloverFields) {
		this(id, dbConnectionName, new String[]{sqlQuery});
		setCloverFields(cloverFields);
	}
	
	/**
	 * Constructor for the DBInputTable object
	 */
	DBOutputTable(String id, String dbConnectionName){
		super(id);
		this.dbConnectionName = dbConnectionName;
		this.dbTableName = null;
		cloverFields = null;
		dbFields = null;
		recordsInCommit = RECORDS_IN_COMMIT;
		maxErrors=MAX_ALLOWED_ERRORS;
		useBatch=false;
		batchSize=RECORDS_IN_BATCH;
	}
	
	/**
	 *  Sets the dBFields attribute of the DBOutputTable object
	 *
	 * @param  dbFields  The new dBFields value
	 */
	public void setDBFields(String[] dbFields) {
		this.dbFields = dbFields;
	}


	/**
	 *  Sets the useBatch attribute of the DBOutputTable object
	 *
	 * @param  batchMode  The new useBatch value
	 */
	public void setUseBatch(boolean batchMode) {
		this.useBatch = batchMode;
	}

	/**
	 * Sets batch size - how many records are in batch which is sent
	 * to DB at once.
	 * @param batchSize
	 */
	public void setBatchSize(int batchSize){
	    this.batchSize=batchSize;
	}

	/**
	 *  Sets the cloverFields attribute of the DBOutputTable object
	 *
	 * @param  cloverFields  The new cloverFields value
	 */
	public void setCloverFields(String[] cloverFields) {
		this.cloverFields = cloverFields;
	}


	/**
	 *  Description of the Method
	 *
	 * @exception  ComponentNotReadyException  Description of Exception
	 * @since                                  September 27, 2002
	 */
	public void init() throws ComponentNotReadyException {
		super.init();
		// get dbConnection from graph
        IConnection conn = getGraph().getConnection(dbConnectionName);
        if(conn == null) {
            throw new ComponentNotReadyException("Can't find DBConnection ID: " + dbConnectionName);
        }
        if(!(conn instanceof DBConnection)) {
            throw new ComponentNotReadyException("Connection with ID: " + dbConnectionName + " isn't instance of the DBConnection class.");
        }
        dbConnection = (DBConnection) conn;
		dbConnection.init();

		// create connection instance, which represents connection to a database
		try {
			connection = dbConnection.getConnection(getId(), OperationType.WRITE);
		} catch (JetelException e1) {
			throw new ComponentNotReadyException(e1);
		}
		
        //prepare inRecord, rejectedRecord and keysRecord
        inPort = getInputPort(READ_FROM_PORT);
		inRecord = new DataRecord(inPort.getMetadata());
		inRecord.init();
		rejectedPort=getOutputPort(WRITE_REJECTED_TO_PORT);
		rejectedRecord = rejectedPort != null ? new DataRecord(rejectedPort.getMetadata()) : null;
		if (rejectedRecord != null) {
			rejectedRecord.init();
			errorCodeFieldNum = rejectedRecord.getMetadata().findAutoFilledField(MultiFileReader.ERROR_CODE);
			errMessFieldNum = rejectedRecord.getMetadata().findAutoFilledField(MultiFileReader.ERROR_MESSAGE);
			if (errMessFieldNum == -1){
				DataRecordMetadata rejectedMetadata = rejectedPort.getMetadata();
				if (inPort.getMetadata().getNumFields() == rejectedMetadata.getNumFields() - 1
						&& rejectedMetadata.getField(rejectedMetadata.getNumFields() -1).getType() == DataFieldMetadata.STRING_FIELD){
					errMessFieldNum = rejectedMetadata.getNumFields() - 1;
				}
			}
		}		
		
		//create insert query from db table name
		if (sqlQuery == null) {
			sqlQuery = new String[1];
			if (dbFields != null) {
				sqlQuery[0] = SQLUtil.assembleInsertSQLStatement(dbTableName, dbFields);
			}else{
				sqlQuery[0] = SQLUtil.assembleInsertSQLStatement(inPort.getMetadata(), dbTableName);
			}
		}
		
		keysPort = getOutputPort(WRITE_AUTO_KEY_TO_PORT);
		returnResult = new boolean[sqlQuery.length];
		Arrays.fill(returnResult, false);
		keysRecord = keysPort != null ? new DataRecord(keysPort.getMetadata()) : null;
		if (keysRecord != null) {
			keysRecord.init();
			keysRecord.reset();
		}
		
		boolean supportsConnectionKeyGenaration = false;
		try {
			supportsConnectionKeyGenaration = connection.getSqlConnection().getMetaData().supportsGetGeneratedKeys();
		} catch (SQLException e1) {
			// TODO Auto-generated catch block
		}
		//prepare set of statements
		statement = new SQLCloverStatement[sqlQuery.length];
		if (statement.length > 1 && autoGeneratedColumns != null) {
			logger.warn("Found more then one sql query and " + XML_AUTOGENERATEDCOLUMNS_ATTRIBUTE +
			" parameter. The last one will be ignored");
			autoGeneratedColumns = null;
		}
		int end, start = 0;
		String[] tmpCloverFields = null;
		for (int i = 0; i < statement.length; i++) {
			if (cloverFields != null) {
				end = StringUtils.count(sqlQuery[i], '?');
				tmpCloverFields = new String[end - start];
				for (int j = 0; j < tmpCloverFields.length; j++) {
					if (start + j >= cloverFields.length) {
						throw new ComponentNotReadyException(this,	XML_CLOVERFIELDS_ATTRIBUTE,
								"Missing parameter value for query " + StringUtils.quote(sqlQuery[i]
								+ " , parameter number: " + (start + j + 1)));
					}
					tmpCloverFields[j] = cloverFields[start + j];
				}
				start = end;
			}
			statement[i] = new SQLCloverStatement(connection, sqlQuery[i], inRecord, tmpCloverFields, autoGeneratedColumns);
			if (statement[i].getQueryType() == QueryType.INSERT && statement[i].returnResult()) {
				if (useBatch) {
					logger.warn("Getting generated keys in batch mode is not supported -> switching it off !");
					sqlQuery[i] = sqlQuery[i].substring(0, sqlQuery[i].toLowerCase().indexOf(SQLCloverStatement.RETURNING_KEY_WORD));
					statement[i] = new SQLCloverStatement(connection, sqlQuery[i], inRecord, cloverFields);
				}else if (!supportsConnectionKeyGenaration) {
					logger.warn("DB indicates no support for getting generated keys -> switching it off !");
					sqlQuery[i] = sqlQuery[i].substring(0, sqlQuery[i].toLowerCase().indexOf(SQLCloverStatement.RETURNING_KEY_WORD));
					statement[i] = new SQLCloverStatement(connection, sqlQuery[i], inRecord, cloverFields);
				}
			}
		}
		
		//check that what we require is supported
		try {
			if (useBatch && !connection.getSqlConnection().getMetaData().supportsBatchUpdates()){
				logger.warn("DB indicates no support for batch updates -> switching it off !");
				useBatch=false;
			}
		} catch (SQLException e) {
		}
		
		if (keysRecord != null) {
			for (int i = 0; i < returnResult.length; i++) {
				returnResult[i] = statement[i].returnResult();
			}
		}
		
		//when no one of queries returns something switch off key port
		if (keysRecord != null) {
			int i;
			for (i = 0; i < returnResult.length; i++) {
				if (returnResult[i]) break;
			}
			if (i == returnResult.length) {
				keysRecord = null;
			}
		}
		
		if (useBatch && batchSize > MAX_BATCH_SIZE){
			logger.warn("Batch size greater then MAX_BATCH_SIZE -> " + XML_BATCHSIZE_ATTRIBUTE + " set to " + MAX_BATCH_SIZE);
			batchSize = MAX_BATCH_SIZE;
		}

		// it is probably wise to have COMMIT size multiplication of BATCH size
		// except situation when commit size is MAX_INTEGER -> we never commit in this situation;
		if (useBatch && recordsInCommit!=Integer.MAX_VALUE && (recordsInCommit % batchSize != 0)){
			int multiply= recordsInCommit/batchSize;
			recordsInCommit=(multiply+1) * batchSize;
		}
		
		//init statements
		SQLCloverStatement eachStatement;
		for (int i = 0; i < statement.length; i++) {
			eachStatement = statement[i];
			eachStatement.setLogger(logger);
			try {
				eachStatement.init();
			} catch (Exception e) {
				throw new ComponentNotReadyException(this, e.getMessage());
			} 
		}
	
	}

	@Override
	public synchronized void reset() throws ComponentNotReadyException {
		super.reset();
		inRecord = new DataRecord(inPort.getMetadata());
		inRecord.init();
		if (rejectedRecord != null) {
			rejectedRecord.reset();
		}		
		if (keysRecord != null) {
			keysRecord.reset();
		}
		for (SQLCloverStatement eachStatement : statement) {
			try {
				eachStatement.setInRecord(inRecord);
				eachStatement.reset();
			} catch (Exception e) {
				throw new ComponentNotReadyException(this, e.getMessage());
			} 
		}
		recCount = 0;
		countError = 0;
	}
	
	/**
	 * @param dbTableName The dbTableName to set.
	 */
	public void setDBTableName(String dbTableName) {
		this.dbTableName = dbTableName;
	}
	
	/**
	 *  Sets the recordsInCommit attribute of the DBOutputTable object
	 *
	 * @param  nRecs  The new recordsInCommit value
	 */
	public void setRecordsInCommit(int nRecs) {
		if (nRecs > 0) {
			recordsInCommit = nRecs;
		}
	}

	@Override
	public Result execute() throws Exception {
		/*
		 * Run main processing loop
		 */
		try{
			if (useBatch){
				runInBatchMode();
			}else{
				runInNormalMode();
			}
		}catch (InterruptedException e) {
			if (errorAction == ConnectionAction.ROLLBACK) {
				errorAction.perform(connection.getSqlConnection());
				if (errorAction == ConnectionAction.ROLLBACK) {
					logger.info("Rollback performed.");
					logger.info("Number of commited records: " + (recCount / recordsInCommit)*recordsInCommit);
				}else{
					logger.info("Number of commited records: " + recCount);
				}
				logger.info("Rollback performed.");
				logger.info("Number of commited records: " + (recCount / recordsInCommit)*recordsInCommit);
			}else if (recordsInCommit!=Integer.MAX_VALUE){
				errorAction.perform(connection.getSqlConnection());
				logger.info("Number of commited records: " + recCount);
			}
		} finally {
			broadcastEOF();
			for (SQLCloverStatement eachStatement : statement) {
				eachStatement.close();
			}
		}
        return runIt ? Result.FINISHED_OK : Result.ABORTED;
	}
	
	@Override
	public synchronized void free() {
		super.free();
//		if (dbConnection != null) {
//			dbConnection.free();
//		}
	}

	private void runInNormalMode() throws SQLException,InterruptedException,IOException, JetelException{
		String errmes = "";
		SQLException exception = null;
		while ((inRecord = inPort.readRecord(inRecord)) != null && runIt) {
			if (keysRecord != null){
				keysRecord.reset();
			}
			//execute all statements
			for (int i=0; i<statement.length; i++) {
				try{
					statement[i].executeUpdate(returnResult[i] ? keysRecord : null);
				}catch(SQLException ex) {
					countError++;
					exception = ex;
					errmes = "Exeption thrown by: " + statement[i].getQuery() + ". Message: " + ex.getMessage();
					if (rejectedPort != null) {
						rejectedRecord.copyFieldsByName(inRecord);
						if (errMessFieldNum != -1) {
							rejectedRecord.getField(errMessFieldNum).setValue(errmes);
						}
						if (errorCodeFieldNum != -1){
							rejectedRecord.getField(errorCodeFieldNum).setValue(ex.getErrorCode());
						}
						rejectedPort.writeRecord(rejectedRecord);
					}
					if (countError <= MAX_WARNINGS) {
						logger.warn(errmes);
					}else if (countError == MAX_WARNINGS + 1){
						logger.warn("more errors...");
					}
				}
			}
			//send filled key record to output
			if (keysRecord != null) {
				keysPort.writeRecord(keysRecord);
			}
			//if number of errors is greater then allowed throw exception
			if (countError>maxErrors && maxErrors!=-1){
				//Perform commit or rollback
				errorAction.perform(connection.getSqlConnection());
				if (errorAction == ConnectionAction.ROLLBACK) {
					logger.info("Rollback performed.");
					logger.info("Number of commited records: " + (recCount / recordsInCommit)*recordsInCommit);
//					logger.info("Last " + recCount % recordsInCommit  + " records not commited");
				}else if (errorAction == ConnectionAction.COMMIT){
					logger.info("Number of commited records: " + ++recCount);
				}
				throw new JetelException("Maximum # of errors exceeded when inserting record. "+ errmes, exception);
			}
			//if needed, commit
			if (recordsInCommit!=Integer.MAX_VALUE && ++recCount % recordsInCommit == 0) {
				connection.getSqlConnection().commit();
			}
			SynchronizeUtils.cloverYield();
		}
 		// end of records stream - final commits;
		 // unless we have option never to commit, commit at the end of processing
	    if (runIt && recordsInCommit!=Integer.MAX_VALUE){
	    	connection.getSqlConnection().commit();	
	    }else if (!runIt) {//component execution aborted
			errorAction.perform(connection.getSqlConnection());
			if (errorAction == ConnectionAction.ROLLBACK) {
				logger.info("Rollback performed.");
				logger.info("Number of commited records: " + (recCount / recordsInCommit)*recordsInCommit);
//				logger.info("Last " + recCount % recordsInCommit + " records not commited");
			}else if (errorAction == ConnectionAction.COMMIT){
				logger.info("Number of commited records: " + ++recCount);
			}
	    }
	    
	}


	private void runInBatchMode() throws SQLException,InterruptedException,IOException, JetelException{
	    int batchCount=0;
    	int statementCount=0;
    	String errmes = "";
    	SQLException exception = null;
	    DataRecordMetadata rejectedMetadata = null;
	    if (rejectedPort != null) {
	    	rejectedMetadata = rejectedPort.getMetadata();
	    }
	    DataRecord[][] dataRecordHolder;
	    DataRecord[] updatedRecord = null;
	    int holderCount= -1;
		BatchUpdateException[] exceptions = new BatchUpdateException[statement.length];
		boolean exThrown;
	    
        // first, we set transMap to batchUpdateMode
		for (SQLCloverStatement eachStatement : statement) {
			eachStatement.setBatchUpdate(true);
		}
		
	    // if we have rejected records port connected, we will
	    // store and report error records in batch
	    if (rejectedPort!=null){
	        dataRecordHolder=new DataRecord[statement.length][batchSize];
	        for (int i = 0; i < statement.length; i++) {
				for (int j = 0; j < batchSize; j++) {
					dataRecordHolder[i][j] = new DataRecord(rejectedMetadata);
					dataRecordHolder[i][j].init();
				}
			}
	    }else{
	        dataRecordHolder=null;
	    }
	    
	    while ((inRecord = inPort.readRecord(inRecord)) != null && runIt) {
			if (keysRecord != null){
				keysRecord.reset();
			}
			holderCount++;
			for (statementCount = 0; statementCount < statement.length; statementCount++) {
				try{
					statement[statementCount].addBatch(returnResult[statementCount] ? keysRecord : null);
					//prepare prospective rejected record
	                if (dataRecordHolder!=null) {
	                	dataRecordHolder[statementCount][holderCount].copyFieldsByName(inRecord);
						if (errMessFieldNum != -1) {
							dataRecordHolder[statementCount][holderCount].getField(errMessFieldNum).reset();
						}
						if (errorCodeFieldNum != -1){
							dataRecordHolder[statementCount][holderCount].getField(errorCodeFieldNum).reset();
						}
	                }
				}catch(SQLException ex){
	               countError++;
	               exception = ex;
	               errmes = "Exeption thrown by: " + statement[statementCount].getQuery() + ". Message: " + ex.getMessage();
	               //for this record statement won't be executed 
					if (rejectedPort != null) {
		               dataRecordHolder[statementCount][holderCount] = null;
						rejectedRecord.copyFieldsByName(inRecord);
						if (errMessFieldNum != -1) {
							rejectedRecord.getField(errMessFieldNum).setValue(errmes);
						}
						if (errorCodeFieldNum != -1){
							rejectedRecord.getField(errorCodeFieldNum).setValue(ex.getErrorCode());
						}
						rejectedPort.writeRecord(rejectedRecord);
					}
					if (countError <= MAX_WARNINGS) {
						logger.warn(errmes);
					}else if (countError == MAX_WARNINGS + 1){
						logger.warn("more errors...");
					}
				}
			}
			if (countError>maxErrors && maxErrors!=-1){
				logger.info("Number of commited records: " + recCount);
                throw new JetelException("Maximum # of errors exceeded when inserting record. "+ errmes, exception);
            }
			
            // shall we commit ?
	        if (++batchCount % batchSize == 0) {
	        	exThrown = false;
				for (statementCount = 0; statementCount < statement.length; statementCount++) {
		            try {
						statement[statementCount].executeBatch();
						updatedRecord = statement[statementCount].getBatchResult();
						statement[statementCount].clearBatch();
		            } catch (BatchUpdateException ex) {
						updatedRecord = statement[statementCount].getBatchResult();
		                statement[statementCount].clearBatch();
		                exceptions[statementCount] = ex;
		                exception = ex;
		                errmes = "Exeption thrown by: " + statement[statementCount].getQuery() + ". Message: " + ex.getMessage();
		                exThrown = true;
		            }
		            for (int i = 0 ; i < updatedRecord.length; i++) {
		            	keysPort.writeRecord(updatedRecord[i]);
		            }
		        }
				//all statements executed, some of them could fail
				if (exThrown) {
					flushErrorRecords(dataRecordHolder, holderCount, exceptions, rejectedPort);
					if (countError>maxErrors && maxErrors!=-1){
						errorAction.perform(connection.getSqlConnection());
						if (errorAction == ConnectionAction.ROLLBACK) {
							logger.info("Rollback performed.");
							logger.info("Number of commited records: " + (recCount / recordsInCommit)*recordsInCommit);
//							logger.info("Last " + batchCount + " records not commited");
						}else if (errorAction == ConnectionAction.COMMIT){
							logger.info("Number of commited records: " + ++recCount);
						}
	                    throw new JetelException("Maximum # of errors exceeded when executing batch. " + errmes, exception);
	                }
				}
	            batchCount = 0;
	            holderCount=-1;
			}
	        if (++recCount % recordsInCommit == 0) {
	            if (batchCount!=0){
	            	exThrown = false;
					for (statementCount = 0; statementCount < statement.length; statementCount++) {
			            try {
			            	statement[statementCount].executeBatch();
							updatedRecord = statement[statementCount].getBatchResult();
							statement[statementCount].clearBatch();
			            } catch (BatchUpdateException ex) {
							updatedRecord = statement[statementCount].getBatchResult();
			                statement[statementCount].clearBatch();
			                exceptions[statementCount] = ex;
			                exception = ex;
			                errmes = "Exeption thrown by: " + statement[statementCount].getQuery() + ". Message: " + ex.getMessage();
			                exThrown = true;
			            }
			            for (int i = 0 ; i < updatedRecord.length; i++) {
			            	keysPort.writeRecord(updatedRecord[i]);
			            }
			        }
					//all statements executed, some of them could fail
					if (exThrown){
						flushErrorRecords(dataRecordHolder, holderCount, exceptions, rejectedPort);
						if (countError>maxErrors && maxErrors!=-1){
							errorAction.perform(connection.getSqlConnection());
							if (errorAction == ConnectionAction.ROLLBACK) {
								logger.info("Rollback performed.");
								logger.info("Number of commited records: " + (recCount / recordsInCommit)*recordsInCommit);
//								logger.info("Last " + recCount % recordsInCommit + " records not commited");
							}else if (errorAction == ConnectionAction.COMMIT){
								logger.info("Number of commited records: " + recCount);
							}
		                    throw new JetelException("Maximum # of errors exceeded when executing batch. " + errmes, 
		                    		exception);
		                }
					}
		            batchCount = 0;
		            holderCount=-1;
	            }
	            connection.getSqlConnection().commit();
		    }
            SynchronizeUtils.cloverYield();
	    }
	    
		// final commit (if anything is left in batch)
	    exThrown = false;
	    for (statementCount = 0; statementCount < statement.length; statementCount++) {
			try {
				statement[statementCount].executeBatch();
			} catch (BatchUpdateException ex) {
                exceptions[statementCount] = ex;
                exception = ex;
                errmes = "Exeption thrown by: " + statement[statementCount].getQuery() + ". Message: " + ex.getMessage();
                exThrown = true;
			}finally{
				updatedRecord = statement[statementCount].getBatchResult();
			}
            for (int i = 0 ; i < updatedRecord.length; i++) {
            	keysPort.writeRecord(updatedRecord[i]);
            }
		}
		//all statements executed, some of them could fail
		if (exThrown) {
			flushErrorRecords(dataRecordHolder, holderCount, exceptions, rejectedPort);
			if (countError > maxErrors && maxErrors != -1) {
//			    if (dataRecordHolder!=null) {
//			        Arrays.fill(dataRecordHolder,null);
//		        	Arrays.fill(exeptions, null);
//			    }
				errorAction.perform(connection.getSqlConnection());
				if (errorAction == ConnectionAction.ROLLBACK) {
					logger.info("Rollback performed.");
					logger.info("Number of commited records: " + (recCount / recordsInCommit)*recordsInCommit);
//					logger.info("Last " + recCount % recordsInCommit + " records not commited");
				}else if (errorAction == ConnectionAction.COMMIT){
					logger.info("Number of commited records: " + recCount);
				}
				throw new JetelException("Maximum # of errors exceeded when executing batch. " + errmes, exception);
			}
		}
		// unless we have option never to commit, commit at the end of processing
	    if (runIt && recordsInCommit!=Integer.MAX_VALUE){
	    	connection.getSqlConnection().commit();
	    }else if (!runIt) {
			errorAction.perform(connection.getSqlConnection());
			if (errorAction == ConnectionAction.ROLLBACK) {
				logger.info("Rollback performed.");
				logger.info("Number of commited records: " + (recCount / recordsInCommit)*recordsInCommit);
//				logger.info("Last " + recCount % recordsInCommit + " records not commited");
			}else if (errorAction == ConnectionAction.COMMIT){
				logger.info("Number of commited records: " + recCount);
			}
	    }
//	    if (dataRecordHolder!=null) {
//	        Arrays.fill(dataRecordHolder,null);
//        	Arrays.fill(exeptions, null);
//	    }
	}
	
    
    /**
     * This method sends error records to output and counts errors. If array <i>records</i> is null, only counting of errors is performed  
     * 
     * @param records potential rejected records
     * @param recCount number of records in batch
     * @param ex thrown exception
     * @param rejectedPort rejected Port
     * @throws IOException
     * @throws InterruptedException
     */
    private void flushErrorRecords(DataRecord[][] records,int recCount, BatchUpdateException[] ex, OutputPort rejectedPort) 
    throws IOException,InterruptedException {

//        if (records==null) return;
        
        int[] updateCounts;
        int count;
        SQLException exception;
        StringBuilder message = new StringBuilder();

        //for each statement exception has occurred
        for (int i=0; i < ex.length; i++) {
			if (ex[i] != null) {
				exception = ex[i];
				updateCounts = ex[i].getUpdateCounts();
				count = 0;
		        while(count<updateCounts.length){
					if (updateCounts[count] == Statement.EXECUTE_FAILED) {
						//increase error counter, fill rejected record and log error message
						countError++;
						if (records != null && records[i][count] != null) {
							if (exception != null) {
								if (errMessFieldNum != -1) {
									records[i][count].getField(errMessFieldNum).setValue("Exeption thrown by: " + 
											statement[i].getQuery() + ". Message: " + exception.getMessage());
								}
								if (errorCodeFieldNum != -1){
									records[i][count].getField(errorCodeFieldNum).setValue(exception.getErrorCode());
								}
							}
							if (exception != null && countError <= MAX_WARNINGS) {
								logger.warn("Exeption thrown by: " + statement[i].getQuery() + 
										". Message: " + exception.getMessage());
							} else if (exception == null && countError <= MAX_WARNINGS) {
								logger.warn("Record not inserted to database");
							} else if (countError == MAX_WARNINGS + 1) {
								logger.warn("more errors...");
							}
							rejectedPort.writeRecord(records[i][count]);
							if (exception != null) {
								exception = exception.getNextException();
							}
						}else if (records != null){//records[i][count] == null - it wasn't added to batch, prepare for next batch
							records[i][count] = new DataRecord(rejectedPort.getMetadata());
							records[i][count].init();
						}
					}
					count++;
		        }
		        // flush rest of the records for which we don't have update counts
		        message.setLength(0);
		        Integer errCode = exception != null ? exception.getErrorCode() : null;
		    	while (exception != null) {
		    		message.append(exception.getMessage());
		    		exception = exception.getNextException();
		    	}
		        while(count<recCount){
		    		if (records != null && records[i][count] != null) {
						if (message.length() > 0 && countError <= MAX_WARNINGS) {
							logger.warn(message);
						} else if (message.length() > 0
								&& countError == MAX_WARNINGS + 1) {
							logger.warn("more errors...");
						}
						if (message.length() > 0 && i < recCount) {
							if (errMessFieldNum != -1) {
								records[i][count].getField(errMessFieldNum).setValue(message);
							}
							if (errorCodeFieldNum != -1){
								records[i][count].getField(errorCodeFieldNum).setValue(errCode);
							}
						}
						message = new StringBuilder("Record not inserted to database");
						countError++;
						rejectedPort.writeRecord(records[i][count]);
					}else if (records != null){
						records[i][count] = new DataRecord(rejectedPort.getMetadata());
						records[i][count].init();
					}
					count++;
		        }
			}
		}

        //clear errors
        Arrays.fill(ex, null);
    }
	
	/**
	 *  Description of the Method
	 *
	 * @return    Description of the Returned Value
	 * @since     September 27, 2002
	 */
	@Override public void toXML(Element xmlElement) {
		super.toXML(xmlElement);
		if (dbConnectionName != null) {
			xmlElement.setAttribute(XML_DBCONNECTION_ATTRIBUTE, dbConnectionName);
		}
		if (sqlQuery != null) {
			xmlElement.setAttribute(XML_SQLQUERY_ATRIBUTE, StringUtils.stringArraytoString(sqlQuery, Defaults.Component.KEY_FIELDS_DELIMITER.charAt(0)));
		}
		if (dbTableName != null) {
			xmlElement.setAttribute(XML_DBTABLE_ATTRIBUTE, dbTableName);
		}
		
		if (dbFields != null) {
			StringBuffer buf = new StringBuffer(dbFields[0]);
			for (int i=1; i< dbFields.length; i++ ) {
				buf.append(Defaults.Component.KEY_FIELDS_DELIMITER + dbFields[i]);
			}
			xmlElement.setAttribute(XML_DBFIELDS_ATTRIBUTE, buf.toString());
		}
		
		if (cloverFields != null) {
			StringBuffer buf = new StringBuffer(cloverFields[0]);
			for (int i=1; i< cloverFields.length; i++ ) {
				buf.append(Defaults.Component.KEY_FIELDS_DELIMITER + cloverFields[i]);
			}
			xmlElement.setAttribute(XML_DBFIELDS_ATTRIBUTE, buf.toString());
		}
		if (recordsInCommit > 0) {
			xmlElement.setAttribute(XML_COMMIT_ATTRIBUTE,String.valueOf(recordsInCommit));
		}
		
		xmlElement.setAttribute(XML_BATCHMODE_ATTRIBUTE, String.valueOf(useBatch));
		
		xmlElement.setAttribute(XML_BATCHSIZE_ATTRIBUTE, String.valueOf(batchSize));
		
		xmlElement.setAttribute(XML_MAXERRORS_ATRIBUTE, String.valueOf(maxErrors));
		
		if (autoGeneratedColumns != null) {
			StringBuilder tmp = new StringBuilder(autoGeneratedColumns[0]);
			for (int i = 1; i < autoGeneratedColumns.length; i++) {
				tmp.append(Defaults.Component.KEY_FIELDS_DELIMITER + autoGeneratedColumns[i]);
			}
			xmlElement.setAttribute(XML_AUTOGENERATEDCOLUMNS_ATTRIBUTE, tmp.toString());
		}
		
		xmlElement.setAttribute(XML_ACTION_ON_ERROR, errorAction.toString());
	}
	
	/**
	 *  Description of the Method
	 *
	 * @param  nodeXML  Description of Parameter
	 * @return          Description of the Returned Value
	 * @since           September 27, 2002
	 */
     public static Node fromXML(TransformationGraph graph, Element xmlElement) throws XMLConfigurationException {
		ComponentXMLAttributes xattribs = new ComponentXMLAttributes(xmlElement, graph);
		ComponentXMLAttributes xattribsChild;
		org.w3c.dom.Node childNode;
		DBOutputTable outputTable;

		try {
			// allows specifying parameterized SQL (with ? - question marks)
			if (xattribs.exists(XML_SQLQUERY_ATRIBUTE)) {
					outputTable = new DBOutputTable(xattribs.getString(XML_ID_ATTRIBUTE),
					xattribs.getString(XML_DBCONNECTION_ATTRIBUTE),
					xattribs.getString(XML_SQLQUERY_ATRIBUTE).split(STATEMENT_SEPARATOR));
			}else if(xattribs.exists(XML_URL_ATTRIBUTE)){
				outputTable = new DBOutputTable(xattribs.getString(XML_ID_ATTRIBUTE),
						xattribs.getString(XML_DBCONNECTION_ATTRIBUTE),
						xattribs.resolveReferences(FileUtils.getStringFromURL(graph.getProjectURL(), 
								xattribs.getString(XML_URL_ATTRIBUTE), xattribs.getString(XML_CHARSET_ATTRIBUTE, null))).split(STATEMENT_SEPARATOR));
			}else if(xattribs.exists(XML_DBTABLE_ATTRIBUTE)){
				outputTable = new DBOutputTable(xattribs.getString(XML_ID_ATTRIBUTE),
						xattribs.getString(XML_DBCONNECTION_ATTRIBUTE),
						xattribs.getString(XML_DBTABLE_ATTRIBUTE));
			}else{
			    childNode = xattribs.getChildNode(xmlElement, XML_SQLCODE_ELEMENT);
                if (childNode == null) {
                    throw new XMLConfigurationException(COMPONENT_TYPE + ":" + xattribs.getString(XML_ID_ATTRIBUTE," unknown ID ") + ": Can't find <SQLCode> node !");
                }
                xattribsChild = new ComponentXMLAttributes((Element)childNode, graph);
                outputTable = new DBOutputTable(xattribs.getString(XML_ID_ATTRIBUTE),
    					xattribs.getString(XML_DBCONNECTION_ATTRIBUTE),
    					xattribsChild.getText(childNode).split(STATEMENT_SEPARATOR));
			}
			
			
			if (xattribs.exists(XML_DBTABLE_ATTRIBUTE)) {
				outputTable.setDBTableName(xattribs.getString(XML_DBTABLE_ATTRIBUTE));
			}
			if (xattribs.exists(XML_FIELDMAP_ATTRIBUTE)){
				String[] pairs = StringUtils.split(xattribs.getString(XML_FIELDMAP_ATTRIBUTE));
				String[] cloverFields = new String[pairs.length];
				String[] dbFields = new String[pairs.length];
				String[] mapping;
				for (int i=0;i<pairs.length;i++){
					mapping = JoinKeyUtils.getMappingItemsFromMappingString(pairs[i]);//:= or =
					cloverFields[i] = mapping[0];
					dbFields[i] = mapping[1];
				}
				outputTable.setCloverFields(cloverFields);
				outputTable.setDBFields(dbFields);
			}else {
				if (xattribs.exists(XML_DBFIELDS_ATTRIBUTE)) {
					outputTable.setDBFields(xattribs.getString(XML_DBFIELDS_ATTRIBUTE).split(Defaults.Component.KEY_FIELDS_DELIMITER_REGEX));
				}
	
				if (xattribs.exists(XML_CLOVERFIELDS_ATTRIBUTE)) {
					outputTable.setCloverFields(xattribs.getString(XML_CLOVERFIELDS_ATTRIBUTE).split(Defaults.Component.KEY_FIELDS_DELIMITER_REGEX));
				}
			}
			if (xattribs.exists(XML_COMMIT_ATTRIBUTE)) {
				outputTable.setRecordsInCommit(xattribs.getInteger(XML_COMMIT_ATTRIBUTE));
			}
			
			if (xattribs.exists(XML_BATCHMODE_ATTRIBUTE)) {
				outputTable.setUseBatch(xattribs.getBoolean(XML_BATCHMODE_ATTRIBUTE));
			}
			if (xattribs.exists(XML_BATCHSIZE_ATTRIBUTE)) {
				outputTable.setBatchSize(xattribs.getInteger(XML_BATCHSIZE_ATTRIBUTE));
			}
			if (xattribs.exists(XML_MAXERRORS_ATRIBUTE)){
				outputTable.setMaxErrors(xattribs.getInteger(XML_MAXERRORS_ATRIBUTE));
			}
			if (xattribs.exists(XML_AUTOGENERATEDCOLUMNS_ATTRIBUTE)){
				outputTable.setAutoGeneratedColumns(xattribs.getString(XML_AUTOGENERATEDCOLUMNS_ATTRIBUTE).split(Defaults.Component.KEY_FIELDS_DELIMITER_REGEX));
			}
			if (xattribs.exists(XML_ACTION_ON_ERROR)){
				outputTable.setErrorAction(xattribs.getString(XML_ACTION_ON_ERROR));
			}
			
			return outputTable;
			
		} catch (Exception ex) {
            throw new XMLConfigurationException(COMPONENT_TYPE + ":" + xattribs.getString(XML_ID_ATTRIBUTE," unknown ID ") + ":" + ex.getMessage(),ex);
        }
	}


	/**
	 *  Description of the Method
	 *
	 * @return    Description of the Return Value
	 */
     @Override
     public ConfigurationStatus checkConfig(ConfigurationStatus status) {
         super.checkConfig(status);
         
         if(!checkInputPorts(status, 1, 1)
        		 || !checkOutputPorts(status, 0, 2)) {
        	 return status;
         }

         try {
//             init();
        	 
             IConnection conn = getGraph().getConnection(dbConnectionName);
             if(conn == null) {
                 throw new ComponentNotReadyException("Can't find DBConnection ID: " + dbConnectionName);
             }
             if(!(conn instanceof DBConnection)) {
                 throw new ComponentNotReadyException("Connection with ID: " + dbConnectionName + " isn't instance of the DBConnection class.");
             }
             dbConnection = (DBConnection) conn;
       		 dbConnection.init();
     		// create connection instance, which represents connection to a database
     		try {
     			connection = dbConnection.getConnection(getId(), OperationType.WRITE);
     		} catch (JetelException e1) {
     			throw new ComponentNotReadyException(e1);
     		}
             
             inPort = getInputPort(READ_FROM_PORT);
     		if (sqlQuery == null) {
    			sqlQuery = new String[1];
    			if (dbFields != null) {
    				sqlQuery[0] = SQLUtil.assembleInsertSQLStatement(dbTableName, dbFields);
    			}else{
    				sqlQuery[0] = SQLUtil.assembleInsertSQLStatement(inPort.getMetadata(), dbTableName);
    			}
    		}
             if (inPort.getMetadata() != null) {
				inRecord = new DataRecord(inPort.getMetadata());
				inRecord.init();
				int start = 0, end;
				for (int i = 0; i < sqlQuery.length; i++) {
					String[] tmpCloverFields = null;
					if (cloverFields != null) {
						end = StringUtils.count(sqlQuery[i], '?');
						tmpCloverFields = new String[end - start];
						for (int j = 0; j < tmpCloverFields.length; j++) {
							if (start + j >= cloverFields.length) {
								throw new ComponentNotReadyException(
										this,
										XML_CLOVERFIELDS_ATTRIBUTE,
										"Missing parameter value for query "
												+ StringUtils
														.quote(sqlQuery[i]
																+ " , parameter number: "
																+ (start + j + 1)));
							}
							tmpCloverFields[j] = cloverFields[start + j];
						}
						start = end;
					}
					SQLCloverStatement statement = new SQLCloverStatement(
							connection, sqlQuery[i], inRecord, tmpCloverFields,
							autoGeneratedColumns);
					try {
						statement.init();
					} catch (SQLException e) {
						throw new ComponentNotReadyException(this, e);
					}
				}
			}
             
        } catch (ComponentNotReadyException e) {
             ConfigurationProblem problem = new ConfigurationProblem(e.getMessage(), ConfigurationStatus.Severity.ERROR, this, ConfigurationStatus.Priority.NORMAL);
             if(!StringUtils.isEmpty(e.getAttributeName())) {
                 problem.setAttributeName(e.getAttributeName());
             }
             status.add(problem);
         } finally {
             free();
         }
         
         return status;
    }

	public String getType(){
		return COMPONENT_TYPE;
	}
	
	/**
	 * @param maxErrors Maximum number of tolerated SQL errors during component run. Default: 0 (zero)
	 */
	public void setMaxErrors(int maxErrors) {
		this.maxErrors = maxErrors;
	}

	/**
	 * @param autoGeneratedColumns names of db columns to get back from database
	 */
	public void setAutoGeneratedColumns(String[] autoGeneratedColumns) {
		this.autoGeneratedColumns = autoGeneratedColumns;
	}
	
	public String[] getAutoGeneratedColumns() {
		return autoGeneratedColumns;
	}

	public void setErrorAction(ConnectionAction errorAction) {
		this.errorAction = errorAction;
	}
	
	public void setErrorAction(String errorAction) {
		this.errorAction = ConnectionAction.valueOf(errorAction);
	}

}
	
