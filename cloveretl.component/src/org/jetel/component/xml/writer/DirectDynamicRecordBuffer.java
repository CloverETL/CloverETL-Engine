/*
 * jETeL/CloverETL - Java based ETL application framework.
 * Copyright (c) Javlin, a.s. (info@cloveretl.com)
 *  
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
package org.jetel.component.xml.writer;

import static org.jetel.util.bytes.ByteBufferUtils.encodeLength;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.BufferOverflowException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.List;

import org.jetel.data.DataRecord;
import org.jetel.data.Defaults;
import org.jetel.util.bytes.ByteBufferUtils;

/**
 * Class implementing DynamicRecordBuffer backed by temporary file - i.e. unlimited size<br>
 * 
 * @author lkrejci (info@cloveretl.com) (c) Javlin, a.s. (www.cloveretl.com)
 * 
 * @created 5 Jan 2011
 */
public class DirectDynamicRecordBuffer {
	
	private FileChannel tmpFileChannel;
	private File tmpFile;
	private String tempDirectory;
	
	private List<DiskSlot> fileBuffers = new ArrayList<DiskSlot>();
	
	private ByteBuffer recordBuffer;
	private ByteBuffer dataBuffer;
	
	private int currentWritePosition;
	private int writeRecordCount = 0;
	private int readRecordCount = 0;
	private int nextSlot = 0;
	
	private int dataBufferSize = Defaults.Record.MAX_RECORD_SIZE + ByteBufferUtils.SIZEOF_INT;
	
	private final static String TMP_FILE_PREFIX = ".fbuf";
	// prefix of temporary file generated by system
	private final static String TMP_FILE_SUFFIX = ".tmp";
	// suffix of temporary file generated by system
	private final static String TMP_FILE_MODE = "rw";
	
	public DirectDynamicRecordBuffer(String tempDirectory) {
		this.tempDirectory = tempDirectory;
	}
	
	public void init() throws IOException {
		tmpFile = File.createTempFile(TMP_FILE_PREFIX, TMP_FILE_SUFFIX, tempDirectory != null ? new File(tempDirectory) : null);
		tmpFile.deleteOnExit();
		tmpFileChannel = new RandomAccessFile(tmpFile, TMP_FILE_MODE).getChannel();
		dataBuffer = ByteBuffer.allocateDirect(Defaults.Record.MAX_RECORD_SIZE + ByteBufferUtils.SIZEOF_INT);
		recordBuffer = ByteBuffer.allocateDirect(Defaults.Record.MAX_RECORD_SIZE);
	}
	
	public IndexKey writeRaw(DataRecord record) throws IOException {
        try {
            record.serialize(recordBuffer);
        } catch (BufferOverflowException ex) {
            throw new IOException("Internal buffer is not big enough to accomodate data record ! (See MAX_RECORD_SIZE parameter)");
        }
        recordBuffer.flip();
		
		int recordSize = recordBuffer.remaining();
		
		tmpFileChannel.write(recordBuffer);
		recordBuffer.clear();
        currentWritePosition += recordSize; 
		
		return new IndexKey(currentWritePosition - recordSize, recordSize);
	}
	
	public void write(DataRecord record) throws IOException {
		try {
            record.serialize(recordBuffer);
        } catch (BufferOverflowException ex) {
            throw new IOException("Internal buffer is not big enough to accomodate data record ! (See MAX_RECORD_SIZE parameter)");
        }
        recordBuffer.flip();
        
        int recordSize = recordBuffer.remaining();
        
        if (dataBuffer.remaining() < recordSize + ByteBufferUtils.SIZEOF_INT) {
        	flushBuffer();
        }
        encodeLength(dataBuffer, recordSize);
        dataBuffer.put(recordBuffer);
        recordBuffer.clear();
        writeRecordCount++;
	}
	
	public void flushBuffer() throws IOException {
		DiskSlot diskSlot = new DiskSlot(fileBuffers.size() + 1);

		dataBuffer.flip();
		diskSlot.setUsedBytes(dataBuffer.limit());
		dataBuffer.limit(dataBufferSize);
		tmpFileChannel.write(dataBuffer, diskSlot.getPosition(dataBufferSize));

		dataBuffer.clear();
		fileBuffers.add(diskSlot);
	}

	public void read(ByteBuffer record, int position) throws IOException {
		tmpFileChannel.read(record, position);
		record.flip();
	}
	
	public boolean next(DataRecord record) throws IOException {
		if (readRecordCount < writeRecordCount) {
			if (dataBuffer.remaining() == 0) {
				if (!loadData()) {
					return false;
				}
			}
			int recordSize = ByteBufferUtils.decodeLength(dataBuffer);

			int oldLimit = dataBuffer.limit();
			dataBuffer.limit(dataBuffer.position() + recordSize);
			recordBuffer.put(dataBuffer);
			dataBuffer.limit(oldLimit);
			recordBuffer.flip();
			record.deserialize(recordBuffer);
			recordBuffer.clear();
			readRecordCount++;

			return true;
		}
		return false;
	}
	
	public boolean loadData() throws IOException {
		if (nextSlot < fileBuffers.size()) {
			DiskSlot slot = fileBuffers.get(nextSlot++);
			dataBuffer.clear();
			tmpFileChannel.read(dataBuffer, (long)slot.getSlot()*dataBufferSize);
			dataBuffer.flip();
			dataBuffer.limit(slot.getUsedBytes());
			return true;
		}
		return false;
		
	}

	public void close() throws IOException {
		if (tmpFileChannel != null) {
			tmpFileChannel.close();
		}
		tmpFile.delete();
	}
	
	public void clear() {
		fileBuffers.clear();
		dataBuffer.clear();
		
		writeRecordCount = 0;
		readRecordCount = 0;
		nextSlot = 0;
		try {
			tmpFileChannel.truncate(0);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public void reset() {
		readRecordCount = 0;
		nextSlot = 0;
	}
	
	private static class DiskSlot {
        int slot;
        int usedBytes;
        
         DiskSlot(int slot,int usedBytes){
            this.slot=slot;
            this.usedBytes=usedBytes;
        }


         DiskSlot(int slot){
             this(slot,-1);
         }
         
        /**
         * @return the slot
         * @since 21.11.2006
         */
         int getSlot() {
            return slot;
        }

        /**
         * @return the usedBytes
         * @since 21.11.2006
         */
         int getUsedBytes() {
            return usedBytes;
        }

         /**
         * @param bufferSize
         * @return
         * @since 27.11.2006
         */
        long getPosition(final int bufferSize){
             final long position=slot;
             return position * bufferSize;
         }
         
        /**
         * @param usedBytes the usedBytes to set
         * @since 21.11.2006
         */
         void setUsedBytes(int usedBytes) {
            this.usedBytes = usedBytes;
        }
        
    }

}
