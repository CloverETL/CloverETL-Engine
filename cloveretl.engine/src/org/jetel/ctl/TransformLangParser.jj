/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. TransformLangParser.jj */
/*@egen*//*
    Clover.ETL - Transformation language grammar.
    (c) 2004-07 David.Pavlis <david.pavlis@centrum.cz>, Michal Tomcanyi <michal.tomcanyi@javlin.cz>
    Released under LGPL license.
    
    (Adapted from Ken Beesley and Metamata's javacc 'Interpreter' example.)
 
*/


/* *********** !!!!!!!!!!!!!!! Compilation note !!!!!!!!!!!!!! *****************
	After modifying this file you must execute ant target generate-java-sources (eclise launch configuration "cloveretl.engine generate-java-sources")
	 
	Whenever parser is manually recompiled by javacc, you need to:
	
	1. Delete the file org.jetel.ctl.Node.java
	   Delete the file org.jetel.ctl.SimpleNode.java
	   Because all AST nodes are using org.jetel.ctl.ASTNode.Node as their parent
	   
	2. Fix imports in org.jetel.interpreter.TransformLangParserVisitor.java
	   Since our AST nodes are located in package org.jetel.ctl.ASTNode
	   Add TransformLangParserVisitor extends SyntheticNodeVisitor interface
	   
	3. Modify org.jetel.ctl.TransformLangParser.jj_consume_token():
	 	
	 	...
	 	jj_kind = kind;
    	tokenError(kind); // <- Inserted
    	throw generateParseException();
	    }
	    
	    
	    If not done, most of the syntactic errors will not be correctly reported by the parser
	    and javacc does not provide token_error() method mentioned in documentation anymore.
	    `
	4. Before making a commit of production parser be sure to set the 
		DEBUG_PARSER = false;
   		DEBUG_TOKEN_MANAGER = false;
   		Otherwise the parser generates amounts of debug messages iin background and is much slower.
   *****************************************************************************/

options {
              
   STATIC=false; 
                 
   JDK_VERSION = "1.6";
   CACHE_TOKENS=true;
                         
                      
                                
   JAVA_UNICODE_ESCAPE = true;
                             // change to true only if new Node has been added 
   DEBUG_PARSER = false;	
   DEBUG_TOKEN_MANAGER = false;
   
}


/* *** Specifcation of the parser class *** */

PARSER_BEGIN(TransformLangParser)

package org.jetel.ctl;

import org.jetel.graph.TransformationGraph;
import org.jetel.ctl.ASTnode.*;
import org.jetel.ctl.data.TLType;
import org.jetel.ctl.data.TLTypePrimitive;
import org.jetel.ctl.data.Scope;
import org.jetel.util.property.PropertyRefResolver;
import org.jetel.util.property.RefResFlag;
import org.jetel.util.string.StringUtils;
import org.jetel.util.file.FileUtils;
import org.jetel.component.RecordTransform;
import java.util.Map;
import java.util.HashSet;
import java.util.List;
import java.io.Reader;
import java.io.StringReader;
import java.io.IOException;
import java.net.URL;


public class TransformLangParser extends ExpParser/*@bgen(jjtree)*/implements TransformLangParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTTransformLangParserState jjtree = new JJTTransformLangParserState();

/*@egen*/

	   private ParserHelper parserHelper;       
       private boolean hasEvalNode;
	   private HashSet<String> parsedImports;
	   private ProblemReporter problemReporter;
	   private TransformationGraph graph;
       private PropertyRefResolver propertyRefResolver;
       private String encoding;
       private boolean isImported = false;
       private String sourceCode;
       private int tabSize;

	/**
	 * Creates the main parser
	 */
	public TransformLangParser(TransformationGraph graph, ProblemReporter problemReporter, java.io.Reader input, String encoding) {
		this(input);
		if (input instanceof SourceCodeProvider) {
			this.sourceCode = ((SourceCodeProvider) input).getSourceCode();
		}		this.graph = graph;
		this.propertyRefResolver = (graph != null) ? new PropertyRefResolver(graph.getGraphProperties()) : null;
		this.parserHelper = new ParserHelper();
		this.hasEvalNode = false;
		this.parsedImports = new HashSet<String>();
		this.problemReporter = problemReporter;
		this.encoding = encoding;
	}
       
      /**
       * Used by main parser to create import parsers
       */
      public TransformLangParser(TransformLangParser parent, String filename, java.io.Reader input){			  this(input);
			  this.graph = parent.graph;              this.propertyRefResolver = parent.propertyRefResolver;
			  this.parserHelper=parent.parserHelper;
			  this.hasEvalNode = false;              this.problemReporter = parent.problemReporter;
              this.parsedImports = parent.parsedImports;              this.isImported  = true;
              this.encoding = parent.encoding;
              this.setTabSize(parent.tabSize);
      }
      
	public void reset(java.io.Reader input) {
  		parserHelper.reset();
		hasEvalNode = false;
		parsedImports.clear();
		problemReporter.reset();
		this.sourceCode = (input instanceof SourceCodeProvider) ? ((SourceCodeProvider) input).getSourceCode() : null;
		ReInit(input);	
	}

	public String getSource() {		return sourceCode;
	}

	public String getEncoding() {
	    return encoding;	}

	public void setTabSize(int size) {
	    this.tabSize = size;
		this.token_source.input_stream.setTabSize(size);
	}

	public int getTabSize() {	    return this.tabSize;
	}

    @Override
    public final Map<String,List<CLVFFunctionDeclaration>> getFunctions(){
        return parserHelper.getFunctions();
    }
    
     public static final String unquote(String image){
     	return image.substring(1,image.length()-1);
     }

	public void addVariable(CLVFVariableDeclaration var) {
		CLVFVariableDeclaration oldDeclaration = null;
		if ((oldDeclaration = parserHelper.addVariable(var)) != null) {
			error(var,"Duplicate variable '" + var.getName() + "'");
		}
	}
	
	public CLVFVariableDeclaration checkDeclaration(String name, int beginLine, int beginColumn, int endLine, int endColumn) {
		CLVFVariableDeclaration var = parserHelper.getVariable(name);
		if (var == null) {
			error(beginLine,beginColumn,endLine,endColumn,"Variable '" + name + "' is not declared");
		}
		
		return var;
	}
	
	/** Method for entering function blocks and checking for duplicate declarations */
	public void enteredBlock(CLVFFunctionDeclaration func) {
		if (!parserHelper.enteredBlock(func)) {
			error(func,"Duplicate function '" + func.getName() + "'"); 
		}
	}
	
	/** Method for entering anonymous code blocks (loops/switch/if bodies) */
	public Scope enteredBlock() {
		return parserHelper.enteredBlock();
	}
	
	public void exitedBlock() {
		parserHelper.exitedBlock();
	}
	
	public int getCurrentBlockOffset() {
		return parserHelper.getCurrentBlockOffset();
	}
      
    /**
     * Does the parsed AST tree contain any "eval" node ?
     * If so, executor will need reference to parser to process such
     * nodes
     *
     */
    
    public boolean hasEvalNode(){
    	return hasEvalNode;
    }
    
	public boolean isParsedImport(String url) {
		return parsedImports != null && parsedImports.contains(url);
	}

    public void addParsedImports(HashSet<String> imports) {
    	if (imports == null) {
    		return;
    	}
    	
    	if (parsedImports == null) {
    		parsedImports = new HashSet<String>();
    	}
    	
    	parsedImports.addAll(imports);
    		
    }
    
    public void addParsedImport(String url) {
    	
    	if (parsedImports == null) {
    		parsedImports = new HashSet<String>();
    	}
    	
    	parsedImports.add(url);
    }
    
    public HashSet<String> getParsedImports() {
    	return parsedImports;
    }
    
    
    // -------------------- Error Reporting --------------------------
    
   	private void warn(SimpleNode node, String error, String hint) {
		problemReporter.warn(node.getBegin(), node.getEnd(), error, hint);
	}
	
	private void warn(Token token, String error, String hint) {
		problemReporter.warn(token.beginLine,token.beginColumn,token.endLine,token.endColumn,error,hint);
	}

	private void warn(int beginLine, int beginColumn, int endLine, int endColumn, String error, String hint) {
		problemReporter.warn(beginLine, beginColumn, endLine, endColumn, error, hint);
	}
	
	private void error(Token token, String error) {
		problemReporter.error(token.beginLine,token.beginColumn,token.endLine,token.endColumn,error,null);
	}
	
	private void error(Token token, String error, String hint) {
		problemReporter.error(token.beginLine,token.beginColumn,token.endLine,token.endColumn,error,hint);
	}
	
	private void error(int beginLine, int beginColumn, int endLine, int endColumn, String error) {
		problemReporter.error(beginLine, beginColumn, endLine, endColumn, error, null);
	}
	
	private void error(SimpleNode node, String error) {
		problemReporter.error(node.getBegin(), node.getEnd(), error, null);
	}
	
	private void error(SimpleNode node, String error, String hint) {
		problemReporter.error(node.getBegin(), node.getEnd(), error, hint);
	}

	public ProblemReporter getProblemReporter() {
		return this.problemReporter;
	}
	
    /**
     *  Method to report a shift-operation for an unexpected token.
     *  Insert: Call to this method into the generated parser's jj_consume_token() method
     *  just before 'throw generateException()' line
     */
    public void tokenError(int expectedKind) {
		String errorMessage;
		if (jj_nt.kind != EOF) {
			errorMessage = "Syntax error on token '" + jj_nt.image + "'";
		} else {
			// EOF has code 0 and is not present in tokenImage
			errorMessage = "Syntax error - unexpected end of file";
		}

		String hint;
		if (expectedKind > 0) {
			hint = "Insert " + tokenImage[expectedKind] + " to correct";
		} else {
			hint = "Delete this token";
		}

		error(jj_nt, errorMessage, hint);
	}
	
	/**
	 * Analyzes special tokens (comments) for occurrence of indication comment to determine
	 * if compiled or non-compiled mode is active.
	 */
	private boolean isCompiledMode(Token regular) {
       		boolean lastCompiled = false;
                while (regular.specialToken != null) {
                        switch (regular.specialToken.kind) {
                                case TL_COMPILE:
                                        // this is #CTL2:COMPILE -> running in compiled mode
                                        // NEW COMMENT
                                        lastCompiled = true;
                                        regular = regular.specialToken;
                                        break;
                                case TL_SHEBANG:
                                        // this is #CTL2 -> running in non-compiled mode
                                        lastCompiled = false;
                                        regular = regular.specialToken;
                                        break;
                                default:
                                        // check previous special token (if any)
                                		regular = regular.specialToken;
                                        break;
                        }
                }

                // we checked all special tokens and did not find #CTL2:COMPILED -> return false
                return lastCompiled;
	}
    
    
    public void parsingError(ParseException e) {
    	// inspired by ParseException.toString()
    	Token errorToken = e.currentToken;
		if (e.currentToken.next != null) {
			errorToken = e.currentToken.next;
    	}
    	
    	int beginLine = 1;
    	int beginColumn = 1;
    	int endLine = 1;
    	int endColumn = 2;
    	String errorMessage = "Unrecoverable syntax error(s) occured"; 
    	if (errorToken != null) {
			beginLine = errorToken.beginLine;
			beginColumn = errorToken.beginColumn;
			endLine = errorToken.endLine;
			endColumn = errorToken.endColumn;
			errorMessage = "Syntax error on token '" + errorToken.image + "'";
    	}
    	
    	error(beginLine,beginColumn,endLine,endColumn,errorMessage);
    }
    
	// checks if LHS is a valid variable for assignment
	// NOTE: variable intializers are not handled as assignments but as an expression!
	//       that is why there is no JJTVARIABLEDECLARATION in thwe switch below      
    private boolean checkAssignmentTarget(SimpleNode lhs) {
		switch (lhs.getId()) {
		case TransformLangParserTreeConstants.JJTIDENTIFIER:
		case TransformLangParserTreeConstants.JJTFIELDACCESSEXPRESSION:
		case TransformLangParserTreeConstants.JJTDICTIONARYNODE:
			// identifier and field are valid LHS of assignment
			return true;
		case TransformLangParserTreeConstants.JJTARRAYACCESSEXPRESSION:
			SimpleNode child = (SimpleNode) lhs.jjtGetChild(0);
			if (child.getId() == TransformLangParserTreeConstants.JJTFUNCTIONCALL) {
				return true; // return type should be list or map, will be checked later
			}
			// for array access, the 'array' must be a valid target (i.e. identifier)
			return checkAssignmentTarget(child);
		case TransformLangParserTreeConstants.JJTMEMBERACCESSEXPRESSION:
			// for member access, the source object must be a valid identifier (not a lookup, method..)
			return checkAssignmentTarget((SimpleNode)lhs.jjtGetChild(0));
		}
		
		// anyhting else is not valid
		return false;
	}
}

PARSER_END(TransformLangParser)

/* *** Token specification *** */

/* Skip whitespace */
SKIP : { " " | "\t" | "\n" | "\r" | "\n\r" }


/* HANDLING COMMENTS */
SPECIAL_TOKEN: {  <"/*"> : WithinComment }
<WithinComment> SPECIAL_TOKEN:
{
    <"*/"> : DEFAULT
}

<WithinComment> MORE: { <~[]> }

SPECIAL_TOKEN : {
	< "//" > : WithinSingleLineComment
}

<WithinSingleLineComment> SPECIAL_TOKEN : {
	<"\n"|"\r"|"\r\n"> : DEFAULT
}

<WithinSingleLineComment> MORE : { <~[]> }

<WithinSingleLineComment, WithinComment> SPECIAL_TOKEN : {	< TL_SHEBANG : "#CTL2" > 	|	< TL_COMPILE : "#CTL2:COMPILE" >}



//SPECIAL_TOKEN : //{//    < SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")? > : WithinSingleLineComment //} 



/* Literals */
TOKEN : 
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL> 
      | <OCTAL_LITERAL>
  >
|
  < LONG_LITERAL:  <INTEGER_LITERAL> ["l","L"] >
|
  < DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
 
|  
  < STRING_LITERAL: 
		"\"" 
		(	( ~["\"","\\","\n","\r"] ) 
			| ("\\" 
				~["\n", "\r"]
			  )
		)* 
		"\""
   >
|
  < BOOLEAN_LITERAL: "true" | "false" >
|
  < DATE_LITERAL: ["0"-"9"]["0"-"9"]["0"-"9"]["0"-"9"]"-"["0"-"9"](["0"-"9"])?"-"["0"-"9"](["0"-"9"])? >
|
  < DATETIME_LITERAL: ["0"-"9"]["0"-"9"]["0"-"9"]["0"-"9"]"-"["0"-"9"](["0"-"9"])?"-"["0"-"9"](["0"-"9"])? " " ["0"-"9"](["0"-"9"])? ":" ["0"-"9"](["0"-"9"])? ":" ["0"-"9"](["0"-"9"])?>
| 
  < NULL_LITERAL: "null">
}

/* CTL standard functions */
TOKEN: 
{
 < ISNULL: "isnull">
|
 < NVL: "nvl" >
|
 < NVL2: "nvl2" >
|
 < IIF: "iif" >
|
 < IN: "in" >
|
 < PRINT_ERR: "printErr" >
|
 < PRINT_LOG: "printLog" >
|
 < PRINT_STACK: "printStack" >
|
 < RAISE_ERROR: "raiseError" >
}

TOKEN: 
{
	< STRING_PLAIN_LITERAL:
      "'"
        >
        {
        	char inChar,prevChar=' ';
        	image.setLength(0);
        	int startLine=input_stream.getBeginLine();
        	int startCol=input_stream.getBeginColumn();
        	try{
        		LOOP: while(true){
        			inChar=input_stream.readChar();
        			switch(inChar){
        			 case '\'':
        				if (prevChar=='\\')
        					image.setLength(image.length()-1);
        				else
        					break LOOP;
        			break;
        			case 'u':
        				if (prevChar=='\\')
        					image.setLength(image.length()-1);
        				break;
        			case '\r':
        			case '\n':
        				if (prevChar=='\\')
        					image.setLength(image.length()-1);
        				else
        					throw new UnterminatedStringException(startLine,startCol,input_stream.getEndLine(),input_stream.getEndColumn());
        				break;
        			}
        			image.append(inChar);
        			prevChar=inChar;
        		}
        	}catch(java.io.IOException ioe){
        		throw new UnterminatedStringException(startLine,startCol,input_stream.getEndLine(),input_stream.getEndColumn());
        	}
        	matchedToken.image=image.toString();
        	matchedToken.endLine = input_stream.getEndLine();
            matchedToken.endColumn = input_stream.getEndColumn();
        }
}

/* Logical operators */
TOKEN [IGNORE_CASE]: 
{
  < OR: "or" | "||" >
| < AND: "and" | "&&" >
| < NOT: "not" | "!" >
}


/* Comparison Operators */
TOKEN [IGNORE_CASE]: 
{
  < EQUAL: "==" | ".eq.">
| < NON_EQUAL: "!=" | "<>" | ".ne." >
| < LESS_THAN: "<" | ".lt." >
| < LESS_THAN_EQUAL: "<=" | "=<" | ".le." >
| < GREATER_THAN: ">" | ".gt.">
| < GREATER_THAN_EQUAL: ">=" | "=>" | ".ge." >
| < REGEX_EQUAL: "~=" | ".regex." >
| < REGEX_CONTAINS: "?=" >
}

/* Numeric Operators */
TOKEN: 
{
  < MINUS: "-" >
| < PLUS: "+" >
| < MULTIPLY: "*" >
| < DIVIDE: "/" >
| < MODULO: "%" >
| < INCR: "++" >
| < DECR: "--" >
| < TILDA: "~" >

}

/* Separators */
TOKEN: 
{
  < ASSIGN: "=" >
| < MAPPING: ":=" > 
| < SEMICOLON: ";" >
| < BLOCK_START: "{" >
| < BLOCK_END: "}" >
| < OPEN_PAR: "(" > 
| < CLOSE_PAR: ")" >
| < DOT: "." >
| < QUESTION_MARK: "?" >
| < COLON: ":" > 
}

/* Types */
TOKEN : 
{ 	
    <INT_VAR: "integer" >
 |  <LONG_VAR: "long" >
 |  <DATE_VAR: "date" >
 |  <DOUBLE_VAR: "number" | "double" >
 |  <DECIMAL_VAR: "decimal" >
 |  <BOOLEAN_VAR: "boolean" >
 |  <STRING_VAR: "string" >
 |  <BYTE_VAR: "byte" | "cbyte">
 |  <LIST_VAR: "list" >
 |  <MAP_VAR: "map" >
 |  <RECORD_VAR: "record" >
 |  <OBJECT_VAR: "object" >
 |  <VOID_VAR: "void" >
 }

/* Reserved words */
TOKEN :
{
  < BREAK: "break" >
| < CONTINUE: "continue" >
| < ELSE: "else" >
| < FOR: "for" >
| < FOR_EACH: "foreach" >
| < FUNCTION: "function" >
| < IF: "if" >
| < RETURN: "return" >
| < WHILE: "while" >
| < CASE: "case" >
| < ENUM: "enum" >
| < IMPORT: "import" >
| < SWITCH: "switch" >
| < CASE_DEFAULT: "default" >
| < DO: "do" >
| < TRY: "try" >
| < CATCH: "catch" >
| < LOOKUP: "lookup" >
| < LOOKUP_NEXT: "lookup_next" > // obsolete
| < LOOKUP_FOUND: "lookup_found" > // obsolete
| < LOOKUP_ADMIN: "lookup_admin" > // obsolete
| < DICTIONARY: "dictionary" >
| < SEQUENCE: "sequence" >
| < LOGLEVEL_DEBUG: "debug" >
| < LOGLEVEL_INFO: "info" >
| < LOGLEVEL_WARN: "warn" >
| < LOGLEVEL_ERROR: "error" >
| < LOGLEVEL_FATAL: "fatal" >
| < LOGLEVEL_TRACE: "trace" >
}

/* Date parts */
TOKEN : 
{ 
  < YEAR: "year" >
| < MONTH: "month" > 
| < WEEK: "week" >
| < DAY:  "day" >
| < HOUR:  "hour" >
| < MINUTE: "minute" >
| < SECOND: "second" >
| < MILLISEC: "millisec" >
}


/* Transformation return value constants */
TOKEN : 
{
  < RETURN_OK: "OK" >
| < RETURN_SKIP: "SKIP" >
| < RETURN_ALL: "ALL" >
| < RETURN_STOP: "STOP" >
}

/*
 * Record field access in form $1.fieldName clashes with float numbers since it is parsed as
 * "$" and "1.". Therefore after "$" we switch to a new lexical state WithinFieldIdentifier and parse the record
 * identifier (either numeric or as an identifier), then switch back to DEFAULT
 */
TOKEN : 
{
	< FIELD_ACCESS_OPERATOR : "$" | "$in." | "$out." > :  WithinFieldIdentifier 
}

<WithinFieldIdentifier> 
TOKEN :
{
  <RECORD_ACCESS_FIRST_PART :  ( <NUMERIC_ID> | <STRING_ID> ) >
  // after this token, decide whether to switch to DEFAULT state or to ExpectingFieldIdentifier
  // the decision is made using a custom lookahead
  // we need to distinguish between function call and string field identifiers
  // - function call is followed by a left parenthesis
  {
		boolean fieldIdentifier = false; // is the following token a field identifier?
		int count = 0; // the number of characters to rollback
		try  {
		    char c = input_stream.readChar(); // read the first character
			count++;
		    if (c == '.') { // field identifier may only come after '.'
				c = input_stream.readChar(); // read the second character
				count++;
			    if (c == '_' || Character.isLetter(c)) { // string identifier
				    do { // read letters, digits and underscores
						c = input_stream.readChar();
						count++;
				    } while(c == '_' || Character.isLetterOrDigit(c));
				    while (c == ' ' || c == '\t' || c == '\r' || c == '\n') { // skip whitespace after the identifier
						c = input_stream.readChar();
						count++;
				    }
				    if (c != '(') { // the identifier is actually a function name
				    	fieldIdentifier = true;
				    } else {
//				    	System.out.print("\nFunction call");
				    }
			    } else if (Character.isDigit(c)) { // numeric identifier
					// if the first character is a number, assume it is a numeric field identifier
					// TODO if there are more digits, make sure the first one is [1-9]
			    	fieldIdentifier = true;				} else if (c == '*') { // asterisk
					// also expect <RECORD_ACCESS_SECOND_PART> if there is an asterisk			    	fieldIdentifier = true;
				}
		    }
		} catch (Exception ex) {
			// end of file
		} finally {
		    try {
//				System.out.println();
				input_stream.backup(count); // rollback to the original position
		    } catch(Exception ex) {
		    	throw new RuntimeException("Error restoring previous input stream position", ex);
		    }
		}
		
		if (fieldIdentifier) {
//			System.out.println("Expecting a field identifier");
			// manually switch state to <ExpectingFieldIdentifier>
			SwitchTo(TransformLangParserConstants.ExpectingFieldIdentifier);
		} else {
//			System.out.println("Not expecting a field identifier");
			// manually switch state to <DEFAULT>
			SwitchTo(TransformLangParserConstants.DEFAULT);
		}
	    
   }
}

// See above. When identifier of field is parsed jump back to DEFAULT lexical state
<ExpectingFieldIdentifier> 
TOKEN :
{
  <RECORD_ACCESS_SECOND_PART : "." ( <NUMERIC_ID> | <STRING_ID> | "*") > : DEFAULT| 
  < #NUMERIC_ID : ( [ "1"-"9" ] )? ( [ "0" - "9" ] )+ >
|
  < #STRING_ID : <IDENTIFIER> >
}

TOKEN : 
{
  < IDENTIFIER: (<LETTER>|<UNDERSCORE>) (<LETTER>|["0"-"9"]|<UNDERSCORE>)* > 
| 
  < #LETTER: ["a"-"z","A"-"Z" ]>
| 
  < #UNDERSCORE: "_" > 
}




/* 
 *  The start nonterminal and its productions. 
 *  Nonterminal & productions for transformation language
 */
CLVFStart Start() :         // Start -> Exp
{/*@bgen(jjtree) Start */
  CLVFStart jjtn000 = new CLVFStart(this, JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
        try {
/*@egen*/
	{
		if (!isImported)
	  	{			// create global scope
			jjtn000.setScope(enteredBlock());
		} else		{
		  	// for the imported source file reuse current scope
			jjtn000.setScope( parserHelper.getCurrentScope());
		}
		
		// check comments for execution mode indication
		jjtn000.setCompiled(isCompiledMode(jj_nt));
	}
	try {
  		CompilationUnit()
	} catch (EndOfFileException e) { 		// Parsing deliberately terminated in unknownToken() due to EOF token
	} catch (UnterminatedStringException e) {
		error(e.beginLine,e.beginColumn,e.endLine,e.endColumn,"Unterminated string literal encountered");
  	} catch (ParseException e) {
  		error(e.currentToken, "Syntax error");
	} catch (Exception e) {
		error(1,1,1,2,"Parser error: " + e.getMessage());
		e.printStackTrace();
	} catch (TokenMgrError e) {
		error(1,1,1,2,"Invalid lexical token encountered: " + e.getMessage());
	}/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
	
	{
		if (!isImported)
	  	{
			exitedBlock();		
		}
  		return jjtn000;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

/* 
 *  The start expression nonterminal and its productions. 
 *  Nonterminal & productions for expressions only
 */
CLVFStartExpression StartExpression() : {/*@bgen(jjtree) StartExpression */
  CLVFStartExpression jjtn000 = new CLVFStartExpression(this, JJTSTARTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) StartExpression */
        try {
/*@egen*/
	{
		jjtn000.setScope(enteredBlock());
		// check the comment (if any) and set the compilation mode
		jjtn000.setCompiled(isCompiledMode(jj_nt));
	}
	
	try {	
  		ConditionalFailExpression()
	} catch (EndOfFileException e) { 
		// Parsing deliberately terminated in unknownToken() due to EOF token
  	} catch (ParseException e) {
  		error(1,1,1,2, "Syntax error");
	} catch (Exception e) {
		error(1,1,1,2,"Parser error: " + e.getMessage());
		e.printStackTrace();
	} catch (TokenMgrError e) {
		error(1,1,1,2,"Invalid lexical token encountered: " + e.getMessage());
	}/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
	
	{ 
		exitedBlock();		return jjtn000;	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/}	
void CompilationUnit()       :
{}
{
	(ImportSource() ";" )*

	try {
   (
	   LOOKAHEAD(3)
       Statement()     |
       VariableDeclaration() ";"     |
       FunctionDeclaration()
	 | 	   unknownToken() // consumes EOF as well and throw exception to finish processing
   )*
	} catch (ParseException e) {
		recover(SEMICOLON); // this handles problems in variable initializers
	}
   
   
}


void StatementOrBlock()       :
{}
{
	/*
	 * Insert a fake block node in case there is only a single statement to simplify processing.
	 * This will also insert empty Block node in case loop has no body
	 */
	Statement()
	{
		SimpleNode blockStatement = (SimpleNode)jjtree.popNode();
		CLVFBlock fakeBlock = new CLVFBlock(this,JJTBLOCK);
		fakeBlock.jjtSetParent(blockStatement.jjtGetParent());
		fakeBlock.jjtAddChild(blockStatement,0);
		fakeBlock.begin(blockStatement.getLine(),blockStatement.getColumn());
		fakeBlock.end(blockStatement.getEnd().getLine(),blockStatement.getEnd().getColumn());
		blockStatement.jjtSetParent(fakeBlock);
		jjtree.pushNode(fakeBlock);
	}
	|
	Block()
}


void ImportSource() :{/*@bgen(jjtree) ImportSource */
        CLVFImportSource jjtn000 = new CLVFImportSource(this, JJTIMPORTSOURCE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/	Token t;	String filenameURL;}{/*@bgen(jjtree) ImportSource */
        try {
/*@egen*/	// must parse whole tree and insert it at this place	<IMPORT>
	{
		jjtn000.begin(token.beginLine,token.beginColumn);
	}
	 ( 
	 	t=<STRING_LITERAL> { filenameURL=unquote(t.image); }		| 
		t=<STRING_PLAIN_LITERAL> { filenameURL=t.image; } 
	 )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{		// tag end of import
		jjtn000.end(t.endLine,t.endColumn);

		// to prevent parsing of an existing import
		if (!isParsedImport(filenameURL)) {
			Reader input;
			
			// we need to resolve the filename to project path (if it is relative)
			final URL projectURL = graph != null ? graph.getRuntimeContext().getContextURL() : null;
			
			jjtn000.setSourceToImport(filenameURL);			CLVFStart parseTree = null;
    		// store current "import context" so we can restore it after parsing this import
    		String importFileUrl = problemReporter.getImportFileUrl();
    		ErrorLocation errorLocation = problemReporter.getErrorLocation();

			try {
				String importSourceCode = null;
				try {
					importSourceCode = FileUtils.getStringFromURL(projectURL, filenameURL, encoding);
				} catch (RuntimeException re) { // CLO-2167
				  	if (re.getCause() instanceof IOException) {
				  	    throw (IOException) re.getCause();				  	} else {						throw new IOException(re.getMessage());
				 	}				} catch (Exception e) {
					throw new IOException(e.getMessage());
				}
				if (propertyRefResolver != null) {
					importSourceCode = propertyRefResolver.resolveRef(importSourceCode, RefResFlag.SPEC_CHARACTERS_OFF);
				}

				input = new StringReader(importSourceCode);
				addParsedImport(filenameURL); // the above will handle invalid URL etc.
                // set new "import context", propagate error location if already defined
        		problemReporter.setImportFileUrl(filenameURL);
        		problemReporter.setErrorLocation((errorLocation != null)
        				? errorLocation : new ErrorLocation(jjtn000.getBegin(), jjtn000.getEnd()));

				TransformLangParser parser = new TransformLangParser(this,filenameURL,input);				
				parser.addParsedImports(getParsedImports());
			 	parseTree = parser.Start();
			 	jjtn000.setSourceFilename(filenameURL);				jjtn000.jjtAddChild(parseTree,0);
				jjtn000.jjtGetChild(0).jjtSetParent(jjtn000);
				addParsedImports(parser.getParsedImports()); // merge child's imports
				this.hasEvalNode = this.hasEvalNode || parser.hasEvalNode;			} catch(IOException e){				error(jjtn000,"Unable to open import \""+filenameURL+"\": " + e.getMessage());
			} finally {
        		// restore current "import context"
        		problemReporter.setImportFileUrl(importFileUrl);
        		problemReporter.setErrorLocation(errorLocation);
			}
		} else {                        warn(jjtn000, "Multiple import of \""+filenameURL+"\": ignoring redundant occurrences", "Try to remove multiple occurrences of import of the same file");
		}		  

	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/}


void FunctionDeclaration()      :
{}
{
	 	LOOKAHEAD(3) // disabiguate between V1 and V2 declaration
	 (
	 	// obsolete syntax
	  	V1FunctionDeclaration()
	  	{
	  		SimpleNode n = (SimpleNode)jjtree.peekNode();
			error(n,"Obsolete function declaration",
			"Use 'function <ReturnType> functionName(<ParamType> param,...)' instead");
		}
	 )
	|
	 (
	 	V2FunctionDeclaration()
	 )
}



void V2FormalParameters()            :
{/*@bgen(jjtree) Parameters */
  CLVFParameters jjtn000 = new CLVFParameters(this, JJTPARAMETERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Parameters */
        try {
/*@egen*/
	"(" 
	{
		jjtn000.begin(token.beginLine,token.beginColumn);
	}
		[ V2FormalParameter() ("," V2FormalParameter() )* ] 
	")"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.end(token.endLine,token.endColumn);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ReturnType()      :
{}
{
	VariableType()
	|
	VoidType()
}

void VoidType()       :
{/*@bgen(jjtree) Type */
  CLVFType jjtn000 = new CLVFType(this, JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Type */
        try {
/*@egen*/
	"void"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.begin(token.beginLine,token.beginColumn);
		jjtn000.end(token.endLine,token.endColumn);
		jjtn000.setKind(VOID_VAR);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void V2FunctionDeclaration()                     :
{/*@bgen(jjtree) FunctionDeclaration */
  CLVFFunctionDeclaration jjtn000 = new CLVFFunctionDeclaration(this, JJTFUNCTIONDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionDeclaration */
        try {
/*@egen*/
	
	"function"
	{ 
		jjtn000.begin(token.beginLine,token.beginColumn);
	}
	
	ReturnType()
	<IDENTIFIER>
	
	{
		jjtn000.setName(token.image);
		// function scope is allocated and saved within ParserHelper.enterBlock(CLVFFunctionDeclaration)
		enteredBlock(jjtn000);
	} 
	
	V2FormalParameters()
	Block()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	
	{
		exitedBlock();
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
	
}

/* Function parameters in the old version are not typed */
void V1FormalParameter()                     : 
{/*@bgen(jjtree) VariableDeclaration */
  CLVFVariableDeclaration jjtn000 = new CLVFVariableDeclaration(this, JJTVARIABLEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VariableDeclaration */
        try {
/*@egen*/
	{
		// push fake type node	
		CLVFType type = new CLVFType(this,JJTTYPE);
		type.setType(TLType.VOID);
		jjtree.pushNode(type);
	}
	<IDENTIFIER>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.begin(token.beginLine,token.beginColumn);
		jjtn000.end(token.endLine,token.endColumn);
		jjtn000.setName(token.image);
		addVariable(jjtn000);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void V1FormalParameters()            :
{/*@bgen(jjtree) Parameters */
        CLVFParameters jjtn000 = new CLVFParameters(this, JJTPARAMETERS);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}
{/*@bgen(jjtree) Parameters */
        try {
/*@egen*/
	"(" 
	{
		jjtn000.begin(token.beginLine,token.beginColumn);
	}
		[ V1FormalParameter()  ( "," V1FormalParameter() )* ] 
	")"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/	
	{
		jjtn000.end(token.endLine, token.endColumn);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void V1FunctionDeclaration()                     :{/*@bgen(jjtree) FunctionDeclaration */
  CLVFFunctionDeclaration jjtn000 = new CLVFFunctionDeclaration(this, JJTFUNCTIONDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) FunctionDeclaration */
        try {
/*@egen*/	"function"
	{
		jjtn000.begin(token.beginLine,token.beginColumn);
		// push fake type node
		// TODO: try to extract type from return statement in type-checking phase
		CLVFType type = new CLVFType(this,JJTTYPE);
		type.setType(TLType.VOID);
		jjtree.pushNode(type);
	}

		 
	<IDENTIFIER> 
	{ 		jjtn000.setName(token.image); 
		enteredBlock(jjtn000);	}			V1FormalParameters()	Block()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{		exitedBlock();
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/}

void V2FormalParameter()                     : 
{/*@bgen(jjtree) VariableDeclaration */
  CLVFVariableDeclaration jjtn000 = new CLVFVariableDeclaration(this, JJTVARIABLEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VariableDeclaration */
        try {
/*@egen*/
	VariableType()
	<IDENTIFIER>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.begin(token.beginLine,token.beginColumn);
		jjtn000.setName(token.image);
		jjtn000.end(token.endLine,token.endColumn);
		addVariable(jjtn000);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void PrimitiveType()      : 
{/*@bgen(jjtree) Type */
  CLVFType jjtn000 = new CLVFType(this, JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Type */
    try {
/*@egen*/
    (
    	 ( <INT_VAR>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/	
    	 	{ 
    	 		jjtn000.begin(token.beginLine,token.beginColumn);
    	 		jjtn000.end(token.endLine,token.endColumn);  
    	 		jjtn000.setKind(INT_VAR);
    	 	} 
    	 )  
    	|
    	 ( <LONG_VAR>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/	
    	 	{ 
    	 		jjtn000.begin(token.beginLine,token.beginColumn);
    	 		jjtn000.end(token.endLine,token.endColumn);  
    	 		jjtn000.setKind(LONG_VAR);
    	 	}
    	 ) 
    	|
    	 ( <DOUBLE_VAR>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/	
    	 	{ 
    	 		jjtn000.begin(token.beginLine,token.beginColumn);
    	 		jjtn000.end(token.endLine,token.endColumn);  
    	 		jjtn000.setKind(DOUBLE_VAR);
    	 	} 
    	 ) 
    	|
    	 ( <DECIMAL_VAR>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ 
    	 	{ 
    	 		jjtn000.begin(token.beginLine,token.beginColumn);
    	 		jjtn000.end(token.endLine,token.endColumn);
    	 		jjtn000.setKind(DECIMAL_VAR); 
    	 	}
    	 ) 
    	|
    	 ( <STRING_VAR>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/	
    	 	{ 
    	 		jjtn000.begin(token.beginLine,token.beginColumn);
    	 		jjtn000.end(token.endLine,token.endColumn);  
    	 		jjtn000.setKind(STRING_VAR);
    	 	} 
    	 )		|
		 ( <DATE_VAR>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/	
			{ 
    	 		jjtn000.begin(token.beginLine,token.beginColumn);
    	 		jjtn000.end(token.endLine,token.endColumn);  
    	 		jjtn000.setKind(DATE_VAR);
    	 	}
    	 ) 
		|
		 ( <BYTE_VAR>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/
		 	{ 
    	 		jjtn000.begin(token.beginLine,token.beginColumn);
    	 		jjtn000.end(token.endLine,token.endColumn);  
    	 		jjtn000.setKind(BYTE_VAR);
    	 	} 
    	 )
		|
		 ( <BOOLEAN_VAR>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/
		 	{ 
    	 		jjtn000.begin(token.beginLine,token.beginColumn);
    	 		jjtn000.end(token.endLine,token.endColumn);  
    	 		jjtn000.setKind(BOOLEAN_VAR); 
    	 	}
    	 ) 
	)/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 

}

void CompositeType()      :
{/*@bgen(jjtree) Type */
        CLVFType jjtn000 = new CLVFType(this, JJTTYPE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t, name;
}
{/*@bgen(jjtree) Type */
        try {
/*@egen*/
	(
	 ( "map" "[" PrimitiveType() "," (PrimitiveType() | CompositeType() ) "]"/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/	
	 	{ 
    		jjtn000.begin(token.beginLine,token.beginColumn);
    		jjtn000.end(token.endLine,token.endColumn);  
    		jjtn000.setKind(MAP_VAR);
    	} 
	 )
	|
	 ( 
	   //obsolete syntax
	   t = "record" "(" name = <IDENTIFIER> ")"/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/  
	   { 
	   	 jjtn000.begin(t.beginLine,t.beginColumn);
	   	 jjtn000.end(token.endLine,token.endColumn);
	   	 error(jjtn000,"Obsolete variable declaration'","Use '<MetadataName> identifier;' instead");
	   	 jjtn000.setKind(IDENTIFIER);
	   	 jjtn000.setMetadataName(name.image); 
	   }
	 ) 
	|
	 (
	 	"list"/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/  
	 	{
	 		jjtn000.begin(token.beginLine,token.beginColumn);
	 		jjtn000.end(token.endLine,token.endColumn);
	 		error(jjtn000,"Obsolete list declaration","Use '<Type>[]' instead");
	 		jjtn000.setKind(LIST_VAR);
	 	}
	 )
	 |
	 ( 
		<IDENTIFIER>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{
		 jjtn000.begin(token.beginLine,token.beginColumn);
		 jjtn000.end(token.endLine,token.endColumn);
		 jjtn000.setKind(IDENTIFIER); 
		 jjtn000.setMetadataName(token.image);
	   	}			
	 ) 
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void VariableType()              :
{/*@bgen(jjtree) #Type( isList) */
        CLVFType jjtn000 = new CLVFType(this, JJTTYPE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	boolean isList = false;
}
{/*@bgen(jjtree) #Type( isList) */
        try {
/*@egen*/
	(
	 LOOKAHEAD(2)	 CompositeType() 
	 [
	 	"[" "]"
	 	{ 
	 		isList = true;
    		jjtn000.begin(token.beginLine,token.beginColumn);
    		jjtn000.end(token.endLine,token.endColumn);  
    		jjtn000.setKind(LIST_VAR);
    	}
	 ]
	 | PrimitiveType()
	 [
	 	"[" "]"
	 	{ 
	 		isList = true;
    		jjtn000.begin(token.beginLine,token.beginColumn);
    		jjtn000.end(token.endLine,token.endColumn);  
    		jjtn000.setKind(LIST_VAR);
    	}
	 ]
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  isList);
          }
        }
/*@egen*/
}

void VariableDeclaration():{/*@bgen(jjtree) VariableDeclaration */
  CLVFVariableDeclaration jjtn000 = new CLVFVariableDeclaration(this, JJTVARIABLEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) VariableDeclaration */
    try {
/*@egen*/
    
    VariableType()
    {
    	SimpleNode n = (SimpleNode)jjtree.peekNode();
    	jjtn000.begin(n.getLine(),n.getColumn());
    }
    <IDENTIFIER>
    {
    	jjtn000.setName(token.image);
    	jjtn000.end(token.endLine,token.endColumn);
    }

    [ 
    	"=" Expression() 
    	{
    		SimpleNode expr = (SimpleNode)jjtree.peekNode();
    		jjtn000.end(expr.getEnd().getLine(),expr.getEnd().getColumn());
    	} 
    ]/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	
	{
		// having the variable registration after initializer fixes the errorneous: int a = a;
		addVariable(jjtn000);
	}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
    
}

// Formal root of expressions, delegates to AssignmentExpression
void Expression()       : 
{} 
{
	AssignmentExpression()
}

 // Cascades of assignment allowed: x=y=z=3. Achieved by recursion inside  [...]void AssignmentExpression()                 : 
{/*@bgen(jjtree) #Assignment(> 1) */
  CLVFAssignment jjtn000 = new CLVFAssignment(this, JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) #Assignment(> 1) */
        try {
/*@egen*/  	ConditionalFailExpression()
  	
	[  	 ( 
  	  <ASSIGN>
  	  |
  	  (
  	    <MAPPING>
  	    {
  	    	warn(token,"Operator ':=' is obsolete","Use '=' operator instead");
  	    }
  	  ) 
  	) 
  	{
  		// We check if the LHS is a variable reference
  		// The check can't be done immediately after ConditionalFailExpression()
  		// because of the recursive call to AssignmentExpression() below
  		final SimpleNode result = (SimpleNode)jjtree.peekNode();
  		if (! checkAssignmentTarget(result)) {
  			error(result,"The left hand side of assignment must be a variable");
  		}
  	}
  	AssignmentExpression()
   ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/}

void ConditionalFailExpression()       :
{}
{
  	ConditionalExpression()  ( LOOKAHEAD(2) ":"/*@bgen(jjtree) #ConditionalFailExpression( 2) */
                                                    {
                                                      CLVFConditionalFailExpression jjtn001 = new CLVFConditionalFailExpression(this, JJTCONDITIONALFAILEXPRESSION);
                                                      boolean jjtc001 = true;
                                                      jjtree.openNodeScope(jjtn001);
                                                    }
                                                    try {
/*@egen*/ ConditionalExpression()/*@bgen(jjtree)*/
                                                    } catch (Throwable jjte001) {
                                                      if (jjtc001) {
                                                        jjtree.clearNodeScope(jjtn001);
                                                        jjtc001 = false;
                                                      } else {
                                                        jjtree.popNode();
                                                      }
                                                      if (jjte001 instanceof RuntimeException) {
                                                        throw (RuntimeException)jjte001;
                                                      }
                                                      if (jjte001 instanceof ParseException) {
                                                        throw (ParseException)jjte001;
                                                      }
                                                      throw (Error)jjte001;
                                                    } finally {
                                                      if (jjtc001) {
                                                        jjtree.closeNodeScope(jjtn001,  2);
                                                      }
                                                    }
/*@egen*/                               )*}
void ConditionalExpression()                            : {/*@bgen(jjtree) #ConditionalExpression(> 2) */
  CLVFConditionalExpression jjtn000 = new CLVFConditionalExpression(this, JJTCONDITIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) #ConditionalExpression(> 2) */
        try {
/*@egen*/	ConditionalOrExpression()
	[ LOOKAHEAD(2) "?" ConditionalExpression() ":" ConditionalExpression() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 2);
          }
        }
/*@egen*/}void ConditionalOrExpression()       : {}        {   ConditionalAndExpression()
   ( <OR>/*@bgen(jjtree) #Or( 2) */
          {
            CLVFOr jjtn001 = new CLVFOr(this, JJTOR);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
          }
          try {
/*@egen*/ ConditionalAndExpression()/*@bgen(jjtree)*/
          } catch (Throwable jjte001) {
            if (jjtc001) {
              jjtree.clearNodeScope(jjtn001);
              jjtc001 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte001 instanceof RuntimeException) {
              throw (RuntimeException)jjte001;
            }
            if (jjte001 instanceof ParseException) {
              throw (ParseException)jjte001;
            }
            throw (Error)jjte001;
          } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  2);
            }
          }
/*@egen*/       	)*}void ConditionalAndExpression()       : {}{   EqualityExpression()
      ( <AND>/*@bgen(jjtree) #And( 2) */
           {
             CLVFAnd jjtn001 = new CLVFAnd(this, JJTAND);
             boolean jjtc001 = true;
             jjtree.openNodeScope(jjtn001);
           }
           try {
/*@egen*/ EqualityExpression()/*@bgen(jjtree)*/
           } catch (Throwable jjte001) {
             if (jjtc001) {
               jjtree.clearNodeScope(jjtn001);
               jjtc001 = false;
             } else {
               jjtree.popNode();
             }
             if (jjte001 instanceof RuntimeException) {
               throw (RuntimeException)jjte001;
             }
             if (jjte001 instanceof ParseException) {
               throw (ParseException)jjte001;
             }
             throw (Error)jjte001;
           } finally {
             if (jjtc001) {
               jjtree.closeNodeScope(jjtn001,  2);
             }
           }
/*@egen*/        	) *}void EqualityExpression()       :{}{  RelationalExpression()
    (     <EQUAL> RelationalExpression()/*@bgen(jjtree) #Comparison( 2) */
                                    {
                                      CLVFComparison jjtn001 = new CLVFComparison(this, JJTCOMPARISON);
                                      boolean jjtc001 = true;
                                      jjtree.openNodeScope(jjtn001);
                                    }
                                    try {
/*@egen*//*@bgen(jjtree)*/
                                    {
                                      jjtree.closeNodeScope(jjtn001,  2);
                                      jjtc001 = false;
                                    }
/*@egen*/ { jjtn001.setOperator(EQUAL); }/*@bgen(jjtree)*/
                                    } finally {
                                      if (jjtc001) {
                                        jjtree.closeNodeScope(jjtn001,  2);
                                      }
                                    }
/*@egen*/                  |     <NON_EQUAL> RelationalExpression()/*@bgen(jjtree) #Comparison( 2) */
                                        {
                                          CLVFComparison jjtn002 = new CLVFComparison(this, JJTCOMPARISON);
                                          boolean jjtc002 = true;
                                          jjtree.openNodeScope(jjtn002);
                                        }
                                        try {
/*@egen*//*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn002,  2);
                                          jjtc002 = false;
                                        }
/*@egen*/ { jjtn002.setOperator(NON_EQUAL); }/*@bgen(jjtree)*/
                                        } finally {
                                          if (jjtc002) {
                                            jjtree.closeNodeScope(jjtn002,  2);
                                          }
                                        }
/*@egen*/                 )*}void RelationalExpression()       :{}{  AdditiveExpression()
  (    <LESS_THAN> AdditiveExpression()/*@bgen(jjtree) #Comparison( 2) */
                                     {
                                       CLVFComparison jjtn001 = new CLVFComparison(this, JJTCOMPARISON);
                                       boolean jjtc001 = true;
                                       jjtree.openNodeScope(jjtn001);
                                     }
                                     try {
/*@egen*//*@bgen(jjtree)*/
                                     {
                                       jjtree.closeNodeScope(jjtn001,  2);
                                       jjtc001 = false;
                                     }
/*@egen*/ { jjtn001.setOperator(LESS_THAN); }/*@bgen(jjtree)*/
                                     } finally {
                                       if (jjtc001) {
                                         jjtree.closeNodeScope(jjtn001,  2);
                                       }
                                     }
/*@egen*/                  |    <GREATER_THAN> AdditiveExpression()/*@bgen(jjtree) #Comparison( 2) */
                                        {
                                          CLVFComparison jjtn002 = new CLVFComparison(this, JJTCOMPARISON);
                                          boolean jjtc002 = true;
                                          jjtree.openNodeScope(jjtn002);
                                        }
                                        try {
/*@egen*//*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn002,  2);
                                          jjtc002 = false;
                                        }
/*@egen*/ { jjtn002.setOperator(GREATER_THAN); }/*@bgen(jjtree)*/
                                        } finally {
                                          if (jjtc002) {
                                            jjtree.closeNodeScope(jjtn002,  2);
                                          }
                                        }
/*@egen*/                  |    <LESS_THAN_EQUAL> AdditiveExpression()/*@bgen(jjtree) #Comparison( 2) */
                                           {
                                             CLVFComparison jjtn003 = new CLVFComparison(this, JJTCOMPARISON);
                                             boolean jjtc003 = true;
                                             jjtree.openNodeScope(jjtn003);
                                           }
                                           try {
/*@egen*//*@bgen(jjtree)*/
                                           {
                                             jjtree.closeNodeScope(jjtn003,  2);
                                             jjtc003 = false;
                                           }
/*@egen*/ { jjtn003.setOperator(LESS_THAN_EQUAL); }/*@bgen(jjtree)*/
                                           } finally {
                                             if (jjtc003) {
                                               jjtree.closeNodeScope(jjtn003,  2);
                                             }
                                           }
/*@egen*/                  |    <GREATER_THAN_EQUAL> AdditiveExpression()/*@bgen(jjtree) #Comparison( 2) */
                                              {
                                                CLVFComparison jjtn004 = new CLVFComparison(this, JJTCOMPARISON);
                                                boolean jjtc004 = true;
                                                jjtree.openNodeScope(jjtn004);
                                              }
                                              try {
/*@egen*//*@bgen(jjtree)*/
                                              {
                                                jjtree.closeNodeScope(jjtn004,  2);
                                                jjtc004 = false;
                                              }
/*@egen*/ { jjtn004.setOperator(GREATER_THAN_EQUAL); }/*@bgen(jjtree)*/
                                              } finally {
                                                if (jjtc004) {
                                                  jjtree.closeNodeScope(jjtn004,  2);
                                                }
                                              }
/*@egen*/                  | 
   	<REGEX_EQUAL>  AdditiveExpression()/*@bgen(jjtree) #Comparison( 2) */
                                            {
                                              CLVFComparison jjtn005 = new CLVFComparison(this, JJTCOMPARISON);
                                              boolean jjtc005 = true;
                                              jjtree.openNodeScope(jjtn005);
                                            }
                                            try {
/*@egen*//*@bgen(jjtree)*/
                                            {
                                              jjtree.closeNodeScope(jjtn005,  2);
                                              jjtc005 = false;
                                            }
/*@egen*/ { jjtn005.setOperator(REGEX_EQUAL); }/*@bgen(jjtree)*/
                                            } finally {
                                              if (jjtc005) {
                                                jjtree.closeNodeScope(jjtn005,  2);
                                              }
                                            }
/*@egen*/               
   |
    <REGEX_CONTAINS> AdditiveExpression()/*@bgen(jjtree) #Comparison( 2) */
                                          {
                                            CLVFComparison jjtn006 = new CLVFComparison(this, JJTCOMPARISON);
                                            boolean jjtc006 = true;
                                            jjtree.openNodeScope(jjtn006);
                                          }
                                          try {
/*@egen*//*@bgen(jjtree)*/
                                          {
                                            jjtree.closeNodeScope(jjtn006,  2);
                                            jjtc006 = false;
                                          }
/*@egen*/ { jjtn006.setOperator(REGEX_CONTAINS); }/*@bgen(jjtree)*/
                                          } finally {
                                            if (jjtc006) {
                                              jjtree.closeNodeScope(jjtn006,  2);
                                            }
                                          }
/*@egen*/                 )*}void AdditiveExpression()       :
{}{ MultiplicativeExpression() (     <PLUS>/*@bgen(jjtree) #AddNode( 2) */
            {
              CLVFAddNode jjtn001 = new CLVFAddNode(this, JJTADDNODE);
              boolean jjtc001 = true;
              jjtree.openNodeScope(jjtn001);
            }
            try {
/*@egen*/ MultiplicativeExpression()/*@bgen(jjtree)*/
            } catch (Throwable jjte001) {
              if (jjtc001) {
                jjtree.clearNodeScope(jjtn001);
                jjtc001 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte001 instanceof RuntimeException) {
                throw (RuntimeException)jjte001;
              }
              if (jjte001 instanceof ParseException) {
                throw (ParseException)jjte001;
              }
              throw (Error)jjte001;
            } finally {
              if (jjtc001) {
                jjtree.closeNodeScope(jjtn001,  2);
              }
            }
/*@egen*/               |     <MINUS>/*@bgen(jjtree) #SubNode( 2) */
             {
               CLVFSubNode jjtn002 = new CLVFSubNode(this, JJTSUBNODE);
               boolean jjtc002 = true;
               jjtree.openNodeScope(jjtn002);
             }
             try {
/*@egen*/ MultiplicativeExpression()/*@bgen(jjtree)*/
             } catch (Throwable jjte002) {
               if (jjtc002) {
                 jjtree.clearNodeScope(jjtn002);
                 jjtc002 = false;
               } else {
                 jjtree.popNode();
               }
               if (jjte002 instanceof RuntimeException) {
                 throw (RuntimeException)jjte002;
               }
               if (jjte002 instanceof ParseException) {
                 throw (ParseException)jjte002;
               }
               throw (Error)jjte002;
             } finally {
               if (jjtc002) {
                 jjtree.closeNodeScope(jjtn002,  2);
               }
             }
/*@egen*/              )*}void MultiplicativeExpression()       : 
{}{     UnaryExpression()  (    <MULTIPLY>/*@bgen(jjtree) #MulNode( 2) */
               {
                 CLVFMulNode jjtn001 = new CLVFMulNode(this, JJTMULNODE);
                 boolean jjtc001 = true;
                 jjtree.openNodeScope(jjtn001);
               }
               try {
/*@egen*/ UnaryExpression()/*@bgen(jjtree)*/
               } catch (Throwable jjte001) {
                 if (jjtc001) {
                   jjtree.clearNodeScope(jjtn001);
                   jjtc001 = false;
                 } else {
                   jjtree.popNode();
                 }
                 if (jjte001 instanceof RuntimeException) {
                   throw (RuntimeException)jjte001;
                 }
                 if (jjte001 instanceof ParseException) {
                   throw (ParseException)jjte001;
                 }
                 throw (Error)jjte001;
               } finally {
                 if (jjtc001) {
                   jjtree.closeNodeScope(jjtn001,  2);
                 }
               }
/*@egen*/               |    <DIVIDE>/*@bgen(jjtree) #DivNode( 2) */
             {
               CLVFDivNode jjtn002 = new CLVFDivNode(this, JJTDIVNODE);
               boolean jjtc002 = true;
               jjtree.openNodeScope(jjtn002);
             }
             try {
/*@egen*/ UnaryExpression()/*@bgen(jjtree)*/
             } catch (Throwable jjte002) {
               if (jjtc002) {
                 jjtree.clearNodeScope(jjtn002);
                 jjtc002 = false;
               } else {
                 jjtree.popNode();
               }
               if (jjte002 instanceof RuntimeException) {
                 throw (RuntimeException)jjte002;
               }
               if (jjte002 instanceof ParseException) {
                 throw (ParseException)jjte002;
               }
               throw (Error)jjte002;
             } finally {
               if (jjtc002) {
                 jjtree.closeNodeScope(jjtn002,  2);
               }
             }
/*@egen*/               |    <MODULO>/*@bgen(jjtree) #ModNode( 2) */
             {
               CLVFModNode jjtn003 = new CLVFModNode(this, JJTMODNODE);
               boolean jjtc003 = true;
               jjtree.openNodeScope(jjtn003);
             }
             try {
/*@egen*/ UnaryExpression()/*@bgen(jjtree)*/
             } catch (Throwable jjte003) {
               if (jjtc003) {
                 jjtree.clearNodeScope(jjtn003);
                 jjtc003 = false;
               } else {
                 jjtree.popNode();
               }
               if (jjte003 instanceof RuntimeException) {
                 throw (RuntimeException)jjte003;
               }
               if (jjte003 instanceof ParseException) {
                 throw (ParseException)jjte003;
               }
               throw (Error)jjte003;
             } finally {
               if (jjtc003) {
                 jjtree.closeNodeScope(jjtn003,  2);
               }
             }
/*@egen*/              )*}

void UnaryExpression()       :
{}
{  (    UnaryStatement()
  |
    UnaryNonStatement()
  )
}
  
void UnaryStatement()                           :{/*@bgen(jjtree) #UnaryStatement( isPrefix) */
        CLVFUnaryStatement jjtn000 = new CLVFUnaryStatement(this, JJTUNARYSTATEMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	boolean isPrefix = false;
}
{/*@bgen(jjtree) #UnaryStatement( isPrefix) */
         try {
/*@egen*/ 		 PostfixExpression()	|	
	 (
	 	// prefix expression
		{
			// set the flag asap before jjtree has a chance to close node scope
			isPrefix = true;
		}	 	
	 	PrefixStatementOp(jjtn000)
	 	UnaryExpression() 
	 )/*@bgen(jjtree)*/
         } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             throw (RuntimeException)jjte000;
           }
           if (jjte000 instanceof ParseException) {
             throw (ParseException)jjte000;
           }
           throw (Error)jjte000;
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000,  isPrefix);
           }
         }
/*@egen*/}

void PrefixStatementOp(CLVFUnaryStatement expr)       :
{}
{ 
  (  "++" | "--"  )
  {
    expr.begin(token.beginLine,token.beginColumn);
    expr.setOperator(token.kind);
  }
}

void UnaryNonStatement()                      :
{/*@bgen(jjtree) #UnaryNonStatement(true) */
  CLVFUnaryNonStatement jjtn000 = new CLVFUnaryNonStatement(this, JJTUNARYNONSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}

{/*@bgen(jjtree) #UnaryNonStatement(true) */
         try {
/*@egen*/ 
	 (
	 	PrefixNonStatementOp(jjtn000)
	 	UnaryExpression() 
	 )/*@bgen(jjtree)*/
         } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             throw (RuntimeException)jjte000;
           }
           if (jjte000 instanceof ParseException) {
             throw (ParseException)jjte000;
           }
           throw (Error)jjte000;
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/
}
void PrefixNonStatementOp(CLVFUnaryNonStatement expr)       :
{}
{ 
  (  "-" | < NOT > )
  {
    expr.begin(token.beginLine,token.beginColumn);
    expr.setOperator(token.kind);
  }
}

void PostfixExpression()                               :{/*@bgen(jjtree) #PostfixExpression( isPostfix) */
        CLVFPostfixExpression jjtn000 = new CLVFPostfixExpression(this, JJTPOSTFIXEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	boolean isPostfix = false;
}
{/*@bgen(jjtree) #PostfixExpression( isPostfix) */
        try {
/*@egen*/	PrimaryExpression()	
	[ 
		{
			// set the flag asap before jjtree has a chance to close node scope
			isPostfix = true;
		} 
		PostfixOp(jjtn000)
	]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  isPostfix);
          }
        }
/*@egen*/ }void PostfixOp(CLVFPostfixExpression expr)       :{}{  ( "++" | "--")
  {    expr.setOperator(token.kind);
    expr.end(token.endLine,token.endColumn);  }}

void PrimaryExpression()      :
{
	Object id;
	Token t;
	Node prefix;
} 
{
	(
	 ( 
	 	LOOKAHEAD(7) // disambiguate between identifier and function call 
	 	( GeneralFunctionCall() )
		|
		( Identifier() )
		|
		( Literal() )
		|
		( LookupNode() )
		|
		( SequenceNode() )
		|
		( DictionaryNode() )
		|
		( "("	Expression() ")" )
	 	|
		( RecordOrFieldIdentifier() )
		
	 )
	 ( 
	 	{ prefix = jjtree.popNode(); }
	 	PrimarySuffix(prefix) 
	 )*
	)  
	 
}

void PrimarySuffix(Node prefix)      :
{
	Token t;
	Node memAcc = null;
}	

{
	(
		t = "."
		(
		// built-in functions can't be called like .print_err() 
		// so we can't use GeneralFunctionCall() derivation here
		 LOOKAHEAD(2)
		 FunctionCall(prefix) 
		|
		 ( <IDENTIFIER>/*@bgen(jjtree) MemberAccessExpression */
                   {
                     CLVFMemberAccessExpression jjtn001 = new CLVFMemberAccessExpression(this, JJTMEMBERACCESSEXPRESSION);
                     boolean jjtc001 = true;
                     jjtree.openNodeScope(jjtn001);
                   }
                   try {
/*@egen*//*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn001, true);
                     jjtc001 = false;
                   }
/*@egen*/ 
		   { 
		   	 jjtn001.begin(t.beginLine,t.beginColumn);
		   	 jjtn001.end(token.endLine,token.endColumn);
		   	 jjtn001.setName(token.image);
		   	 jjtn001.setWildcard(false);
		   }/*@bgen(jjtree)*/
                   } finally {
                     if (jjtc001) {
                       jjtree.closeNodeScope(jjtn001, true);
                     }
                   }
/*@egen*/
		   	                        
		   {
		   	 // push the prefix as LHS of the member access selector
		   	 memAcc = jjtree.peekNode();
		   	 memAcc.jjtAddChild(prefix,0);
		   	 memAcc.jjtSetParent(prefix.jjtGetParent());
		   	 prefix.jjtSetParent(memAcc);
		   } 
		 )
		|
		 (
		   "*"/*@bgen(jjtree) MemberAccessExpression */
                   {
                     CLVFMemberAccessExpression jjtn002 = new CLVFMemberAccessExpression(this, JJTMEMBERACCESSEXPRESSION);
                     boolean jjtc002 = true;
                     jjtree.openNodeScope(jjtn002);
                   }
                   try {
/*@egen*//*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn002, true);
                     jjtc002 = false;
                   }
/*@egen*/
		   { 
		   	 jjtn002.begin(t.beginLine,t.beginColumn);
		   	 jjtn002.end(token.endLine,token.endColumn);
		   	 jjtn002.setName(token.image);
		   	 jjtn002.setWildcard(true);
		   }/*@bgen(jjtree)*/
                   } finally {
                     if (jjtc002) {
                       jjtree.closeNodeScope(jjtn002, true);
                     }
                   }
/*@egen*/
		   	                        
		   {
		   	 // push the prefix as LHS of the member access selector
		   	 memAcc = jjtree.peekNode();
		   	 memAcc.jjtAddChild(prefix,0);
		   	 memAcc.jjtSetParent(prefix.jjtGetParent());
		   	 prefix.jjtSetParent(memAcc);
		   } 
		 )
		) 
	)
	|	// TODO: [] operator on lists means 'concatenate' -> will implement as '+'
	( 
		 	{
		 		jjtree.pushNode(prefix);
		 	}
		 
		 	t = "["  ConditionalFailExpression() "]"/*@bgen(jjtree) #ArrayAccessExpression( 2) */
                        {
                          CLVFArrayAccessExpression jjtn003 = new CLVFArrayAccessExpression(this, JJTARRAYACCESSEXPRESSION);
                          boolean jjtc003 = true;
                          jjtree.openNodeScope(jjtn003);
                        }
                        try {
/*@egen*//*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn003,  2);
                          jjtc003 = false;
                        }
/*@egen*/
		
		 	{
				jjtn003.begin(t.beginLine,t.beginColumn);
				jjtn003.end(token.beginLine,token.beginColumn);
		 	}/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc003) {
                            jjtree.closeNodeScope(jjtn003,  2);
                          }
                        }
/*@egen*/
		 	
		 	                         
	 )
	}

void GeneralFunctionCall()      :
{
	Token id;
}
{
	BuiltInFunctionCall()
	|
	FunctionCall(null)
}

void FunctionCall(Node zeroArgument)      :
{
	Token t;
}
{
	(
	 ( 
	 	t = <IN> Arguments(zeroArgument)/*@bgen(jjtree) #InFunction( 1) */
                {
                  CLVFInFunction jjtn001 = new CLVFInFunction(this, JJTINFUNCTION);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*//*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn001,  1);
                  jjtc001 = false;
                }
/*@egen*/ 
	 	{ 
	 		jjtn001.begin(t.beginLine,t.beginColumn); 
	 	}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  1);
                  }
                }
/*@egen*/	
	 	               
	 )
	|
	 ( 
	 	t = <IDENTIFIER>  Arguments(zeroArgument)/*@bgen(jjtree) #FunctionCall( 1) */
                {
                  CLVFFunctionCall jjtn002 = new CLVFFunctionCall(this, JJTFUNCTIONCALL);
                  boolean jjtc002 = true;
                  jjtree.openNodeScope(jjtn002);
                }
                try {
/*@egen*//*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn002,  1);
                  jjtc002 = false;
                }
/*@egen*/ 
	 	{
	 		jjtn002.begin(t.beginLine,t.beginColumn);
			jjtn002.setName(t.image);
	  	}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc002) {
                    jjtree.closeNodeScope(jjtn002,  1);
                  }
                }
/*@egen*/ 
	  	                
	 )
	) 
}



void BuiltInFunctionCall()      :
{
	Token t;
}
{
	(
	   ( t = <ISNULL> Arguments(null)/*@bgen(jjtree) #IsNullNode( 1) */
                                          {
                                            CLVFIsNullNode jjtn001 = new CLVFIsNullNode(this, JJTISNULLNODE);
                                            boolean jjtc001 = true;
                                            jjtree.openNodeScope(jjtn001);
                                          }
                                          try {
/*@egen*//*@bgen(jjtree)*/
                                          {
                                            jjtree.closeNodeScope(jjtn001,  1);
                                            jjtc001 = false;
                                          }
/*@egen*/ { jjtn001.begin(t.beginLine,t.beginColumn); }/*@bgen(jjtree)*/
                                          } finally {
                                            if (jjtc001) {
                                              jjtree.closeNodeScope(jjtn001,  1);
                                            }
                                          }
/*@egen*/                ) 
	 | ( t = <NVL>  Arguments(null)/*@bgen(jjtree) #NVLNode( 1) */
                                        {
                                          CLVFNVLNode jjtn002 = new CLVFNVLNode(this, JJTNVLNODE);
                                          boolean jjtc002 = true;
                                          jjtree.openNodeScope(jjtn002);
                                        }
                                        try {
/*@egen*//*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn002,  1);
                                          jjtc002 = false;
                                        }
/*@egen*/ { jjtn002.begin(t.beginLine,t.beginColumn); }/*@bgen(jjtree)*/
                                        } finally {
                                          if (jjtc002) {
                                            jjtree.closeNodeScope(jjtn002,  1);
                                          }
                                        }
/*@egen*/	             )
	 | ( t = <NVL2> Arguments(null)/*@bgen(jjtree) #NVL2Node( 1) */
                                        {
                                          CLVFNVL2Node jjtn003 = new CLVFNVL2Node(this, JJTNVL2NODE);
                                          boolean jjtc003 = true;
                                          jjtree.openNodeScope(jjtn003);
                                        }
                                        try {
/*@egen*//*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn003,  1);
                                          jjtc003 = false;
                                        }
/*@egen*/ { jjtn003.begin(t.beginLine,t.beginColumn); }/*@bgen(jjtree)*/
                                        } finally {
                                          if (jjtc003) {
                                            jjtree.closeNodeScope(jjtn003,  1);
                                          }
                                        }
/*@egen*/               )
	 | ( t = <IIF> Arguments(null)/*@bgen(jjtree) #IIfNode( 1) */
                                       {
                                         CLVFIIfNode jjtn004 = new CLVFIIfNode(this, JJTIIFNODE);
                                         boolean jjtc004 = true;
                                         jjtree.openNodeScope(jjtn004);
                                       }
                                       try {
/*@egen*//*@bgen(jjtree)*/
                                       {
                                         jjtree.closeNodeScope(jjtn004,  1);
                                         jjtc004 = false;
                                       }
/*@egen*/ { jjtn004.begin(t.beginLine,t.beginColumn); }/*@bgen(jjtree)*/
                                       } finally {
                                         if (jjtc004) {
                                           jjtree.closeNodeScope(jjtn004,  1);
                                         }
                                       }
/*@egen*/                )
	 | ( t = <PRINT_ERR> Arguments(null)/*@bgen(jjtree) #PrintErrNode( 1) */
                                             {
                                               CLVFPrintErrNode jjtn005 = new CLVFPrintErrNode(this, JJTPRINTERRNODE);
                                               boolean jjtc005 = true;
                                               jjtree.openNodeScope(jjtn005);
                                             }
                                             try {
/*@egen*//*@bgen(jjtree)*/
                                             {
                                               jjtree.closeNodeScope(jjtn005,  1);
                                               jjtc005 = false;
                                             }
/*@egen*/ { jjtn005.begin(t.beginLine,t.beginColumn); }/*@bgen(jjtree)*/
                                             } finally {
                                               if (jjtc005) {
                                                 jjtree.closeNodeScope(jjtn005,  1);
                                               }
                                             }
/*@egen*/                  )
	 | ( t = <PRINT_LOG> Arguments(null)/*@bgen(jjtree) #PrintLogNode( 1) */
                                             {
                                               CLVFPrintLogNode jjtn006 = new CLVFPrintLogNode(this, JJTPRINTLOGNODE);
                                               boolean jjtc006 = true;
                                               jjtree.openNodeScope(jjtn006);
                                             }
                                             try {
/*@egen*//*@bgen(jjtree)*/
                                             {
                                               jjtree.closeNodeScope(jjtn006,  1);
                                               jjtc006 = false;
                                             }
/*@egen*/ { jjtn006.begin(t.beginLine,t.beginColumn); }/*@bgen(jjtree)*/
                                             } finally {
                                               if (jjtc006) {
                                                 jjtree.closeNodeScope(jjtn006,  1);
                                               }
                                             }
/*@egen*/                  )
	 | ( t = <PRINT_STACK> Arguments(null)/*@bgen(jjtree) #PrintStackNode( 1) */
                                               {
                                                 CLVFPrintStackNode jjtn007 = new CLVFPrintStackNode(this, JJTPRINTSTACKNODE);
                                                 boolean jjtc007 = true;
                                                 jjtree.openNodeScope(jjtn007);
                                               }
                                               try {
/*@egen*//*@bgen(jjtree)*/
                                               {
                                                 jjtree.closeNodeScope(jjtn007,  1);
                                                 jjtc007 = false;
                                               }
/*@egen*/ { jjtn007.begin(t.beginLine,t.beginColumn); }/*@bgen(jjtree)*/
                                               } finally {
                                                 if (jjtc007) {
                                                   jjtree.closeNodeScope(jjtn007,  1);
                                                 }
                                               }
/*@egen*/                    )
	 | ( t = <RAISE_ERROR> Arguments(null)/*@bgen(jjtree) #RaiseErrorNode( 1) */
                                               {
                                                 CLVFRaiseErrorNode jjtn008 = new CLVFRaiseErrorNode(this, JJTRAISEERRORNODE);
                                                 boolean jjtc008 = true;
                                                 jjtree.openNodeScope(jjtn008);
                                               }
                                               try {
/*@egen*//*@bgen(jjtree)*/
                                               {
                                                 jjtree.closeNodeScope(jjtn008,  1);
                                                 jjtc008 = false;
                                               }
/*@egen*/ { jjtn008.begin(t.beginLine,t.beginColumn); }/*@bgen(jjtree)*/
                                               } finally {
                                                 if (jjtc008) {
                                                   jjtree.closeNodeScope(jjtn008,  1);
                                                 }
                                               }
/*@egen*/                    )
	)
	
}

/*
 * Unfortunately identifiers like $in.1 collide with float syntax allowing .1 syntax for 0.1
 * To parse this properly we would have to add lexical state switching for most of the tokens
 * because field identifier can be on RHS and shorthand $1 syntax is allowed
 */
void RecordOrFieldIdentifier()                       : 
{/*@bgen(jjtree) FieldAccessExpression */
  CLVFFieldAccessExpression jjtn000 = new CLVFFieldAccessExpression(this, JJTFIELDACCESSEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FieldAccessExpression */
        try {
/*@egen*/
	<FIELD_ACCESS_OPERATOR>
	{
		// first read the field access operator
		// can be "$", "$in." or "$out."
	 	jjtn000.begin(token.beginLine,token.beginColumn);

		String fieldAccessImage = token.image;
		String discriminator = null;
	 	if (fieldAccessImage.equals("$in.")) {
	 	  discriminator = "in"; // an input port is required
		} else if (fieldAccessImage.equals("$out.")) {
	 	  discriminator = "out"; // an output port is required
		}
		// store the information from the field access operator
	 	jjtn000.setDiscriminator(discriminator);
	}
	<RECORD_ACCESS_FIRST_PART>
	{
		// the first part may denote a record ID or a field ID (old syntax) 
		String firstPartImage = token.image;
	    String secondPartImage = null;
	}
	// 
	(
	  <RECORD_ACCESS_SECOND_PART>
	  {
	    // optionally, there may be the second part of the field access expression
	    secondPartImage = token.image.substring(1); // remove the '.' from the beginning
	  }
	)?/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
	 	jjtn000.end(token.endLine,token.endColumn);	
	 	// let's presume this is not a wildcard access
	 	jjtn000.setWildcard(false);
	 	
	 	if (secondPartImage != null) {
	 		try {
	 			Integer recNum = Integer.parseInt(firstPartImage);
	 			// set directly the position access 
	 			jjtn000.setRecordId(recNum);
	 		} catch (NumberFormatException e) {
	 			jjtn000.setRecordName(firstPartImage);
	 		}
	 		
			if (secondPartImage.equals("*")) {
				jjtn000.setWildcard(true);
			} else {
		 		try {
		 			Integer fieldNum = Integer.parseInt(secondPartImage);
		 			// set directly the position access
		 			jjtn000.setFieldId(fieldNum);
		 		} catch (NumberFormatException e) {
		 			// set the field name
		 			jjtn000.setFieldName(secondPartImage);
		 		}
			}
			
	 	} else if (discriminator == null) {
	 		// shortended syntax $1 or $fieldName -> treat as $0.1 or $0.fieldName
	 		jjtn000.setRecordId(0);
			try {
		 		Integer fieldNum = Integer.parseInt(firstPartImage);
		 		// set directly the position access
		 		jjtn000.setFieldId(fieldNum);
		 	} catch (NumberFormatException e) {
		 		// set the field name
		 		jjtn000.setFieldName(firstPartImage);
		 	}
	 	} else {
	 	    // new syntax, $in.1 no longer means $0.1, but $1.* instead
	 	    jjtn000.setWildcard(true);
	 		try {
	 			Integer recNum = Integer.parseInt(firstPartImage);
	 			// set directly the position access 
	 			jjtn000.setRecordId(recNum);
	 		} catch (NumberFormatException e) {
	 			jjtn000.setRecordName(firstPartImage);
	 		}
	 	}
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Identifier() :
{/*@bgen(jjtree) Identifier */
        CLVFIdentifier jjtn000 = new CLVFIdentifier(this, JJTIDENTIFIER);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	CLVFVariableDeclaration vd = null;
}
{/*@bgen(jjtree) Identifier */
        try {
/*@egen*/
	// the setName() method must be manually added to the generated AST node
	<IDENTIFIER>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
	{
		jjtn000.begin(token.beginLine,token.beginColumn); 
		jjtn000.end(token.endLine,token.endColumn);
		jjtn000.setName(token.image);
		vd = checkDeclaration(token.image,token.beginLine,token.beginColumn,token.endLine,token.endColumn);
		if (vd != null) {
			// declaration found, store reference and compute offset
			jjtn000.setVariable(vd);
			jjtn000.setBlockOffset(vd.getBlockOffset() == 0 ? -1 : getCurrentBlockOffset()-vd.getBlockOffset());
			jjtn000.setVariableOffset(vd.getVariableOffset());
		} 
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	
}

void Arguments(Node zeroArgument)           :
{/*@bgen(jjtree) Arguments */
  CLVFArguments jjtn000 = new CLVFArguments(this, JJTARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Arguments */
        try {
/*@egen*/
	"(" 
	{
		jjtn000.begin(token.beginLine,token.beginColumn);
		if (zeroArgument != null) {
			jjtree.pushNode(zeroArgument);
		} 
	}
		[ 
		 ( 
			ConditionalFailExpression()
		  	|
		  	TypeArgument()
		 )
		 ( 
		   ","
		  ( 
		   ConditionalFailExpression()
		   |
		   TypeArgument()
		  ) 
		 )* 
		]
	 ")"/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
         }
/*@egen*/
	 {
		jjtn000.end(token.endLine,token.endColumn);
	 }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void TypeArgument()      :
{}
{
	PrimitiveType()
	|
	DateField()
	|
	LogLevel()
}

void DateField() :
{/*@bgen(jjtree) DateField */
  CLVFDateField jjtn000 = new CLVFDateField(this, JJTDATEFIELD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DateField */
        try {
/*@egen*/
	( "year" | "month" | "week" | "day" | "hour" | "minute" | "second" | "millisec" )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.begin(token.beginLine,token.beginColumn); 
		jjtn000.end(token.endLine,token.endColumn); 
		jjtn000.setFieldType(token.kind);
		jjtn000.setType(TLType.createTypeSymbol(token.kind)); 
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void LogLevel() :
{/*@bgen(jjtree) LogLevel */
  CLVFLogLevel jjtn000 = new CLVFLogLevel(this, JJTLOGLEVEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LogLevel */
        try {
/*@egen*/
	( "debug" | "info" | "warn" | "error" | "fatal" | "trace")/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.begin(token.beginLine,token.beginColumn); 
		jjtn000.end(token.endLine,token.endColumn); 
		jjtn000.setLogLevel(token.kind);
		jjtn000.setType(TLType.createTypeSymbol(token.kind)); 
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/

}
void Literal()       :             {	Token t;
	SimpleNode s;}{ 	(
	 ( t=<FLOATING_POINT_LITERAL>/*@bgen(jjtree) Literal */
                {
                  CLVFLiteral jjtn001 = new CLVFLiteral(this, JJTLITERAL);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*//*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn001, true);
                  jjtc001 = false;
                }
/*@egen*/	
	 	{ 
	 		jjtn001.begin(t.beginLine,t.beginColumn);
	 		jjtn001.end(t.endLine,t.endColumn);
	 		jjtn001.setValue(FLOATING_POINT_LITERAL,t.image);
	 	}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                  }
                }
/*@egen*/ 
	 	         
	 ) 	|
 	 ( t=<LONG_LITERAL>/*@bgen(jjtree) Literal */
                {
                  CLVFLiteral jjtn002 = new CLVFLiteral(this, JJTLITERAL);
                  boolean jjtc002 = true;
                  jjtree.openNodeScope(jjtn002);
                }
                try {
/*@egen*//*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn002, true);
                  jjtc002 = false;
                }
/*@egen*/  		
 	 	{ 
			jjtn002.begin(t.beginLine,t.beginColumn);
	 		jjtn002.end(t.endLine,t.endColumn);
 	 		jjtn002.setValue(LONG_LITERAL,t.image);
 	 	}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc002) {
                    jjtree.closeNodeScope(jjtn002, true);
                  }
                }
/*@egen*/   
 	 	         
 	 ) 	|
 	 ( t=<INTEGER_LITERAL>/*@bgen(jjtree) Literal */
                {
                  CLVFLiteral jjtn003 = new CLVFLiteral(this, JJTLITERAL);
                  boolean jjtc003 = true;
                  jjtree.openNodeScope(jjtn003);
                }
                try {
/*@egen*//*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn003, true);
                  jjtc003 = false;
                }
/*@egen*/	  	
 	 	{
			jjtn003.begin(t.beginLine,t.beginColumn);
	 		jjtn003.end(t.endLine,t.endColumn);
 	 		jjtn003.setValue(INTEGER_LITERAL,t.image);
 	 	}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc003) {
                    jjtree.closeNodeScope(jjtn003, true);
                  }
                }
/*@egen*/   
 	 	         
 	 ) 	|
 	 ( t=<STRING_LITERAL>/*@bgen(jjtree) Literal */
                {
                  CLVFLiteral jjtn004 = new CLVFLiteral(this, JJTLITERAL);
                  boolean jjtc004 = true;
                  jjtree.openNodeScope(jjtn004);
                }
                try {
/*@egen*//*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn004, true);
                  jjtc004 = false;
                }
/*@egen*/
 	 	{ 
			jjtn004.begin(t.beginLine,t.beginColumn);
	 		jjtn004.end(t.endLine,t.endColumn);
	 		try { 				jjtn004.setValue(STRING_LITERAL,StringUtils.stringToSpecCharStrict(unquote(t.image)));	 		} catch (IllegalArgumentException iae) {
	 		  	error(jjtn004, iae.getMessage());
	 		}
 	 	}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc004) {
                    jjtree.closeNodeScope(jjtn004, true);
                  }
                }
/*@egen*/   
 	 	         
 	 ) 	|
 	 ( t=<STRING_PLAIN_LITERAL>/*@bgen(jjtree) Literal */
                {
                  CLVFLiteral jjtn005 = new CLVFLiteral(this, JJTLITERAL);
                  boolean jjtc005 = true;
                  jjtree.openNodeScope(jjtn005);
                }
                try {
/*@egen*//*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn005, true);
                  jjtc005 = false;
                }
/*@egen*/	
 	 	{ 
			jjtn005.begin(t.beginLine,t.beginColumn);
	 		jjtn005.end(t.endLine,t.endColumn);
  			jjtn005.setValue(STRING_LITERAL,t.image);
 	 	}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc005) {
                    jjtree.closeNodeScope(jjtn005, true);
                  }
                }
/*@egen*/   
 	 	         
 	 ) 	|
 	 ( t=<BOOLEAN_LITERAL>/*@bgen(jjtree) Literal */
                 {
                   CLVFLiteral jjtn006 = new CLVFLiteral(this, JJTLITERAL);
                   boolean jjtc006 = true;
                   jjtree.openNodeScope(jjtn006);
                 }
                 try {
/*@egen*//*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn006, true);
                   jjtc006 = false;
                 }
/*@egen*/
 	 	 { 
			jjtn006.begin(t.beginLine,t.beginColumn);
	 		jjtn006.end(t.endLine,t.endColumn);
 	 		jjtn006.setValue(BOOLEAN_LITERAL,t.image);
 	 	 }/*@bgen(jjtree)*/
                 } finally {
                   if (jjtc006) {
                     jjtree.closeNodeScope(jjtn006, true);
                   }
                 }
/*@egen*/   
 	 	         
 	 ) 	|
 	 ( t=<DATE_LITERAL>/*@bgen(jjtree) Literal */
                {
                  CLVFLiteral jjtn007 = new CLVFLiteral(this, JJTLITERAL);
                  boolean jjtc007 = true;
                  jjtree.openNodeScope(jjtn007);
                }
                try {
/*@egen*//*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn007, true);
                  jjtc007 = false;
                }
/*@egen*/
 	 	{
 			jjtn007.begin(t.beginLine,t.beginColumn);
	 		jjtn007.end(t.endLine,t.endColumn);
  			jjtn007.setValue(DATE_LITERAL,t.image);
 	  	}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc007) {
                    jjtree.closeNodeScope(jjtn007, true);
                  }
                }
/*@egen*/   
 	  	         
 	 ) 	|
 	 ( t=<DATETIME_LITERAL>/*@bgen(jjtree) Literal */
                {
                  CLVFLiteral jjtn008 = new CLVFLiteral(this, JJTLITERAL);
                  boolean jjtc008 = true;
                  jjtree.openNodeScope(jjtn008);
                }
                try {
/*@egen*//*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn008, true);
                  jjtc008 = false;
                }
/*@egen*/
 	   	{
 	   		jjtn008.begin(t.beginLine,t.beginColumn);
	 		jjtn008.end(t.endLine,t.endColumn); 
   			jjtn008.setValue(DATETIME_LITERAL,t.image);
 	   	}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc008) {
                    jjtree.closeNodeScope(jjtn008, true);
                  }
                }
/*@egen*/   
 	   	         
 	 ) 	|
 	 ( t=<NULL_LITERAL>/*@bgen(jjtree) Literal */
                {
                  CLVFLiteral jjtn009 = new CLVFLiteral(this, JJTLITERAL);
                  boolean jjtc009 = true;
                  jjtree.openNodeScope(jjtn009);
                }
                try {
/*@egen*//*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn009, true);
                  jjtc009 = false;
                }
/*@egen*/
 	  	{
 	  		jjtn009.begin(t.beginLine,t.beginColumn);
	 		jjtn009.end(t.endLine,t.endColumn); 
  			jjtn009.setValue(NULL_LITERAL,t.image);
 	  	}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc009) {
                    jjtree.closeNodeScope(jjtn009, true);
                  }
                }
/*@egen*/ 
 	  	         
 	  ) 	|
 	 ( ListOfLiterals() )			
  )
   }void ListOfLiterals() :{/*@bgen(jjtree) ListOfLiterals */
  CLVFListOfLiterals jjtn000 = new CLVFListOfLiterals(this, JJTLISTOFLITERALS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) ListOfLiterals */
        try {
/*@egen*/
	"[" 
	{
		jjtn000.begin(token.beginLine,token.beginColumn); 
	}
		// list literals must not be empty in order to have type
		Expression() ( "," Expression() )*  
	"]"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/	
	{
		jjtn000.end(token.endLine,token.endColumn);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}/* * Statements */void Statement()       :{}{	try {			(
		  EmptyStatement() 
		|		  IfStatement()		|		  SwitchStatement()		|		  WhileStatement()		|		  ForStatement()		| 		  ForeachStatement()		|		  DoStatement() 		|		   BreakStatement() ";"		|		   ContinueStatement() ";"		|		   ReturnStatement() ";"		| 		  StatementExpression() ";"
		
		)
	} catch (ParseException e) {
		recover(SEMICOLON);
	}
		}void Block() :{/*@bgen(jjtree) Block */
  CLVFBlock jjtn000 = new CLVFBlock(this, JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Block */
  try {
/*@egen*/
  try {
  "{"
  	{
  		jjtn000.begin(token.beginLine,token.beginColumn); 
  	}
  	Statements()
  "}"
  	{
		jjtn000.end(token.endLine,token.endColumn);
  	}
  } catch (ParseException e) {
  	recover(BLOCK_END);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void EmptyStatement()       :
{}
{
	";"
}
void StatementExpression()       :{}{	/*
	 * Both expressions below can derive into degenerated form and must be checked
	 * in semantic/AST cleanup pass
	 * Legal expressions are: assignment, pre/postfix operation, function call
	 */
	Expression() 
	} void IfStatement() :/* * The disambiguating algorithm of JavaCC automatically binds dangling * else's to the innermost if statement.  The LOOKAHEAD specification * is to tell JavaCC that we know what we are doing. */{/*@bgen(jjtree) IfStatement */
  CLVFIfStatement jjtn000 = new CLVFIfStatement(this, JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) IfStatement */
  try {
/*@egen*/  <IF>
  {
  		jjtn000.begin(token.beginLine,token.beginColumn);
  } 
  "(" Expression() ")" 
  {
  		jjtn000.setThenScope(enteredBlock());
  }
  StatementOrBlock() 
  {
  		exitedBlock();
  }
  [ 
  	LOOKAHEAD(2) <ELSE>
  	{
  		jjtn000.setElseScope(enteredBlock());
  	} 
  	StatementOrBlock() 
  	{
  		exitedBlock();
  	}
  ]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}
//TODO: if there are no case statements and expression does not have side effects we can ignore whole switch statementvoid SwitchStatement() :{/*@bgen(jjtree) SwitchStatement */
        CLVFSwitchStatement jjtn000 = new CLVFSwitchStatement(this, JJTSWITCHSTATEMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}{/*@bgen(jjtree) SwitchStatement */
  try {
/*@egen*/  t = <SWITCH>
  {
  	jjtn000.setScope(enteredBlock());
  }
  "(" Expression() ")"  
  "{"
     ( 
     	CaseStatement(jjtn000)
		Statements()
     ) *  
  "}"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
	jjtn000.begin(t.beginLine,t.beginColumn);
	jjtn000.end(token.endLine,token.endColumn); 
  	if (jjtn000.jjtGetNumChildren() < 2) {
  		warn(t.beginLine,t.beginColumn,t.endLine,t.endColumn,"Switch statement has no 'case' sub-statements","Add 'case' statements or remove whole 'switch' statement");
  	}
	exitedBlock();
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
  
}void CaseStatement(CLVFSwitchStatement switchStatement) :{/*@bgen(jjtree) CaseStatement */
  CLVFCaseStatement jjtn000 = new CLVFCaseStatement(this, JJTCASESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) CaseStatement */
  try {
/*@egen*/  ( 
    "case" { jjtn000.begin(token.beginLine,token.beginColumn); }
    Literal() ":"/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/ 
    { jjtn000.end(token.endLine,token.endColumn); }
  )
  |
  (
  	"default" 
  	{
  		 jjtn000.begin(token.beginLine,token.beginColumn);
  		 jjtn000.setDefaultClause(true); 
  	} 
  	":"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/	
  	{
  		jjtn000.end(token.endLine,token.endColumn); 
  		if (switchStatement.hasDefaultClause()) {
  			error(jjtn000,"Default case is already defined");
  		}
  		switchStatement.setDefaultClause(true); 
  	}
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}
void Statements()       :
{} 
{
	( 
  		LOOKAHEAD(3)
		VariableDeclaration() ";"
		| 
  		Statement()
 		
  	)* 
}
void WhileStatement() :{/*@bgen(jjtree) WhileStatement */
  CLVFWhileStatement jjtn000 = new CLVFWhileStatement(this, JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) WhileStatement */
  try {
/*@egen*/  <WHILE>  
  {
  	jjtn000.begin(token.beginLine,token.beginColumn); 
	jjtn000.setScope(enteredBlock());
  } 
  "(" Expression() ")"
  StatementOrBlock()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
 	exitedBlock();
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

void ForInit()      :
{}
{
	LOOKAHEAD(2)
	VariableDeclaration()
	|
	Expression()
}
void ForStatement() :{/*@bgen(jjtree) ForStatement */
        CLVFForStatement jjtn000 = new CLVFForStatement(this, JJTFORSTATEMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	int i=0;
}{/*@bgen(jjtree) ForStatement */
  try {
/*@egen*/  <FOR> 
  { 
  	jjtn000.begin(token.beginLine,token.beginColumn);
  	jjtn000.setScope(enteredBlock());  
  } 
  "(" 
  	[ ForInit() { jjtn000.setInitPosition(i++); } ]  ";" 
  	[ Expression() { jjtn000.setFinalPosition(i++); } ] ";" 
  	[ Expression() { jjtn000.setUpdatePosition(i++); } ] 
  ")"
  StatementOrBlock()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
  	exitedBlock();
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}
void ForeachStatement() :{/*@bgen(jjtree) ForeachStatement */
  CLVFForeachStatement jjtn000 = new CLVFForeachStatement(this, JJTFOREACHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) ForeachStatement */
        try {
/*@egen*/
	<FOR_EACH> 
	{ 
		jjtn000.begin(token.beginLine,token.beginColumn);
		jjtn000.setScope(enteredBlock());  
	} 
	// java requires there is variable declaration on LHS (NOT a variable reference)
	"(" VariableDeclaration() ":" Expression() ")" 
	StatementOrBlock()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		exitedBlock();
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/}

void DoStatement()                 :{/*@bgen(jjtree) #DoStatement( 2) */
  CLVFDoStatement jjtn000 = new CLVFDoStatement(this, JJTDOSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) #DoStatement( 2) */
  try {
/*@egen*/  <DO> 
  { 
  	jjtn000.begin(token.beginLine,token.beginColumn);
  	jjtn000.setScope(enteredBlock());  
  } 
   StatementOrBlock()
   <WHILE> "(" Expression() ")"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000,  2);
    jjtc000 = false;
  }
/*@egen*/   { 
  	// must exit block only here, as the expression is still part of loop scope!
  	exitedBlock();
  	jjtn000.end(token.endLine,token.endColumn); 
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  2);
    }
  }
/*@egen*/
}
////void TryCatchStatement() ://{}//{//  <TRY> Statement() <CATCH> "(" VarExp() ")" Statement()//}//////void BreakStatement() :{/*@bgen(jjtree) BreakStatement */
  CLVFBreakStatement jjtn000 = new CLVFBreakStatement(this, JJTBREAKSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) BreakStatement */
        try {
/*@egen*/	<BREAK>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
	{
		jjtn000.begin(token.beginLine,token.beginColumn);
		jjtn000.end(token.endLine,token.endColumn); 
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/}void ContinueStatement() :{/*@bgen(jjtree) ContinueStatement */
  CLVFContinueStatement jjtn000 = new CLVFContinueStatement(this, JJTCONTINUESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) ContinueStatement */
        try {
/*@egen*/	<CONTINUE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.begin(token.beginLine,token.beginColumn);
		jjtn000.end(token.endLine,token.endColumn); 
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/}
void ReturnStatement() : {/*@bgen(jjtree) ReturnStatement */
  CLVFReturnStatement jjtn000 = new CLVFReturnStatement(this, JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) ReturnStatement */
    try {
/*@egen*/    <RETURN> { jjtn000.begin(token.beginLine,token.beginColumn); }
    [ 
    	Expression() 
    	|
    	ControlConstant()
    ]/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { jjtn000.end(token.endLine,token.endColumn); }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/}
void ControlConstant()          : {/*@bgen(jjtree) Literal */
  CLVFLiteral jjtn000 = new CLVFLiteral(this, JJTLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Literal */
        try {
/*@egen*/
	{ jjtn000.begin(token.beginLine,token.beginColumn); }
	(
	"OK" { jjtn000.setType(TLTypePrimitive.INTEGER); jjtn000.setValueDirect(RecordTransform.OK); }
	|
	"SKIP" { jjtn000.setType(TLTypePrimitive.INTEGER); jjtn000.setValueDirect(RecordTransform.SKIP); }
	|
	"ALL" { jjtn000.setType(TLTypePrimitive.INTEGER); jjtn000.setValueDirect(RecordTransform.ALL); }
	|
	"STOP" { jjtn000.setType(TLTypePrimitive.INTEGER); jjtn000.setValueDirect(RecordTransform.STOP); }
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.end(token.endLine, token.endColumn); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
	
//void EvalNode() ://{}//{//   "eval(" AdditiveExpression() ["," AdditiveExpression() ] ")" { hasEvalNode=true;  jjtThis.setExpMode(false); }//   | "eval_exp(" AdditiveExpression() ")" { jjtThis.setExpMode(true); }//}void SequenceNode() :{/*@bgen(jjtree) SequenceNode */
        CLVFSequenceNode jjtn000 = new CLVFSequenceNode(this, JJTSEQUENCENODE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/	Token t;}{/*@bgen(jjtree) SequenceNode */
        try {
/*@egen*/	"sequence"
	{
		jjtn000.begin(token.beginLine,token.beginColumn);
	} 
	"(" 		t=<IDENTIFIER> 
		{ 
			jjtn000.setSequenceName(t.image);
			jjtn000.setType(TLTypePrimitive.INTEGER); 
		} 	[ ","	  (  
	  	<INT_VAR> { jjtn000.setType(TLTypePrimitive.INTEGER); }	   |
	    <LONG_VAR> {  jjtn000.setType(TLTypePrimitive.LONG); }	   | 
	    <STRING_VAR> { jjtn000.setType(TLTypePrimitive.STRING); }	  ) 
	]	")"
	"." FunctionCall(null)
	{
		jjtn000.end(token.endLine,token.endColumn);
	}/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
         }
/*@egen*/
	 {
	   		CLVFFunctionCall opFunc = (CLVFFunctionCall)jjtn000.jjtGetChild(0);
	   		jjtn000.removeChild(0);
	   		if (opFunc.jjtGetChild(0).jjtGetNumChildren() > 0) {
	   			error(opFunc,"Function '" + opFunc.getName() + "' does not accept any arguments");
	   		}
	   		if ("next".equals(opFunc.getName())) {
	   			jjtn000.setOperation(CLVFSequenceNode.OP_NEXT);
	   		} else if ("current".equals(opFunc.getName())) {
				jjtn000.setOperation(CLVFSequenceNode.OP_CURRENT);
			} else if ("reset".equals(opFunc.getName())) {
				jjtn000.setOperation(CLVFSequenceNode.OP_RESET);
			} else {
	   			error(opFunc,"Illegal sequence manipulator '" + opFunc.getName() + "()'",
	   						"Use one of next(), current() or reset()");
	   		}
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	
}

void LookupNode() :{/*@bgen(jjtree) LookupNode */
  CLVFLookupNode jjtn000 = new CLVFLookupNode(this, JJTLOOKUPNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) LookupNode */
        try {
/*@egen*/	(	 ( "lookup" 
	   {
	   		jjtn000.begin(token.beginLine,token.beginColumn);
	   }
	   "("			<IDENTIFIER> 
			{ 
				jjtn000.setLookupName(token.image); 
			}	   ")"
	   {
	   		jjtn000.end(token.endLine,token.endColumn);
	   }
	   
	   "." FunctionCall(null)/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ 
	   {
	   		CLVFFunctionCall opFunc = (CLVFFunctionCall)jjtn000.jjtGetChild(0);
	   		jjtn000.removeChild(0); // get rid of the manipulator function
	   		if ("get".equals(opFunc.getName())) {
	   			jjtn000.setOperation(CLVFLookupNode.OP_GET);
	   		} else if ("next".equals(opFunc.getName())) {
				jjtn000.setOperation(CLVFLookupNode.OP_NEXT);
			} else if ("count".equals(opFunc.getName())) {
				jjtn000.setOperation(CLVFLookupNode.OP_COUNT);
			} else if ("put".equals(opFunc.getName())) {
				jjtn000.setOperation(CLVFLookupNode.OP_PUT);
			} else {
	   			error(opFunc,"Illegal lookup manipulator","Use one of get(), next(), init(), free() or count()");
	   		}
			CLVFArguments params = (CLVFArguments)opFunc.jjtGetChild(0);
			jjtn000.jjtAddChild(params,0);
			jjtn000.end(params.getEnd().getLine(),params.getEnd().getColumn());
	   }		 ) 	|  // multi-match
	 ( "lookup_next"
	   {
	   		jjtn000.begin(token.beginLine,token.beginColumn);
	   }
	   "("
			<IDENTIFIER> 			{ 
				jjtn000.setOperation(1); 
				jjtn000.setLookupName(token.image); 
			}
	   ")"/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ 	 	{
	   		jjtn000.end(token.endLine,token.endColumn);
			error(jjtn000,"Obsolete lookup syntax","Use 'lookup(<LookupName>).next().field' instead");
	    }	 ) 	|
	 (  // match count		"lookup_found"
		{
	   		jjtn000.begin(token.beginLine,token.beginColumn);
	   	}
		"("
			<IDENTIFIER> 			{
				jjtn000.setOperation(2); 
				jjtn000.setLookupName(token.image); 
			}
		")"/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/		{
	   		jjtn000.end(token.endLine,token.endColumn);
	   		warn(jjtn000,"Obsolete lookup syntax","Use 'lookup(<lookupName>).count()' instead");
	    }	 ) 	|
	 (  // lookup state management		"lookup_admin" 
		{
	   		jjtn000.begin(token.beginLine,token.beginColumn);
	   	}
		"("
			<IDENTIFIER> 			{ 
				jjtn000.setLookupName(token.image); 
			} 
			","	<IDENTIFIER> 
			{ 
				if (token.image.equalsIgnoreCase("init")) {
					jjtn000.setOperation(3); 
				} else if (token.image.equalsIgnoreCase("free")) {
					jjtn000.setOperation(4); 
				} else {
					error(token,
					"Invalid lookup operation identifier - '" + token.image +  "'",
					"Replace with one of 'init' or 'free'");
				}
			} 
		")"/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/		{
	   		jjtn000.end(token.endLine,token.endColumn);
	   		error(jjtn000,"Obsolete lookup syntax","Use 'lookup(<lookupName>).init()' or 'lookup(<lookupName>).free()' instead");
	    }
	 )	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/}

void DictionaryNode() :
{/*@bgen(jjtree) DictionaryNode */
  CLVFDictionaryNode jjtn000 = new CLVFDictionaryNode(this, JJTDICTIONARYNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DictionaryNode */
        try {
/*@egen*/
	(
	 ( <DICTIONARY>/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ 
	   {
	   		jjtn000.begin(token.beginLine,token.beginColumn);
	   		jjtn000.end(token.endLine,token.endColumn);
	   }
	   
	   /* . and identifier is parsed in PrimaryExpression
	   "."
			<IDENTIFIER> 
			{ 
				jjtThis.setKeyName(token.image); 
			}
	   {
	   		jjtThis.end(token.endLine,token.endColumn);
	   }
	   */
	 )
	)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

JAVACODEvoid recover(int kind)       {	Token t;	do {		t = getNextToken();
		if (t.kind == EOF) {
			break;
		}	} while (t.kind != kind);}

JAVACODE
void unknownToken()       {
	Token t;
	
	t = getNextToken();

	if (t.kind != EOF) {
		error(t,"Syntax error on token '" + t.image + "'","Delete this token");
	} else {
		// this stops processing in case we reach EOF
		throw new EndOfFileException();
	}
}


/* error token which is generated by lexer if it can't match with any other */
<WithinFieldIdentifier, DEFAULT>
TOKEN:
{
   <ERROR: ~[] > : DEFAULT
}