/* Generated By:JJTree: Do not edit this line. CLVFLiteral.java */

package org.jetel.interpreter.ASTnode;
import org.jetel.interpreter.ExpParser;
import org.jetel.interpreter.Stack;
import org.jetel.interpreter.TransformLangParserConstants;
import org.jetel.interpreter.TransformLangParserVisitor;

import java.math.BigDecimal;
import java.text.DateFormat;
import java.text.SimpleDateFormat;

import org.jetel.data.Defaults;
import org.jetel.data.primitive.CloverDouble;
import org.jetel.data.primitive.CloverInteger;
import org.jetel.data.primitive.CloverLong;
import org.jetel.data.primitive.DecimalFactory;
import org.jetel.data.primitive.HugeDecimal;
import org.jetel.interpreter.TransformLangExecutorRuntimeException;
import org.jetel.interpreter.data.TLValue;
import org.jetel.interpreter.data.TLValueType;

public class CLVFLiteral extends SimpleNode implements TransformLangParserConstants {
	
    public static final String DECIMAL_DISTINCTER_LOWERCASE="d";
    public static final String DECIMAL_DISTINCTER_UPPERCASE="D";
    public static final String LONG_DISTINCTER_LOWERCASE="l";
    public static final String LONG_DISTINCTER_UPPERCASE="L";
    
    private static DateFormat dateFormat=new SimpleDateFormat(Defaults.DEFAULT_DATE_FORMAT);
    private static DateFormat dateTimeFormat=new SimpleDateFormat(Defaults.DEFAULT_DATETIME_FORMAT);
    
	String valueImage; 
    public Object value;
    public TLValue valueTL;
	int literalType;
	
	public CLVFLiteral(int id) {
		super(id);
	}
	
	public CLVFLiteral(ExpParser p, int id) {
	    super(p, id);
	  }
	
	/** Accept the visitor. **/
	public Object jjtAccept(TransformLangParserVisitor visitor, Object data) {
		return visitor.visit(this, data);
	}
	
	public void init() throws org.jetel.interpreter.TransformLangExecutorRuntimeException {
		try{
			switch(literalType){
			case FLOATING_POINT_LITERAL:
                if (valueImage.endsWith(DECIMAL_DISTINCTER_LOWERCASE) || 
                        valueImage.endsWith(DECIMAL_DISTINCTER_UPPERCASE)){
                    value=DecimalFactory.getDecimal(valueImage.substring(0,valueImage.length()-1));
                    valueTL=new TLValue(TLValueType.DECIMAL,value);
                }else{
                    value= new CloverDouble( Double.parseDouble(valueImage));
                    valueTL=new TLValue(TLValueType.DOUBLE,value);
                }
				break;
			case STRING_LITERAL:
				value=valueImage;
                 valueTL=new TLValue(TLValueType.STRING,value);
				break;
			case INTEGER_LITERAL:
                // determine size of Integere literal
                if (valueImage.endsWith(LONG_DISTINCTER_UPPERCASE) || 
                        valueImage.endsWith(LONG_DISTINCTER_LOWERCASE)) {
                    value = new CloverLong(Long.parseLong(valueImage.substring(0,valueImage.length()-1)));
                    valueTL=new TLValue(TLValueType.LONG,value);
                } else {
                    // try to parse as INT first, if error then LONG
                    try {
                        value = new CloverInteger(Integer.parseInt(valueImage));
                        valueTL=new TLValue(TLValueType.INTEGER,value);
                    } catch (NumberFormatException ex) {
                        value = new CloverLong(Long.parseLong(valueImage));
                        valueTL=new TLValue(TLValueType.LONG,value);
                    }
                }
				break;
            case HEX_LITERAL:
                // try to parse as INT first, if error then LONG
                try{
                    value= new CloverInteger(  Integer.parseInt(valueImage.substring(2),16));
                    valueTL=new TLValue(TLValueType.INTEGER,value);
                }catch(NumberFormatException ex){
                    value= new CloverLong( Long.parseLong(valueImage.substring(2),16));
                    valueTL=new TLValue(TLValueType.LONG,value);
                }
            break;
            case OCTAL_LITERAL:
                // try to parse as INT first, if error then LONG
                try{
                    value= new CloverInteger(  Integer.parseInt(valueImage.substring(1),8));
                    valueTL=new TLValue(TLValueType.INTEGER,value);
                }catch(NumberFormatException ex){
                    value= new CloverLong( Long.parseLong(valueImage.substring(1),8));
                    valueTL=new TLValue(TLValueType.LONG,value);
                }
            break; 
			case DATE_LITERAL:
				//DateFormat dateFormat=new SimpleDateFormat(Defaults.DEFAULT_DATE_FORMAT);
				value=dateFormat.parse(valueImage); 
                 valueTL=new TLValue(TLValueType.DATE,value);
				break;
			case DATETIME_LITERAL:
				//DateFormat dateFormat2=new SimpleDateFormat(Defaults.DEFAULT_DATETIME_FORMAT);
				value=dateTimeFormat.parse(valueImage);
                 valueTL=new TLValue(TLValueType.DATE,value);
				break;
			case BOOLEAN_LITERAL:
                 valueTL=Boolean.parseBoolean(valueImage) ? Stack.TRUE_VAL : Stack.FALSE_VAL;
				break;
            case NULL_LITERAL:
                valueTL=Stack.NULL_VAL;
                break;
			default:
				throw new TransformLangExecutorRuntimeException(this,new Object[0],"Can't handle datatype "
						+tokenImage[literalType]);
			}
		}catch(java.text.ParseException ex){
		    throw new TransformLangExecutorRuntimeException(this,new Object[0],"Parser exception ["+tokenImage[literalType]+"] : Unrecognized value: "+valueImage);
        }catch(NumberFormatException ex){
            throw new TransformLangExecutorRuntimeException(this,new Object[0],"Number format error ["+tokenImage[literalType]+"] : Unrecognized value: "+valueImage);
		}catch(Exception ex){
		    throw new TransformLangExecutorRuntimeException(this,new Object[0],ex.getClass().getName()+" : ["+tokenImage[literalType]+"] : Unrecognized value: "+valueImage);
		}
	}
	
	public void setVal(int literalType, String valueImage){
		this.valueImage=valueImage;
		this.literalType=literalType;
        init();
	}
}
