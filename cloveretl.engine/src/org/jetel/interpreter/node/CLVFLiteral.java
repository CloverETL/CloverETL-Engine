/* Generated By:JJTree: Do not edit this line. CLVFLiteral.java */

package org.jetel.interpreter.node;
import org.jetel.interpreter.ExpParser;
import org.jetel.interpreter.TransformLangParserConstants;
import org.jetel.interpreter.TransformLangParserVisitor;

import java.math.BigDecimal;
import java.text.DateFormat;
import java.text.SimpleDateFormat;

import org.jetel.data.Defaults;
import org.jetel.data.primitive.CloverDouble;
import org.jetel.data.primitive.CloverInteger;
import org.jetel.data.primitive.CloverLong;
import org.jetel.data.primitive.HugeDecimal;
import org.jetel.interpreter.TransformLangExecutorRuntimeException;

public class CLVFLiteral extends SimpleNode implements TransformLangParserConstants {
	
    public static final String DECIMAL_DISTINCTER_LOWERCASE="d";
    public static final String DECIMAL_DISTINCTER_UPPERCASE="D";
    public static final String LONG_DISTINCTER_LOWERCASE="l";
    public static final String LONG_DISTINCTER_UPPERCASE="L";
    
    private static DateFormat dateFormat=new SimpleDateFormat(Defaults.DEFAULT_DATE_FORMAT);
    private static DateFormat dateTimeFormat=new SimpleDateFormat(Defaults.DEFAULT_DATETIME_FORMAT);
    
	String valueImage; 
    public Object value;
	int literalType;
	
	public CLVFLiteral(int id) {
		super(id);
	}
	
	public CLVFLiteral(ExpParser p, int id) {
	    super(p, id);
	  }
	
	/** Accept the visitor. **/
	public Object jjtAccept(TransformLangParserVisitor visitor, Object data) {
		return visitor.visit(this, data);
	}
	
	public void init() throws org.jetel.interpreter.TransformLangExecutorRuntimeException {
		try{
			switch(literalType){
			case FLOATING_POINT_LITERAL:
                if (valueImage.endsWith(DECIMAL_DISTINCTER_LOWERCASE) || 
                        valueImage.endsWith(DECIMAL_DISTINCTER_UPPERCASE)){
                    value=new BigDecimal(valueImage.substring(0,valueImage.length()-1));
                }else{
                    value= new CloverDouble( Double.parseDouble(valueImage));
                }
				break;
			case STRING_LITERAL:
				value=valueImage;
				break;
			case INTEGER_LITERAL:
                // determine size of Integere literal
                if (valueImage.endsWith(LONG_DISTINCTER_UPPERCASE) || 
                        valueImage.endsWith(LONG_DISTINCTER_LOWERCASE)) {
                    value = new CloverLong(Long.parseLong(valueImage.substring(0,valueImage.length()-1)));
                } else {
                    // try to parse as INT first, if error then LONG
                    try {
                        value = new CloverInteger(Integer.parseInt(valueImage));
                    } catch (NumberFormatException ex) {
                        value = new CloverLong(Long.parseLong(valueImage));
                    }
                }
				break;
            case HEX_LITERAL:
                // try to parse as INT first, if error then LONG
                try{
                    value= new CloverInteger(  Integer.parseInt(valueImage.substring(2),16));
                }catch(NumberFormatException ex){
                    value= new CloverLong( Long.parseLong(valueImage.substring(2),16));
                }
            break;
            case OCTAL_LITERAL:
                // try to parse as INT first, if error then LONG
                try{
                    value= new CloverInteger(  Integer.parseInt(valueImage.substring(1),8));
                }catch(NumberFormatException ex){
                    value= new CloverLong( Long.parseLong(valueImage.substring(1),8));
                }
            break; 
			case DATE_LITERAL:
				//DateFormat dateFormat=new SimpleDateFormat(Defaults.DEFAULT_DATE_FORMAT);
				value=dateFormat.parse(valueImage); 
				break;
			case DATETIME_LITERAL:
				//DateFormat dateFormat2=new SimpleDateFormat(Defaults.DEFAULT_DATETIME_FORMAT);
				value=dateTimeFormat.parse(valueImage); 		
				break;
			case BOOLEAN_LITERAL:
				value= Boolean.valueOf(valueImage);
				break;
            case NULL_LITERAL:
                value= null;
                break;
			default:
				throw new TransformLangExecutorRuntimeException(this,new Object[0],"Can't handle datatype "
						+tokenImage[literalType]);
			}
		}catch(java.text.ParseException ex){
		    throw new TransformLangExecutorRuntimeException(this,new Object[0],"Parser exception ["+tokenImage[literalType]+"] : Unrecognized value: "+valueImage);
        }catch(NumberFormatException ex){
            throw new TransformLangExecutorRuntimeException(this,new Object[0],"Number format error ["+tokenImage[literalType]+"] : Unrecognized value: "+valueImage);
		}catch(Exception ex){
		    throw new TransformLangExecutorRuntimeException(this,new Object[0],ex.getClass().getName()+" : ["+tokenImage[literalType]+"] : Unrecognized value: "+valueImage);
		}
	}
	
	public void setVal(int literalType, String valueImage){
		this.valueImage=valueImage;
		this.literalType=literalType;
        init();
	}
}
