/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. FilterExpParser.jj */
/*@egen*//*
    Clover.ETL - filtering conditions grammar.
    (c) 2004 David.Pavlis <david_pavlis@hotmail.com>
    Released under LGPL license.
*/

options {                
   STATIC=false;                           
   LOOKAHEAD=2;                                                                  
}


/* *** Specifcation of the parser class *** */

PARSER_BEGIN(FilterExpParser)

package org.jetel.interpreter;

import org.jetel.data.DataRecord;

public class FilterExpParser/*@bgen(jjtree)*/implements FilterExpParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTFilterExpParserState jjtree = new JJTFilterExpParserState();

/*@egen*/

       DataRecord dataRecord;
       Stack stack;

       public FilterExpParser(DataRecord record,java.io.InputStream stream){
              this(stream);
              dataRecord=record;
              stack=new Stack();
              
      }
      
      public Stack getStack(){
         return stack;
      }
      
      public DataRecord getDataRecord(){
             return dataRecord;
      }
}

PARSER_END(FilterExpParser)

/* *** Token specification *** */

/* Skip whitespace */
SKIP : { " " | "\t" | "\n" | "\r" | "\n\r" }

/* Logical operators */
TOKEN [IGNORE_CASE]: {
  < OR: "or" | "||" >
| < AND: "and" | "&&" >
| < NOT: "not" | "!" >
}

/* Literals */
TOKEN : {
 <INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])? | <HEX_LITERAL> (["l","L"])? | <OCTAL_LITERAL> (["l","L"])?>
|  <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])*>
|  <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+>
|  <#OCTAL_LITERAL: "0" (["0"-"7"])*>
|  <FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])? | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]>
|  <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>
|  <CHARACTER_LITERAL: "\'" (~["\'","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"])) "\'">
|  <STRING_LITERAL: "\"" (~["\"","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"]))* "\"">
}

/* Array of literals */
TOKEN: {
 <STRING_ARRAY: "[" <STRING_LITERAL> ( "," <STRING_LITERAL>)* "]">
|<INTEGER_ARRAY: "[" <INTEGER_LITERAL> ( "," <INTEGER_LITERAL>)* "]">
|<FLOATING_POINT_ARRAY: "[" <FLOATING_POINT_LITERAL> ( "," <FLOATING_POINT_LITERAL>)* "]">
}

/* Operators */
TOKEN: {
  < EQUAL: "==" >
| < NON_EQUAL: "!=" | "<>" >
| < LESS_THAN: "<" >
| < LESS_THAN_EQUAL: "<=" >
| < GREATER_THAN: ">" >
| < GREATER_THAN_EQUAL: ">=" >
| < REGEX_EQUAL: "~=" >
}

TOKEN: {
<#OPERATOR : <EQUAL> | <NON_EQUAL> | <LESS_THAN> | <LESS_THAN_EQUAL> | <GREATER_THAN>
| <GREATER_THAN_EQUAL> | <REGEX_EQUAL> >
}

/* Field Identifiers */
TOKEN: {
  < FIELD_ID: "$"(["A"-"Z", "a"-"z"])(["A"-"Z", "a"-"z", "_","0"-"9"])+ >
}

/* Parenthesis */
TOKEN: {
  <OPEN_PAR: "("> |
  <CLOSE_PAR: ")">
}

/* *** Context-free grammar (EBNF) *** */

/* Each nonterminal is written like a kind of method, containing all its
   productions. JavaC will generate a parsing method for each nonterminal.

   Note: In the start nonterminal, the action "return jjtThis;" instructs
   JavaCC to return the resulting parse tree from the generated parsing
   method. Therefore the start nonterminal has a result type (SimpleNode).
   All other nonterminals have no result type (void).
*/

/* The start nonterminal and its productions. */

SimpleNode Start() : {/*@bgen(jjtree) Start */
  CLVFStart jjtn000 = new CLVFStart(this, JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}        // Start -> Exp
{/*@bgen(jjtree) Start */
  try {
/*@egen*/
  LExpression() <EOF>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/* Other nonterminals and their productions */

void LExpression()       : {}        // Exp -> XFactor [XFactor]
{
   LPrimaryExpression()
   ( <OR>/*@bgen(jjtree) #Or( 2) */
          {
            CLVFOr jjtn001 = new CLVFOr(this, JJTOR);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
          }
          try {
/*@egen*/ LPrimaryExpression()/*@bgen(jjtree)*/
          } catch (Throwable jjte001) {
            if (jjtc001) {
              jjtree.clearNodeScope(jjtn001);
              jjtc001 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte001 instanceof RuntimeException) {
              throw (RuntimeException)jjte001;
            }
            if (jjte001 instanceof ParseException) {
              throw (ParseException)jjte001;
            }
            throw (Error)jjte001;
          } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  2);
            }
          }
/*@egen*/ )*
}

void LPrimaryExpression()       : {}
{
   Condition()
   ( <AND>/*@bgen(jjtree) #And( 2) */
           {
             CLVFAnd jjtn001 = new CLVFAnd(this, JJTAND);
             boolean jjtc001 = true;
             jjtree.openNodeScope(jjtn001);
           }
           try {
/*@egen*/ Condition()/*@bgen(jjtree)*/
           } catch (Throwable jjte001) {
             if (jjtc001) {
               jjtree.clearNodeScope(jjtn001);
               jjtc001 = false;
             } else {
               jjtree.popNode();
             }
             if (jjte001 instanceof RuntimeException) {
               throw (RuntimeException)jjte001;
             }
             if (jjte001 instanceof ParseException) {
               throw (ParseException)jjte001;
             }
             throw (Error)jjte001;
           } finally {
             if (jjtc001) {
               jjtree.closeNodeScope(jjtn001,  2);
             }
           }
/*@egen*/ ) *
}


void Condition()       : {}
{
     <NOT>/*@bgen(jjtree) Negation */
           {
             CLVFNegation jjtn001 = new CLVFNegation(this, JJTNEGATION);
             boolean jjtc001 = true;
             jjtree.openNodeScope(jjtn001);
           }
           try {
/*@egen*/ PrimaryCondition()/*@bgen(jjtree)*/
           } catch (Throwable jjte001) {
             if (jjtc001) {
               jjtree.clearNodeScope(jjtn001);
               jjtc001 = false;
             } else {
               jjtree.popNode();
             }
             if (jjte001 instanceof RuntimeException) {
               throw (RuntimeException)jjte001;
             }
             if (jjte001 instanceof ParseException) {
               throw (ParseException)jjte001;
             }
             throw (Error)jjte001;
           } finally {
             if (jjtc001) {
               jjtree.closeNodeScope(jjtn001, true);
             }
           }
/*@egen*/
     | PrimaryCondition()
}

void PrimaryCondition()       : {}
{
  IDExp() <EQUAL> Literal()/*@bgen(jjtree) #Comparison( 2) */
                             {
                               CLVFComparison jjtn001 = new CLVFComparison(this, JJTCOMPARISON);
                               boolean jjtc001 = true;
                               jjtree.openNodeScope(jjtn001);
                             }
                             try {
/*@egen*//*@bgen(jjtree)*/
                             {
                               jjtree.closeNodeScope(jjtn001,  2);
                               jjtc001 = false;
                             }
/*@egen*/  { jjtn001.cmpType=EQUAL; }/*@bgen(jjtree)*/
                             } finally {
                               if (jjtc001) {
                                 jjtree.closeNodeScope(jjtn001,  2);
                               }
                             }
/*@egen*/
  |IDExp() <NON_EQUAL> Literal()/*@bgen(jjtree) #Comparison( 2) */
                                 {
                                   CLVFComparison jjtn002 = new CLVFComparison(this, JJTCOMPARISON);
                                   boolean jjtc002 = true;
                                   jjtree.openNodeScope(jjtn002);
                                 }
                                 try {
/*@egen*//*@bgen(jjtree)*/
                                 {
                                   jjtree.closeNodeScope(jjtn002,  2);
                                   jjtc002 = false;
                                 }
/*@egen*/ { jjtn002.cmpType=NON_EQUAL; }/*@bgen(jjtree)*/
                                 } finally {
                                   if (jjtc002) {
                                     jjtree.closeNodeScope(jjtn002,  2);
                                   }
                                 }
/*@egen*/
  |IDExp() <LESS_THAN> Literal()/*@bgen(jjtree) #Comparison( 2) */
                                 {
                                   CLVFComparison jjtn003 = new CLVFComparison(this, JJTCOMPARISON);
                                   boolean jjtc003 = true;
                                   jjtree.openNodeScope(jjtn003);
                                 }
                                 try {
/*@egen*//*@bgen(jjtree)*/
                                 {
                                   jjtree.closeNodeScope(jjtn003,  2);
                                   jjtc003 = false;
                                 }
/*@egen*/ { jjtn003.cmpType=LESS_THAN; }/*@bgen(jjtree)*/
                                 } finally {
                                   if (jjtc003) {
                                     jjtree.closeNodeScope(jjtn003,  2);
                                   }
                                 }
/*@egen*/
  |IDExp() <GREATER_THAN> Literal()/*@bgen(jjtree) #Comparison( 2) */
                                    {
                                      CLVFComparison jjtn004 = new CLVFComparison(this, JJTCOMPARISON);
                                      boolean jjtc004 = true;
                                      jjtree.openNodeScope(jjtn004);
                                    }
                                    try {
/*@egen*//*@bgen(jjtree)*/
                                    {
                                      jjtree.closeNodeScope(jjtn004,  2);
                                      jjtc004 = false;
                                    }
/*@egen*/ { jjtn004.cmpType=GREATER_THAN; }/*@bgen(jjtree)*/
                                    } finally {
                                      if (jjtc004) {
                                        jjtree.closeNodeScope(jjtn004,  2);
                                      }
                                    }
/*@egen*/
  |IDExp() <LESS_THAN_EQUAL> Literal()/*@bgen(jjtree) #Comparison( 2) */
                                       {
                                         CLVFComparison jjtn005 = new CLVFComparison(this, JJTCOMPARISON);
                                         boolean jjtc005 = true;
                                         jjtree.openNodeScope(jjtn005);
                                       }
                                       try {
/*@egen*//*@bgen(jjtree)*/
                                       {
                                         jjtree.closeNodeScope(jjtn005,  2);
                                         jjtc005 = false;
                                       }
/*@egen*/ { jjtn005.cmpType=LESS_THAN_EQUAL; }/*@bgen(jjtree)*/
                                       } finally {
                                         if (jjtc005) {
                                           jjtree.closeNodeScope(jjtn005,  2);
                                         }
                                       }
/*@egen*/
  |IDExp() <GREATER_THAN_EQUAL> Literal()/*@bgen(jjtree) #Comparison( 2) */
                                          {
                                            CLVFComparison jjtn006 = new CLVFComparison(this, JJTCOMPARISON);
                                            boolean jjtc006 = true;
                                            jjtree.openNodeScope(jjtn006);
                                          }
                                          try {
/*@egen*//*@bgen(jjtree)*/
                                          {
                                            jjtree.closeNodeScope(jjtn006,  2);
                                            jjtc006 = false;
                                          }
/*@egen*/ { jjtn006.cmpType=GREATER_THAN_EQUAL; }/*@bgen(jjtree)*/
                                          } finally {
                                            if (jjtc006) {
                                              jjtree.closeNodeScope(jjtn006,  2);
                                            }
                                          }
/*@egen*/
  |IDExp() <REGEX_EQUAL> RegexLiteral()/*@bgen(jjtree) #Comparison( 2) */
                                        {
                                          CLVFComparison jjtn007 = new CLVFComparison(this, JJTCOMPARISON);
                                          boolean jjtc007 = true;
                                          jjtree.openNodeScope(jjtn007);
                                        }
                                        try {
/*@egen*//*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn007,  2);
                                          jjtc007 = false;
                                        }
/*@egen*/ { jjtn007.cmpType=REGEX_EQUAL; }/*@bgen(jjtree)*/
                                        } finally {
                                          if (jjtc007) {
                                            jjtree.closeNodeScope(jjtn007,  2);
                                          }
                                        }
/*@egen*/
  | <OPEN_PAR> LExpression() <CLOSE_PAR>
}


void Literal()       : {}
{
     SLitExp()
     |FPLitExp()
     |IntLitExp()
     |IDExp()
}

void Negation() : {/*@bgen(jjtree) Negation */
  CLVFNegation jjtn000 = new CLVFNegation(this, JJTNEGATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Negation */
  try {
/*@egen*/
  <NOT>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void FPLitExp()       :            // FPLitExp -> FPLIT
{
	Token t;
}
{
  t=<FLOATING_POINT_LITERAL>/*@bgen(jjtree) Literal */
        {
          CLVFLiteral jjtn001 = new CLVFLiteral(this, JJTLITERAL);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001, true);
          jjtc001 = false;
        }
/*@egen*/
  	{ jjtn001.setVal(t.image);}/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/
  |/*@bgen(jjtree) FloatArray */
     {
       CLVFFloatArray jjtn002 = new CLVFFloatArray(this, JJTFLOATARRAY);
       boolean jjtc002 = true;
       jjtree.openNodeScope(jjtn002);
     }
     try {
/*@egen*/  <FLOATING_POINT_ARRAY>/*@bgen(jjtree)*/
     } finally {
       if (jjtc002) {
         jjtree.closeNodeScope(jjtn002, true);
       }
     }
/*@egen*/
}

void IntLitExp()       :            // FPLitExp -> FPLIT
{
	Token t;
}
{
  t=<INTEGER_LITERAL>/*@bgen(jjtree) Literal */
        {
          CLVFLiteral jjtn001 = new CLVFLiteral(this, JJTLITERAL);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001, true);
          jjtc001 = false;
        }
/*@egen*/
  	{ jjtn001.setVal(t.image);}/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/
  |/*@bgen(jjtree) IntegerArray */
     {
       CLVFIntegerArray jjtn002 = new CLVFIntegerArray(this, JJTINTEGERARRAY);
       boolean jjtc002 = true;
       jjtree.openNodeScope(jjtn002);
     }
     try {
/*@egen*/  <INTEGER_ARRAY>/*@bgen(jjtree)*/
     } finally {
       if (jjtc002) {
         jjtree.closeNodeScope(jjtn002, true);
       }
     }
/*@egen*/
}

void SLitExp()       :            // FPLitExp -> FPLIT
{
  Token t;
}
{
  t=<STRING_LITERAL>/*@bgen(jjtree) Literal */
        {
          CLVFLiteral jjtn001 = new CLVFLiteral(this, JJTLITERAL);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001, true);
          jjtc001 = false;
        }
/*@egen*/
  	{ jjtn001.setVal(t.image.substring(1,t.image.length()-1)); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/
  |/*@bgen(jjtree) StringArray */
    {
      CLVFStringArray jjtn002 = new CLVFStringArray(this, JJTSTRINGARRAY);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
    }
    try {
/*@egen*/ <STRING_ARRAY>/*@bgen(jjtree)*/
    } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002, true);
      }
    }
/*@egen*/
}

void IDExp()       :               // IDExp -> ID
{
	Token t;
}
{
  t=<FIELD_ID>/*@bgen(jjtree) JetelFieldLiteral */
               {
                 CLVFJetelFieldLiteral jjtn001 = new CLVFJetelFieldLiteral(this, JJTJETELFIELDLITERAL);
                 boolean jjtc001 = true;
                 jjtree.openNodeScope(jjtn001);
               }
               try {
/*@egen*//*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn001, true);
                 jjtc001 = false;
               }
/*@egen*/ { jjtn001.setFieldName(t.image); }/*@bgen(jjtree)*/
               } finally {
                 if (jjtc001) {
                   jjtree.closeNodeScope(jjtn001, true);
                 }
               }
/*@egen*/
}

void RegexLiteral()       :
{
	Token t;
}
{
  t=<STRING_LITERAL>/*@bgen(jjtree) RegexLiteral */
                     {
                       CLVFRegexLiteral jjtn001 = new CLVFRegexLiteral(this, JJTREGEXLITERAL);
                       boolean jjtc001 = true;
                       jjtree.openNodeScope(jjtn001);
                     }
                     try {
/*@egen*//*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn001, true);
                       jjtc001 = false;
                     }
/*@egen*/ { jjtn001.setRegex(t.image); }/*@bgen(jjtree)*/
                     } finally {
                       if (jjtc001) {
                         jjtree.closeNodeScope(jjtn001, true);
                       }
                     }
/*@egen*/
}

