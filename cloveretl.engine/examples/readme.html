<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE>CloverETL examples</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 2.0  (Linux)">
	<META NAME="CREATED" CONTENT="20061005;11474600">
	<META NAME="CHANGED" CONTENT="20070313;9172900">
	<STYLE TYPE="text/css">
	<!--
		@page { size: 8.5in 11in }
	-->
	</STYLE>
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<H1><FONT COLOR="#008000">CloverETL examples</FONT></H1>
<P STYLE="margin-bottom: 0in"><I>by David Pavlis, Agata Vackova, Last
modified 
<SCRIPT LANGUAGE="javascript">
document.writeln(document.lastModified)
</SCRIPT>
</I></P>
<HR>
<H2>Prerequisites</H2>
<P>I assume that you have downloaded a binary package of <A HREF="http://cloveretl.berlios.de/download/#framework" TARGET="_blank">CloverETL</A>
framework and <A HREF="http://cloveretl.berlios.de/download/#examples" TARGET="_blank">Clover
Examples</A> or you built one from sources. Extract both zip files to
the same directory.<BR>When executing examples, You have to be in
directory where you unzipped the examples. Let's assume you have
extracted the archives into <TT>/home</TT>. Then when executing any
example, you have to be switched in <TT>/home/cloverETL/examples</TT>
(the directory where the <TT>.grf</TT> files are). 
</P>
<H4><I>Note: It is a good idea to read <A HREF="http://cloveretl.berlios.de/docs/doc1.html" TARGET="_blank">CloverETL
general documentation</A> first.</I> 
</H4>
<H3>Common things</H3>
<P>The examples presented here use various inputs and create various
outputs. In general, input data is taken from files stored in <TT>data/</TT>
subdirectory. Outputs are created in <TT>output/</TT> subdirectory
and required metadata is read from <TT>metadata/</TT> subdirectory. 
</P>
<P>In the directory with examples there is file workspace.prm with
WORKSPACE parameter definition. You have to change this parameter to
proper value before running graphs.</P>
<P>To run graphs you can use scripts (run.bat or run.sh) included in
examples package. They assumes that environment variable JAVA_HOME is
set to java home directory.</P>
<H4>Important notes</H4>
<P>All the examples below show how to run transformations on Linux
(Unix) machine. If you have Windows installed, just change the <TT>java
-cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
</TT>into <TT>-cp
<TT>&quot;../cloveretl.engine.jar;../lib/commons-logging.jar;../lib/log4j-1.2.12.zip;<TT>../lib/javolution.jar;javaExamples</TT>&quot;</TT></TT>
- the Java classpath delimiter on Windows is <TT>;</TT> (semicolon)
not <TT>:</TT> (colon). 
</P>
<P>CloverETL requires Java (JVM) version 1.5 or higher ! 
</P>
<H2><!-- Simple Examples -->Simple Examples</H2>
<H3><!-- Simple copy -->SimpleCopy example</H3>
<P>This example illustrates usage of SimpleCopy &amp; Trash
components. It reads <TT>employees.dat</TT> file, parses the records,
sends them to SimpleCopy component which in turn replicates them to
several Trash components connected to SimpleCopy component.<BR>One of
the Trash components is configured to dump all incoming records into
text file <TT>Trash1_output.txt</TT> - mostly for debugging
purpose.<BR>The Trash component normally discards all records it
receives on input port. 
</P>
<P STYLE="margin-bottom: 0in">Executing:</P>
<P STYLE="margin-bottom: 0in"><TT><TT>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;</TT>
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphSimpleCopy.grf" TARGET="_blank">graphSimpleCopy.grf</A></TT><BR><BR>This
is the expected output produced by the framework: 
</P>
<HR>
<PRE><TT>***  CloverETL framework/transformation graph runner ver 2.1, (c) 2002-06 D.Pavlis, released under GNU Lesser General Public License  ***</TT>
<TT> Running with framework version: 2.1 build#385 compiled 14/02/2007 18:12:57</TT>

<TT>DEBUG [main] - Plugin org.jetel.lookup loaded.</TT>
<TT>        id - org.jetel.lookup</TT>
<TT>        version - 2.1.0</TT>
<TT>        provider-name - null</TT>
<TT>                point-id  - lookup - {className=org.jetel.lookup.SimpleLookupTable, type=simpleLookup}</TT>
<TT>                point-id  - lookup - {className=org.jetel.lookup.DBLookupTable, type=dbLookup}</TT>

<TT>DEBUG [main] - Plugin org.jetel.sequence loaded.</TT>
<TT>        id - org.jetel.sequence</TT>
<TT>        version - 2.1.0</TT>
<TT>        provider-name - null</TT>
<TT>                point-id  - sequence - {className=org.jetel.sequence.SimpleSequence, type=SIMPLE_SEQUENCE}</TT>
<TT>                point-id  - sequence - {className=org.jetel.sequence.PrimitiveSequence, type=PRIMITIVE_SEQUENCE}</TT>

<TT>DEBUG [main] - Plugin org.jetel.thirdparty loaded.</TT>
<TT>        id - org.jetel.thirdparty</TT>
<TT>        version - 2.1.0</TT>
<TT>        provider-name - null</TT>
<TT>                point-id  - component - {type=XML_EXTRACT, className=org.jetel.component.XMLExtract}</TT>
<TT>                point-id  - component - {type=FILTER, className=org.jetel.component.Filter}</TT>
<TT>                point-id  - component - {type=LDAP_READER, className=com.linagora.component.LdapReader}</TT>
<TT>                point-id  - component - {type=LDAP_WRITER, className=com.linagora.component.LdapWriter}</TT>

<TT>DEBUG [main] - Plugin org.jetel.connection loaded.</TT>
<TT>        id - org.jetel.connection</TT>
<TT>        version - 2.1.0</TT>
<TT>        provider-name - null</TT>
<TT>                point-id  - connection - {className=org.jetel.connection.DBConnection, type=JDBC}</TT>
<TT>                point-id  - connection - {className=org.jetel.connection.JmsConnection, type=JMS}</TT>

<TT>DEBUG [main] - Plugin org.jetel.component loaded.</TT>
<TT>        id - org.jetel.component</TT>
<TT>        version - 2.1.0</TT>
<TT>        provider-name - null</TT>
<TT>                point-id  - component - {type=DATA_READER, className=org.jetel.component.DataReader}</TT>
<TT>                point-id  - component - {type=DATA_WRITER, className=org.jetel.component.DataWriter}</TT>
<TT>                point-id  - component - {type=DELIMITED_DATA_READER, className=org.jetel.component.DelimitedDataReader}</TT>
<TT>                point-id  - component - {type=DELIMITED_DATA_WRITER, className=org.jetel.component.DelimitedDataWriter}</TT>
<TT>                point-id  - component - {type=SIMPLE_COPY, className=org.jetel.component.SimpleCopy}</TT>
<TT>                point-id  - component - {type=CONCATENATE, className=org.jetel.component.Concatenate}</TT>
<TT>                point-id  - component - {type=SIMPLE_GATHER, className=org.jetel.component.SimpleGather}</TT>
<TT>                point-id  - component - {type=REFORMAT, className=org.jetel.component.Reformat}</TT>
<TT>                point-id  - component - {type=DB_INPUT_TABLE, className=org.jetel.component.DBInputTable}</TT>
<TT>                point-id  - component - {type=SORT, className=org.jetel.component.Sort}</TT>
<TT>                point-id  - component - {type=DB_OUTPUT_TABLE, className=org.jetel.component.DBOutputTable}</TT>
<TT>                point-id  - component - {type=FIXLEN_DATA_WRITER, className=org.jetel.component.FixLenDataWriter}</TT>
<TT>                point-id  - component - {type=DEDUP, className=org.jetel.component.Dedup}</TT>
<TT>                point-id  - component - {type=FIXLEN_DATA_READER, className=org.jetel.component.FixLenDataReader}</TT>
<TT>                point-id  - component - {type=MERGE, className=org.jetel.component.Merge}</TT>
<TT>                point-id  - component - {type=MERGE_JOIN, className=org.jetel.component.MergeJoin}</TT>
<TT>                point-id  - component - {type=EXT_MERGE_JOIN, className=org.jetel.component.MergeJoin}</TT>
<TT>                point-id  - component - {type=SORTED_JOIN, className=org.jetel.component.MergeJoin}</TT>
<TT>                point-id  - component - {type=TRASH, className=org.jetel.component.Trash}</TT>
<TT>                point-id  - component - {type=DB_EXECUTE, className=org.jetel.component.DBExecute}</TT>
<TT>                point-id  - component - {type=HASH_JOIN, className=org.jetel.component.HashJoin}</TT>
<TT>                point-id  - component - {type=EXT_HASH_JOIN, className=org.jetel.component.HashJoin}</TT>
<TT>                point-id  - component - {type=CHECK_FOREIGN_KEY, className=org.jetel.component.CheckForeignKey}</TT>
<TT>                point-id  - component - {type=DBF_DATA_READER, className=org.jetel.component.DBFDataReader}</TT>
<TT>                point-id  - component - {type=EXT_FILTER, className=org.jetel.component.ExtFilter}</TT>
<TT>                point-id  - component - {type=EXT_SORT, className=org.jetel.component.ExtSort}</TT>
<TT>                point-id  - component - {type=PARTITION, className=org.jetel.component.Partition}</TT>
<TT>                point-id  - component - {type=DATA_INTERSECTION, className=org.jetel.component.DataIntersection}</TT>
<TT>                point-id  - component - {type=AGGREGATE, className=org.jetel.component.Aggregate}</TT>
<TT>                point-id  - component - {type=SYS_EXECUTE, className=org.jetel.component.SystemExecute}</TT>
<TT>                point-id  - component - {type=KEY_GEN, className=org.jetel.component.KeyGenerator}</TT>
<TT>                point-id  - component - {type=APROX_MERGE_JOIN, className=org.jetel.component.AproxMergeJoin}</TT>
<TT>                point-id  - component - {type=DBJOIN, className=org.jetel.component.DBJoin}</TT>
<TT>                point-id  - component - {type=XLS_READER, className=org.jetel.component.XLSReader}</TT>
<TT>                point-id  - component - {type=XLS_WRITER, className=org.jetel.component.XLSWriter}</TT>
<TT>                point-id  - component - {type=CLOVER_WRITER, className=org.jetel.component.CloverDataWriter}</TT>
<TT>                point-id  - component - {type=CLOVER_READER, className=org.jetel.component.CloverDataReader}</TT>
<TT>                point-id  - component - {className=org.jetel.component.MysqlDataReader, type=MYSQL_DATA_READER}</TT>
<TT>                point-id  - component - {className=org.jetel.component.MysqlDataWriter, type=MYSQL_DATA_WRITER}</TT>
<TT>                point-id  - component - {className=org.jetel.component.StructureWriter, type=STRUCTURE_WRITER}</TT>
<TT>                point-id  - component - {className=org.jetel.component.Normalizer, type=NORMALIZER}</TT>
<TT>                point-id  - component - {className=org.jetel.component.Denormalizer, type=DENORMALIZER}</TT>
<TT>                point-id  - component - {className=org.jetel.component.JmsReader, type=JMS_READER}</TT>
<TT>                point-id  - component - {className=org.jetel.component.JmsWriter, type=JMS_WRITER}</TT>
<TT>                point-id  - component - {className=org.jetel.component.LookupJoin, type=LOOKUP_JOIN}</TT>
<TT>                point-id  - component - {className=org.jetel.component.LookupTableReaderWriter, type=LOOKUP_TABLE_READER_WRITER}</TT>
<TT>                point-id  - component - {className=org.jetel.component.DataGenerator, type=DATA_GENERATOR}</TT>
<TT>                point-id  - component - {className=org.jetel.component.MultiLevelReader, type=MULTI_LEVEL_READER}</TT>
<TT>                point-id  - component - {className=org.jetel.component.SequenceChecker, type=SEQUENCE_CHECKER}</TT>

<TT>DEBUG [main] - Plugin cz.opensys.oracle loaded.</TT>
<TT>        id - cz.opensys.oracle</TT>
<TT>        version - 2.1.0</TT>
<TT>        provider-name -</TT>
<TT>                point-id  - component - {className=cz.opensys.oracle.component.OracleDataReader, type=ORACLE_DATA_READER}</TT>
<TT>                point-id  - component - {className=cz.opensys.oracle.component.OracleDataWriter, type=ORACLE_DATA_WRITER}</TT>

<TT>Graph definition file: graphSimpleCopy.grf</TT>
<TT>INFO  [main] - Checking graph configuration...</TT>
<TT>DEBUG [main] - Opening input file /home/avackova/home/eclipse/cloverETL/examples/data/delimited/employees.dat</TT>
<TT>DEBUG [main] - Reading input file /home/avackova/home/eclipse/cloverETL/examples/data/delimited/employees.dat</TT>
<TT>INFO  [main] - Starting WatchDog thread ...</TT>
<TT>INFO  [WatchDog] - Thread started.</TT>
<TT>INFO  [WatchDog] - Running on 1 CPU(s) max available memory for JVM 65088 KB</TT>
<TT>INFO  [WatchDog] - [Clover] Initializing phase: 0</TT>
<TT>DEBUG [WatchDog] -  initializing edges:</TT>
<TT>DEBUG [WatchDog] -  all edges initialized successfully...</TT>
<TT>DEBUG [WatchDog] -  initializing nodes:</TT>
<TT>DEBUG [WatchDog] -      BROADCAST ...OK</TT>
<TT>DEBUG [WatchDog] -      BROADCAST2 ...OK</TT>
<TT>DEBUG [WatchDog] - Opening input file /home/avackova/home/eclipse/cloverETL/examples/data/delimited/employees.dat</TT>
<TT>DEBUG [WatchDog] - Reading input file /home/avackova/home/eclipse/cloverETL/examples/data/delimited/employees.dat</TT>
<TT>DEBUG [WatchDog] -      INPUT1 ...OK</TT>
<TT>DEBUG [WatchDog] -      TRASH1 ...OK</TT>
<TT>DEBUG [WatchDog] -      TRASH2 ...OK</TT>
<TT>DEBUG [WatchDog] -      TRASH3 ...OK</TT>
<TT>INFO  [WatchDog] - [Clover] phase: 0 initialized successfully.</TT>
<TT>INFO  [WatchDog] - Starting up all nodes in phase [0]</TT>
<TT>DEBUG [WatchDog] - BROADCAST ... started</TT>
<TT>DEBUG [WatchDog] - BROADCAST2 ... started</TT>
<TT>DEBUG [WatchDog] - INPUT1 ... started</TT>
<TT>DEBUG [WatchDog] - TRASH1 ... started</TT>
<TT>DEBUG [WatchDog] - TRASH2 ... started</TT>
<TT>DEBUG [WatchDog] - TRASH3 ... started</TT>
<TT>INFO  [WatchDog] - Sucessfully started all nodes in phase!</TT>
<TT>INFO  [WatchDog] - Execution of phase [0] successfully finished - elapsed time(sec): 1</TT>
<TT>INFO  [WatchDog] - ---------------------** Start of tracking Log for phase [0] **-------------------</TT>
<TT>INFO  [WatchDog] - Time: 09/03/07 11:00:25</TT>
<TT>INFO  [WatchDog] - Node                   Status     Port      #Records         #KB  Rec/s   KB/s</TT>
<TT>INFO  [WatchDog] - ----------------------------------------------------------------------------------</TT>
<TT>INFO  [WatchDog] - BROADCAST              FINISHED_O</TT>
<TT>INFO  [WatchDog] - %CPU:-1.9                          In:0           12           8      0       0</TT>
<TT>INFO  [WatchDog] -                                   Out:0           12           8      0       0</TT>
<TT>INFO  [WatchDog] -                                   Out:1           12           8      0       0</TT>
<TT>INFO  [WatchDog] -                                   Out:2           12           8      0       0</TT>
<TT>INFO  [WatchDog] - BROADCAST2             FINISHED_O</TT>
<TT>INFO  [WatchDog] - %CPU:-1.9                          In:0           12           8      0       0</TT>
<TT>INFO  [WatchDog] -                                   Out:0           12           8      0       0</TT>
<TT>INFO  [WatchDog] - INPUT1                 FINISHED_O</TT>
<TT>INFO  [WatchDog] - %CPU:-1.9                         Out:0           12           8      0       0</TT>
<TT>INFO  [WatchDog] - TRASH1                 FINISHED_O</TT>
<TT>INFO  [WatchDog] - %CPU:-1.9                          In:0           12           8      0       0</TT>
<TT>INFO  [WatchDog] - TRASH2                 FINISHED_O</TT>
<TT>INFO  [WatchDog] - %CPU:-1.9                          In:0           12           8      0       0</TT>
<TT>INFO  [WatchDog] - TRASH3                 FINISHED_O</TT>
<TT>INFO  [WatchDog] - %CPU:-1.9                          In:0           12           8      0       0</TT>
<TT>INFO  [WatchDog] - ---------------------------------** End of Log **--------------------------------</TT>
<TT>INFO  [WatchDog] - Forcing garbage collection ...</TT>
<TT>INFO  [WatchDog] - -----------------------** Summary of Phases execution **---------------------</TT>
<TT>INFO  [WatchDog] - Phase#            Finished Status         RunTime(sec)    MemoryAllocation(KB)</TT>
<TT>INFO  [WatchDog] - 0                 0                                  1               842</TT>
<TT>INFO  [WatchDog] - ------------------------------** End of Summary **---------------------------</TT>
<TT>INFO  [main] - WatchDog thread finished - total execution time: 1 (sec)</TT>
<TT>INFO  [main] - Graph execution finished successfully</TT></PRE><H3>
<!-- Reformat -->Reformat example</H3>
<P>Reformat component changes format and/or content of data records
by applying &quot;reformat&quot; method on all data records flowing
through it.<BR>For every record it receives through input port it
calls <TT>transform()</TT> method of specified class (name defined
through <TT>transformClass</TT> attribute of Reformat component),
which has to implement <TT><A HREF="javaExamples/reformatOrders.java">org.jetel.component.RecordTransform</A></TT>
interface.<BR>The transformation class has to be compiled separately
prior to running Reformat component and it must reside in directory
accessed by Java when searching for classes (i.e. either included in
CLASSPATH or defined using <TT>-cp</TT> parameter when starting java
VM. 
</P>
<P>Executing:<BR><TT>Prepare reformat class:<BR>javac -cp
&quot;../cloveretl.engine.jar&quot;
javaExamples/reformatOrders.java<BR>Execute graph:<BR>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphOrdersReformat.grf" TARGET="_blank">graphOrdersReformat.grf</A></TT></P>
<H3><!-- Reformat Inline -->Reformat example with transformation
class source embedded</H3>
<P>This example is similar to previous one except transformation
class (its source code) is directly embedded into graph definition
file. The source code is automatically compiled when the graph is
started and then transformation object is created to be executed for
each record.<BR>When the graph is run subsequently, the source is
recompiled only if it changes between two runs.<BR>In order to run
successfully, environment variable $JAVA_HOME have to be set
correctly.</P>
<P>Executing:<BR><TT>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples:$JAVA_HOME/lib/tools.jar&quot;
org.jetel.main.runGraph -plugins ../plugins
<A HREF="graphOrdersReformatInline.grf" TARGET="_blank">graphOrdersReformatInline.grf</A></TT></P>
<H3><!-- Reformat with transformation -->Reformat example with
transformation in-line</H3>
<P>This example is similar to previous ones except transformation is
given in special form. If you need simple transformation, when output
fields are combinations of inputs fields and some parameters, this is
the simplest way how to do it.</P>
<P>Executing:<BR><TT>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples<TT>:$JAVA_HOME/lib/tools.jar</TT>&quot;
org.jetel.main.runGraph -plugins ../plugins
<A HREF="graphOrdersReformatUsingTransform.grf" TARGET="_blank">graphOrdersReformatUsingTransform.grf</A></TT></P>
<H3><!-- Reformat with transformation in Transform Language -->Reformat
example with transformation in Transform Language</H3>
<P>This example is similar to previous ones except transformation is
given in <A HREF="../docs/CloverETL_transformation_language.odt">Transform
Language.</A>In this language you can write complicated
transformations in relatively easy way. 
</P>
<P>Executing:<BR><TT>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphOrdersTLReformat.grf" TARGET="_blank">graphOrdersTLReformat.grf</A></TT></P>
<H3><!-- Merge -->Merge example</H3>
<P>Merge component combines several <U>sorted</U> input data flows
into one based on specified key. The resulting data flow is sorted
according to specified key.<BR>This component can be successfully
used when you have several sorted data files and you need to combine
them into one big sorted file, but you don't want to waste resources
on resorting the big file.<BR>The testing graph reads data form
<TT>orders.sorted</TT> file (actually three readers access the file
at the same time) and stores the result into <TT>orders.merged</TT>
file. 
</P>
<P>Executing:<BR><TT>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphMergeData.grf" TARGET="_blank">graphMergeData.grf</A></TT></P>
<H3><!-- Filter -->Filter example</H3>
<P>Filter component allows filtering any input data records based on
specified filter condition. It can split flow of data into two. One
with records which fulfill the condition and the other with those
which don't.<BR>Filter condition is composed of one or more simple
comparisons <TT>&lt;,&gt;,&lt;=,&gt;=,==,!=</TT>. Individual
comparisons can be combined using logical operators <TT>AND</TT> and
<TT>OR</TT>. Parenthesis can be used to group comparisons. There are
some logical functions (see description of <A HREF="http://cloveretl.berlios.de/docs/CloverETL_components.html#0_4_19">Extended
Filter Component</A>) you can use too.<BR>This graph is a bit more
complex and illustrates usage of Filter and HashJoin components. It
produces four output files: 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0in">all employees who were hired
	before 1993-12-31 
	</P>
	<LI><P STYLE="margin-bottom: 0in">all employees who have in their
	memo that they are &quot;fluent&quot; in some language</P>
	<LI><P STYLE="margin-bottom: 0in">all employees who have in their
	memo that they are &quot;fluent&quot; in some language and were
	hired before 1993-12-31</P>
	<LI><P>all employees who were hired after 1993-12-31</P>
</UL>
<P>Executing:<BR><TT>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples<TT>:$JAVA_HOME/lib/tools.jar</TT>&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphExtFilter.grf" TARGET="_blank">graphExtFilter.grf</A></TT></P>
<H3><!-- Join -->Join example</H3>
<P>Join component joins two or more <U>sorted</U> input data flows
into one based on specified key. It can produce classical inner join
or left outer join (based on parameters).<BR>This component can be
useful when you have main data set - for example with orders (driver)
containing part number and you need to join it with other data set
containing price for each part (slave).<BR>The testing graph reads
data form <TT>orders.dat</TT> file (driver) and <TT>employees.dat</TT>
and produces records with combined information from both files.<BR>Each
pair of corresponding records is transformed by
<TT>reformatJoinTest.class</TT>. The source code for this class is
attached as well. 
</P>
<P>Executing:<BR><TT>Prepare reformat class:<BR>javac -cp
&quot;../cloveretl.engine.jar&quot;
javaExamples/<TT>reformatJoinTest</TT>.java<BR>Execute graph:<BR>java
-cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphJoinData.grf" TARGET="_blank">graphJoinData.grf</A></TT>
</P>
<H3><!-- Hash Join -->Hash Join example</H3>
<P>Hash Join component joins two or more input data flows into one
based on specified key. It can produce classical inner join or left
outer join (based on parameters).<BR>Functionality of this component
is similar to previous one, but it doesn't require input data to be
sorted. It is most suited to join data sets when one is relatively
large (master) and the others are small (slaves) - typically when
using lookup table to convert key into corresponding value.<BR>The
testing graph reads data form <TT>orders.dat</TT> file (driver) and
<TT>employees.dat</TT> and produces records with combined information
from both files.<BR>Each pair of corresponding records is transformed
by <TT>reformatJoinTest.class</TT>. The source code for this class is
attached as well. 
</P>
<P>Executing:<BR><TT>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphJoinHash.grf" TARGET="_blank">graphJoinHash.grf</A></TT>
</P>
<H3><!-- Hash Join Inline-->Hash Join with transformation class
source embedded</H3>
<P>As with Reformat component, transformation class which is executed
for input records can be embedded directly into graph. It is again
dynamically compiled at run-time.<BR>In this example you can see
joining more then two input sets. Master data from <TT>orders.dat</TT>
are joined with two slave inputs: first <TT>employees.dat</TT> due to
key field <TT>EmployeeID</TT> and with the second,
<TT>customers_delimited.txt</TT>, due to key field <TT>CustomerID.</TT>
So in output record there are information from all three input files.</P>
<P>Executing:<BR><TT>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples<TT>:$JAVA_HOME/lib/tools.jar</TT>&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphJoinHashInline.grf" TARGET="_blank">graphJoinHashInline.grf</A></TT></P>
<H3><!-- Hash Join with transformation-->Hash Join with
transformation in-line</H3>
<P>As with Reformat component, transformation can be written in
summary form.<BR><BR><BR>
</P>
<P>Executing:<BR><TT>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples<TT>:$JAVA_HOME/lib/tools.jar</TT>&quot;
org.jetel.main.runGraph -plugins ../plugins
<A HREF="graphJoinHashUsingTransform.grf" TARGET="_blank">graphJoinHashUsingTransform.grf</A></TT></P>
<H3><!-- Hash Join with transformation in Transform Language-->Hash
Join with transformation in Transform Language</H3>
<P>As with Reformat component, transformation can be written in
<A HREF="../docs/CloverETL_transformation_language.zip">Transform
Language.</A><BR><BR><BR>
</P>
<P>Executing:<BR><TT>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
org.jetel.main.runGraph -plugins ../plugins
<A HREF="graphJoinHashUsingTransformLanguage.grf" TARGET="_blank">graphJoinHashUsingTransformLanguage.grf</A></TT></P>
<H3><!-- Sort -->Sort example</H3>
<P>Sort component sorts input data flow based on specified key. You
can use more than one field name for key.<BR>Sorted data flow is
required by several components (Merge, Join, etc..) so this is very
useful component.<BR>The testing graph reads data form <TT>orders.dat</TT>
file, sorts them and stores the result into <TT>orders.sorted</TT>
file. 
</P>
<P>Executing:<BR><TT>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphSortData.grf" TARGET="_blank">graphSortData.grf</A></TT></P>
<H3><A NAME="Sort Universal example|outline"></A><!-- Sort Universal -->Sort
Universal example</H3>
<P>Similar to previous example, this one sorts input data. The
difference is that the exact datafile to be sorted is not hardcoded
within graph definition, it is determined based on supplied
parameters.<BR>CloverETL allows global graph properties to be defined
and these properties can be reference from within the graph. Each
reference is replaced by property value at run-time. In our example
parameter's definitions are embedded in graph code (Executing: <TT>java
-cp
&quot;<TT>../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples</TT>&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphSortUniversal.grf" TARGET="_blank">graphSortUniversal.grf)</A></TT>
but it is possible to define parameters in-line. In such case you can
pass on parameters in executing command: <BR><TT>java -cp
&quot;<TT>../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples</TT>&quot;
org.jetel.main.runGraph -plugins ../plugins
-P:sortKey=<I>&lt;..your.fieldName..&gt;</I> -P:metadata=<I>&lt;..metadata
filename..&gt;</I> -P:data=<I>&lt;..datafile..&gt;</I>
-P:outputData=<I>&lt;..datafile..&gt;</I> <A HREF="graphSortUniversal.grf" TARGET="_blank">graphSortUniversal.grf</A></TT></P>
<H3><!-- Phases examples -->Phases example</H3>
<P>Components can be grouped into individual phases. Each phase has
assigned a unique number. In each transformation graph, there must
exists at least one phase (with any number assigned to it).<BR>Execution
of graph is done by phases. It starts with phase with the lowest
number and continues in ascending order. All components in particular
phase are initialized and run. Then components from next phase are
started and so on. If there are any connections (Edges) between
components from different phases, these connections are buffered so
the first component (from preceding phase) can finish its job and the
second component (from following - not necessarily next) can read the
data produced by the fist component.</P>
<P>Example presented here is divided into three phases. First,data is
read and sorted, in second,data is copied into three similar flows.
In third, data is again merged into one flow and saved to file.</P>
<P>Executing:<BR><TT>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphPhasesDemo.grf" TARGET="_blank">graphPhasesDemo.grf</A></TT></P>
<H3><!-- Partition -->Partition data example</H3>
<P>Partition component offers various ways of splitting input data
flow into several output flows. The exact number of output flows
depends on how many output ports are connected.<BR>There are
currently three partition algorithms implemented: 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0in"><B>Round-Robin</B> - first record
	goes into first port, second into second...etc. When the last port
	was used, it starts again with the first one. 
	</P>
	<LI><P STYLE="margin-bottom: 0in"><B>Hash</B> - based on specified
	key, a hash value is calculated and based on it the output port is
	selected. It should be secured that for two different records with
	same keys, the exact same output port is selected. 
	</P>
	<LI><P><B>Range</B> - based on specified key and range array,
	records are sent to output port based on value present in key-field.
	It is very similar to CASE operator, with ranges defined by their
	upper boundary (inclusive). 
	</P>
</UL>
<P>It is possible to write your own partition function. It has to
implement <TT><A HREF="http://cloveretl.berlios.de/docs/JavaDoc/org/jetel/component/partition/PartitionFunction.html">org.jetel.component.partition.PartitionFunction</A>
</TT>and can be write as java source or in <A HREF="../docs/CloverETL_transformation_language.odt">Transformation
Language.</A></P>
<P>Executing example:<BR><TT>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphPartition.grf" TARGET="_blank">graphPartition.grf</A></TT></P>
<H3><!-- System call examples -->System call example</H3>
<P>It is possible to call system command from CloverETL framework.
System execute component can be standalone component or can work with
records flowing form other component. Output from executing system
command can be sent to other component or can be logged to file. If
there is not given interpreter, “command” attribute is treated as
simple system command with parameters, else “command” attribute
is saved in temporary batch file and there is called interpreter to
execute this script</P>
<P>Executing:<BR><TT>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphSystemExecute.grf" TARGET="_blank">graphSystemExecute.grf</A></TT></P>
<H3><!-- Excel example -->Working with Excel files example</H3>
<P>CloverETL can read and write data from/to xls files. In this
example data are read from <TT>ORDERS.xls</TT> file, partitioned to 3
parts and each of thees parts are saved in <TT>orders.partitioned.xls</TT>
file in different sheets. 
</P>
<P><I>Important: 1.Because it is impossible to write to different
sheets in the same time each writing component has to be in different
phase. 2. </I><TT><I>poi-2.5.1.jar (reading/writing to excel files
library) has to be in execution path.</I></TT></P>
<P>Executing:<BR><TT>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples:../lib/poi-2.5.1.jar&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphXLSReadWrite.grf" TARGET="_blank">graphXLSReadWrite.grf</A></TT></P>
<H3><!-- XML example -->XML extract example</H3>
<P>CloverETL can read data from xml files. In this example data are
read from <TT>employees.xml </TT>file. “Mapping” attribute
describes dependencies between xml nodes and metadata fields. 
</P>
<P><I>Important: tools.jar has to be in execution path.</I></P>
<P>Executing:<BR><TT>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples<TT>:$JAVA_HOME/lib/tools.jar</TT>&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphXMLExtract.grf" TARGET="_blank">graphXMLExtract.grf</A></TT></P>
<H3><!-- Read example -->Different ways of reading files</H3>
<P>There are few components for reading data from flat file:
Delimited Data Reader – reads delimited data, Fixlen Data Reader –
reads data of fixed length and Universal Data Reader, which can read
delimited or fixed length data depending on metadata on output port.
There are others reader components for reading data in different
formats: DBFDataReader – reads dBase tables, XMLExtract – reads
xml files, XLSDataReader – reads excel files, Clover Data Reader –
reads data saved in clover internal folders. Most of thees readers
can read data from “MultiFile” - it means that in fileURL
attribute can be wildcards as * or ?. This illustrates following
example:</P>
<P>Executing:<BR><TT>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples<TT>:$JAVA_HOME/lib/tools.jar</TT>&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphCloverData.grf">graphCloverData.grf</A></TT></P>
<P>It is possible to omit some data from flat file. For such purpose
there is attribute <SPAN STYLE="text-decoration: none">shift on
metadata, which indicates how many characters should be omitted from
last field. Usage of this feature you can see in following example:</SPAN></P>
<P><SPAN STYLE="text-decoration: none">Executing:<BR><TT>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples<TT>:<TT>../lib/poi-2.5.1.jar</TT></TT>&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphGenerateData.grf">graphGenerateData.grf</A></TT></SPAN></P>
<HR>
<H2><!-- Database related examples -->Database related examples</H2>
<P>When experimenting with database, presented example graphs expect
that there exists database table <TT>EMPLOYEE</TT> with following
structure:</P>
<PRE><TT>create table MYEMPLOYEE</TT>
<TT>(</TT>
<TT>  EMP_NO      NUMBER not null,</TT>
<TT>  FIRST_NAME  VARCHAR2(15) not null,</TT>
<TT>  LAST_NAME   VARCHAR2(20) not null,</TT>
<TT>  PHONE_EXT   VARCHAR2(4),</TT>
<TT>  HIRE_DATE   DATE not null,</TT>
<TT>  DEPT_NO     CHAR(3) not null,</TT>
<TT>  JOB_CODE    VARCHAR2(5) not null,</TT>
<TT>  JOB_GRADE   NUMBER(4,2) not null,</TT>
<TT>  JOB_COUNTRY VARCHAR2(15) not null,</TT>
<TT>  SALARY      NUMBER(15,2) not null,</TT>
<TT>  FULL_NAME   VARCHAR2(35)</TT>
<TT>);</TT></PRE><P>
If you wish to experiment with unloading data from this table, you
can use <TT>populate_employee_table.sql</TT> file (supplied with
these examples) to insert some records into the table. There is also
Oracle specific file <TT>populate_employee_table.ora</TT>. 
</P>
<H3><!-- DB Unload -->DBUnload example</H3>
<P>DBInputTable component can be used for extracting data from
database. It allows a SQL query to be specified and run against
database. The result set produced by DB is then sent by the component
to output port - and gets propagated to other processing nodes. It
uses JDBC to communicate with DB.<BR>You may wonder why to use
CloverETL for processing data which is already in DB. It should be
faster to perform any processing within DB itself. Well, it is not
always true.<BR>DBUnload component (as all other DB related
components) needs to know which JDBC driver to use, what is the DB
connection string and under what user name it should connect to
database. These parameters can be provided directly to component (one
by one) or special config file can be created from which component is
able to read required info.<BR>Following is an example of config file
which can be used to connect to Borland Interbase DB:</P>
<HR>
<PRE><TT>dbDriver=interbase.interclient.Driver</TT>
<TT>dbURL=jdbc:interbase://localhost/home/projects/interbase/examples/database/employee.gdb</TT>
<TT>user=SYSDBA</TT>
<TT>password=masterkey</TT></PRE>
<HR>
<P>I hope that the parameters (their names) are self-explanatory. If
not, read some JDBC related documentation.<BR>In this example, the
DBInputTable component connects to database and unloads all records
from <B>employee</B> table. It then stores the records in
<TT>employees.list.out</TT> file. 
</P>
<P>Executing:<BR>j<TT>ava -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphDBUnload.grf" TARGET="_blank">graphDBUnload.grf</A></TT></P>
<H3><!-- DB Load -->DBLoad example</H3>
<P>DBOutputTable component does the opposite to DBInputTable, it
populates database table with data processed by CloverETL framework.
Similarly to DBInputTable, it requires some JDBC related parameters
to be supplied. In order to be able to run this example, you have to
create a DB table with the name <TT>EMPLOYEE_TMP</TT> and structure
similar to <TT>EMPLOYEE</TT> table presented above. 
</P>
<P>Executing:<BR>j<TT>ava -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphDBLoad.grf" TARGET="_blank">graphDBLoad.grf</A></TT></P>
<H3><!-- DB Join -->DBJoin example</H3>
<P>DBJoin component joins records from input port with records from
database. Each pair of matching records is sent to transformation
(can be written in four ways : external class, java source embedded
in graph definition, summary transformation or in Transform Language)
to get output record. In this example for records from flat file are
searched records from database where field “lname” on input has
the same value as field “last_name” in database records.</P>
<P>Executing:<BR><TT>Prepare transform class:<BR>javac -cp
&quot;../cloveretl.engine.jar&quot;
javaExamples/TransformForDBjoin.java<BR>Execute graph:<BR>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples<TT>:$JAVA_HOME/lib/tools.jar</TT>&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphDBJoin.grf" TARGET="_blank">graphDBJoin.grf</A></TT></P>
<H3><!-- DB Lookup -->DBLookup example</H3>
<P>Graph <A HREF="graphDBLookup.grf" TARGET="_blank">graphDBLookup.grf
</A>has similar functionality as preceding graph, but You can see
usage of Database Lookup Table.</P>
<P>Executing:<BR><TT>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples<TT>:$JAVA_HOME/lib/tools.jar</TT>&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphDBLookup.grf" TARGET="_blank">graphDBLookup.grf</A></TT></P>
<HR>
<H2><!-- Complex examples -->Complex examples</H2>
<P>This examples combines several components to perform useful
transformation similar to one you could use in a real life.</P>
<H3><!-- Join example -->Join example</H3>
<P>Thees graphs combine information about orders made and information
about individual items/products purchased within each order. It also
adds information about which customer ordered the goods.<BR>To get
all this information, it needs to join data from <TT>ORDERS.DBF</TT>
(a dBase table) <TT>ODETAILS.DBF</TT> and <TT>Customers.txt</TT>.<BR>First
two data sets are joined using <TT>MERGE_JOIN</TT> component, thus
they have to be sorted first. Then information about customer is
added using <TT>HASH_JOIN</TT>. As both joins require transformation
code, two transformation classes are embedded directly into graph
file and dynamically compiled at run-time.<BR>As there is a
possibility that data set containing info about orders references
customer which is not in <TT>Customers.txt</TT> file, second join is
defined to be a left join. At the end, <TT>EXT_FILTER</TT> is used to
split data to two sets - one with customer info complete and the
other with missing.</P>
<P><I>Note:In order to run successfully,<TT>tools.jar</TT> library
(present in $JAVA_HOME/lib/) has to be part of CLASSPATH.</I> 
</P>
<P>Executing:<BR><TT>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples<TT>:$JAVA_HOME/lib/tools.jar</TT>&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphDBFJoin.grf" TARGET="_blank">graphDBFJoin.grf</A></TT></P>
<P>Graph <A HREF="graphDBFJoinTL.grf" TARGET="_blank">graphDBFJoinTL.grf</A>
is very similar to preceding one, but with transformation written in
<A HREF="../docs/CloverETL_transformation_language.zip">Transform
Language.</A>.</P>
<P>Executing:<BR><TT><TT>java -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples
</TT>&quot; org.jetel.main.runGraph -plugins ../plugins
<A HREF="graphDBFJoinTL.grf" TARGET="_blank">graphDBFJoinTL.grf</A></TT></P>
<H3><!-- Intersection example -->Intersection example</H3>
<P>This graph reads personal data from three sources and finds
records with the same values on corresponding fields (lname –
last_name, fname – first_name). Matching pairs are transformed into
one output record and saved in <TT>intersection_customer_employee.txt</TT>
file.</P>
<P>Executing:<BR>j<TT><TT>ava -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples<TT>:$JAVA_HOME/lib/tools.jar</TT></TT>&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphDBRead.grf" TARGET="_blank">graphDBRead.grf</A></TT></P>
<H3><!-- Approximative join example -->Approximative join example</H3>
<P>Approximative join component is used for joining data which are
similar on given fields. It requires data to be prepared: it joins
data from two data flows with the same value of <TT>matching key </TT>and
similar value of <TT>join key. </TT>In this example data are read
from from file<TT>customers0.dat </TT>and from database table
<TT>employee; </TT>then for both flows there is generated <TT>matching
key </TT>consisting of 4 letters of last name (flat file: lname,
database: last_name) and 3 letters of first name (flat file: fname,
database: first_name) . Approximative join component joins data from
thees flows (sorted due the <TT>matching key</TT>) ; it compares
records with the same matching key only, but to conforming output
sends only thees, which join key is similar enough (conformity
attribute), so among conforming records you can found such record: <TT>4
Damstra <FONT COLOR="#ff0000">Robert</FONT> Damstra <FONT COLOR="#ff0000">Roberta</FONT>
0.875” </TT>- with conformity 0.875 (conformity equals 1 means that
records are identical).</P>
<P>This graph illustrates usage of <TT>CustomizedRecordTransform</TT>
class too. This class extend abstract class <A HREF="http://cloveretl.berlios.de/docs/JavaDoc/org/jetel/component/DataRecordTransform.html">DataRecordTransform</A>
and allows to create complex transformation in relatively easy way.</P>
<P>Executing:<BR><TT>Prepare transform class:<BR>javac -cp
&quot;../cloveretl.engine.jar:<TT>../lib/commons-logging.jar</TT>&quot;
javaExamples/customizedTransformExample.java<BR>Execute graph:<BR>java
-cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples<TT>:$JAVA_HOME/lib/tools.jar</TT>&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphAproximativeJoin.grf" TARGET="_blank">graphAproximativeJoin.grf</A></TT></P>
<H3><!-- Real life example -->Real life example</H3>
<P STYLE="margin-bottom: 0in">This is practical illustration of usage
CloverETL. This graph transforms data for branch bank. On inputs are
clients, month interests and charges and half-year bonus. On outputs
we have aggregated revenues by clients, clients without revenues and
clients from database, who are not in input file. 
</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in">Executing:<BR>j<TT><TT>ava -cp
&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples<TT>:$JAVA_HOME/lib/tools.jar</TT></TT>&quot;
org.jetel.main.runGraph -plugins ../plugins <A HREF="graphRevenues.grf" TARGET="_blank">graphRevenues.grf</A></TT></P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<HR>
<H1><!--- ALL EXAMPLES INDEX --->Index of all examples</H1>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=0>
	<COL WIDTH=64*>
	<COL WIDTH=192*>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphAggregateSorted.grf">graphAggregateSorted.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates usage of Aggregate component. 
			</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphAggregateUnsorted.grf">graphAggregateUnsorted.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates usage of Aggregate component. 
			</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphAproximativeJoin.grf">graphAproximativeJoin.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P STYLE="margin-bottom: 0in">In this example data are read from
			from file <TT>customers0.dat </TT>and from database table
			<TT>employee; </TT>then for both flows there is generated <TT>matching
			key </TT>consisting of 4 letters of last name (flat file: lname,
			database: last_name) and 3 letters of first name (flat file:
			fname, database: first_name) . Approximative join component joins
			data from thees flows (sorted due the <TT>matching key</TT>) ; it
			compares records with the same matching key only, but to
			conforming output sends only thees, which join key is similar
			enough (conformity attribute), so among conforming records you can
			found such record: “<TT><FONT SIZE=2>4 Damstra <FONT COLOR="#ff0000">Robert</FONT>
			Damstra <FONT COLOR="#ff0000">Roberta</FONT> 0.875” </FONT></TT>-
			with conformity 0.875 (conformity equals 1 means that records are
			identical).</P>
			<P>This graph illustrates usage of <TT>CustomizedRecordTransform</TT>
			class too. This class extend abstract class <A HREF="http://cloveretl.berlios.de/docs/JavaDoc/org/jetel/component/DataRecordTransform.html">DataRecordTransform</A>
			and allows to create complex transformation in relatively easy
			way.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphCloverData.grf">graphCloverData.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates usage of CloverDataReader/Writer
			components. This components reads/writes data in clover internal
			format and can be used for moving data between different graphs.
			Reading/writing data in clover format is faster then in any other
			format. This graph shows how works StructureWriter component (it
			can be used for writing records and some additional information
			eg. in xml format).</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphDBExecute.grf">graphDBExecute.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates how-to run SQL/DDL/DML commands against
			database. Commands in SQLCode are delimited by semicolon and are
			executed one by one. If needed, they may be grouped into single
			transaction. 
			</P>
			<P>This graph creates two tables (EMPLOYEE and EMPLOYEE_TMP) and
			populates table EMPLOYEE with sample data.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphDBFJoin.grf">graphDBFJoin.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates complex transformation. It reads data
			about orders made and combines them (joins) with data about which
			items were purchased. It then adds information about which company
			made particular order/bought particular item. It illustrates usage
			of DBFDataReader,Sort,MergeJoin,HashJoin,Filter. It also shows how
			to embed data transformation routine directly into transformation
			graph layout file (both joins have the transformations embedded).
			Note: It is faster to reference record's fields by index as
			opposite to names – used in this example.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphDBFJoinTL.grf">graphDBFJoinTL.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates complex transformation like preceding
			example, but transformations are written in <A HREF="../docs/CloverETL_transformation_language.odt">Transform
			Language</A>,</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphDBJoin.grf">graphDBJoin.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph shows usage of DBJoin component: data are read from
			flat file and joined with the records from database due to
			conforming key field (lname in records read from file, last_name
			in records read from database).</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphDBFLoad.grf">graphDBFLoad.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates reading data from DBF file.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphDBLoad.grf">graphDBLoad.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates how to propagate data to database.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphDBLoad5.grf">graphDBLoad5.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates usage of dbFields and cloverFields
			parameters of DB_OUTPUT_TABLE component. Parameter dbFields allows
			to specify that only certain fields of target DB table will be
			populated. Parameter cloverFields allows to specify which
			input/Clover fields are used for populating target fields. The
			final mapping is determined by the order in which Clover fields
			and DB fields appear in the parameters or can be set directly.
			Note: parameter batchMode allows for grouping of inserts into DB
			thus increasing throughput. It works only with DBs/JDBC drivers
			which support this feature (e.g. Oracle).</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphDBLoad6.grf">graphDBLoad6.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates how to run hand-written SQL/DML against
			DB. Parameters (question-marks) are substituted by input fields
			(in order they are listed in cloverFields). Also target parameter
			types are devised from input field types - this may cause some
			problems when trying to map incompatible data types.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphDBLookup.grf" TARGET="_blank">graphDBLookup.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates how to join data using reformat
			component. <A HREF="#graphLookupJoingrf">graphLookupJoin.grf</A>
			shows how to do similar transformation in easier way.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphDBRead.grf" TARGET="_blank">graphDBRead.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph reads personal data from three sources and finds
			records with the same values on corresponding fields (lname –
			last_name, fname – first_name). Matching pairs are transformed
			into one output record and saved in
			<TT>intersection_customer_employee.txt</TT> file.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphDBUnload.grf">graphDBUnload.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>In this example, the DBInputTable component connects to
			database and unloads all records from <B>employee</B> table. It
			then stores the records in <TT>employees.list.out</TT> file. 
			</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphDBUnloadParametrized.grf">graphDBUnloadParametrized.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates how to read not all records from
			database. This example is similar to <A HREF="graphDBJoin.grf">graphDBJoin.grf</A>,
			but found records from database are not sent to transformation
			function, but directly to output port. For illustration in the
			next phase are read all data from the same table.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphDBUnloadUniversal.grf">graphDBUnloadUniversal.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates usage of dynamic metadata generation
			based on SQL query. It allows unloading of database data without
			prior assembly of DB table metadata. Dynamic metadata can be for
			example used for easy migration of data between two different
			databases when one universal graph with parameters specifying
			which table should be unload/migrated can be used. This graph
			requires db_table parameter to be defined. When running this
			graph, use command like this one: <TT>java -cp
			&quot;../cloveretl.engine.jar:../lib/commons-logging.jar:../lib/log4j-1.2.12.zip:../lib/javolution.jar:javaExamples
			&quot; org.jetel.main.runGraph -plugins
			../plugins-P:db_table=Employee graphDBUnloadUniversal.grf </TT>Note:
			where clause 1=0 in SQL query in dynamic metadata definition is
			there only for speeding up query processing - no real data is
			needed, only metadata describing the result - thus we specify
			condition which ensures that no data should really be returned -
			it is up to database whether it will optimize the execution plan
			based on this.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphDenormalizeInline.grf">graphDenormalizeInline.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph demonstrates functionality of DENORMALIZER component
			with denormalization specified by inline Java source.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphDenormalizeTL.grf">graphDenormalizeTL.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph demonstrates functionality of DENORMALIZER component
			with denormalization specified by inline <A HREF="../docs/CloverETL_transformation_language.odt">TransformLang</A>
			source.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphGenerateData.grf">graphGenerateData.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates usage of Data Generator, Reader, Writer
			components. It also shows how to use shift attribute on metadata.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphExtFilter.grf">graphExtFilter.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This illustrates usage of Filter and HashJoin components.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphExtFilter2.grf">graphExtFilter2.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph shows some more functionality of EXT_FILTER
			component. Filters all employees younger than 41 years. The
			current age is calculated as today's date minus date of birth.
			Notice that instead of classical comparison operators ==,!=,
			...etc... one can use their textual abbreviations .eq. .ne. .lt.
			.gt. ...etc...</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphFilter.grf">graphFilter.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph demonstrates functionality of Filter component. It
			can filter on text, date, integer, numeric fields with comparison
			[&gt;, &lt;, ==, &lt;=, &gt;=, !=]. Text fields can also be
			compared to a Java regexp using ~ (tilda) operator. A filter can
			be made of different parts separated by a &quot;;&quot;
			(semicolon). If one of the parts is verified, the record passes
			the filter (it's an OR combination of the parts, and AND can be
			achieved by several filters cascaded). Date format used for
			comparison depends on input field's format – e.g. if input field
			HireDate has defined date format &quot;yyyy-MM-dd&quot;, then the
			same format must be used in filter when specifying date constant.
			This graph produces two output files: First with all employees who
			were hired before 1993-12-31. Second with all employees who have
			in their memo that they are &quot;fluent&quot; in some language
			Note: some of the comparison operators have to be XML encoded -
			e.g. &quot;&gt;&quot; as &quot;&amp;gt;&quot; etc. 
			</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphIntersectData.grf">graphIntersectData.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph demonstrates functionality of DATA_INTERSECT
			component - performs joining of two sorted (based on specified
			key) data flows (A and B) and outputs: 1. to port 0 records found
			only in flow A 2. to port 1 records found in A &amp; B 3. to port
			2 records found only in flow B . Records both in flow A &amp;B
			should be unique</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphJms.grf">graphJms.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates usage of JMS Reader/Writer Components.
			It requires ACtiveMQ JMS server to be running on localhost!</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphJoinData.grf">graphJoinData.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph demonstrates functionality of SORT and MERGE_JOIN
			components. MERGE_JOIN component performs joining of master data
			with slave data based on specified key. It requires both master
			and slave data to be sorted according to used key. 
			</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphJoinHash.grf">graphJoinHash.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph demonstrates functionality of HASH_JOIN components.
			HASH_JOIN component performs joining of master data with slave
			data based on specified key. First all slave data (from all slave
			ports) are read and hash-tables are constructed from them. Then
			for every master record, attempt is made to find corresponding
			slave-records. HASH_JOIN performs better than SORT/MERGE_JOIN when
			you have relatively small slave data set and big master data set.
			It doesn't require master and slave data to be sorted.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphJoinHashInline.grf">graphJoinHashInline.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph demonstrates how to use HASH_JOIN component for 3way
			join. HASH_JOIN component performs joining of master data with
			slave data based on specified key. First all slave data are read
			and hash-tables are constructed from them. Then for every master
			record, attempt is made to find corresponding slave-records.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphJoinHashUsingTransform.grf">graphJoinHashUsingTransform.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph demonstrates functionality of HASH_JOIN components.
			Transformation function is written in compacted form.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphJoinHashUsingTransformLanguage.grf">graphJoinHashUsingTransformLanguage.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph demonstrates functionality of HASH_JOIN components.
			Transformation function is written in <A HREF="../docs/CloverETL_transformation_language.odt">Transform
			Language</A>,</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphJoinMergeInline.grf">graphJoinMergeInline.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates usage of MERGE component. It merges data
			based on specified key. It can merge master flow with a few slave
			flows.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphLdapReader_Uninett.grf">graphLdapReader_Uninett.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P><BR>
			</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphLdapReaderWriter.grf">graphLdapReaderWriter.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>Reads information from LDAP directory.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A NAME="graphLookupJoingrf"></A><A HREF="graphLookupJoin.grf">graphLookupJoin.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph joins data from file with data from lookup table. 
			</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphLookupReader.grf">graphLookupReader.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates usage of in-memory lookup table.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphMergeData.grf">graphMergeData.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates usage of MERGE component. It merges data
			based on specified key. 
			</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphMysqlWriter.grf">graphMysqlWriter.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates usage of MySQL Writer Component.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphNormalizeInline.grf">graphNormalizeInline.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph demonstrates functionality of NORMALIZER component
			with normalization specified by in-line Java source.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphNormalizeTL.grf">graphNormalizeTL.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph demonstrates functionality of NORMALIZER component
			with normalization specified by in-line <A HREF="../docs/CloverETL_transformation_language.odt">TransformLang</A>
			source.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A NAME="graphOrderReformat"></A><A HREF="graphOrdersReformat.grf">graphOrdersReformat.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This example illustrates usage of Reformat component. Source
			data contains info about orders customers made. We add artificial
			key - ProductID which is a sequence of integers. We also combine
			individual fields of ship-to-address (address,city,country) into
			one single field. Reformat component calls &quot;reformatOrders&quot;
			class which implements <A HREF="http://cloveretl.berlios.de/docs/JavaDoc/org/jetel/component/RecordTransform.html">RecordTransform
			interface</A> (required by Reformat component). The directory in
			which recormatOrders class exists must be part of the Java
			classpath</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphOrdersReformatInline.grf">graphOrdersReformatInline.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This example illustrates usage of Reformat component with
			transformation code (class) inlined (saved with the graph itself).
			The source code is automatically compiled at runtime. For
			successful compilation, tools.jar library must be part of
			CLASSPATH.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphOrdersReformatUsingTransform.grf">graphOrdersReformatUsingTransform.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This example illustrates usage of Reformat component with
			transformation written in compact form.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphOrdersTLReformat.grf">graphOrdersTLReformat.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This example illustrates usage of Reformat component with
			transformation written in <A HREF="../docs/CloverETL_transformation_language.odt">Transform
			Language</A>,</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphParametrizedLookup.grf">graphParametrizedLookup.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph demonstrates usage of Node-level parameters.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphPartition.grf">graphPartition.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph demonstrates functionality of Partition component.
			This component can be used to split input data flow into several
			(based on number of connected output ports) output data flows. 
			</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphPhasesDemo.grf">graphPhasesDemo.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates usage of several components in different
			phases. First, all components from phase 0 are run, then the
			execution continues with phase 1. Data which crosses phase
			boundary is automatically buffered so the data producing node can
			finish its work and the data consuming node can later start
			reading the data. 
			</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphRevenues.grf">graphRevenues.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This is practical illustration of usage CloverETL. This graph
			transforms data for branch bank. On inputs are clients, month
			interests and charges and half-year bonus. On outputs we have
			aggregated revenues by clients, clients without revenues and
			clients from database, who are not in input file.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphSequence.grf">graphSequence.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This example extends <A HREF="#graphOrderReformat">graphOrdersReformat</A>
			in a sense that the counter used for generating PRODUCTID is taken
			from Sequence object which is persistent between graph executions
			– i.e. you get continuous sequence of unique numbers. For
			successful compilation, tools.jar library must be part of
			CLASSPATH.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphSequenceCheckData.grf">graphSequenceCheckData.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates usage of Sequence Checker Component.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphSimpleCopy.grf">graphSimpleCopy.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph demonstrates functionality of SimpleCopy component.
			Everything brought to SimpleCopy on port 0 is duplicated onto all
			connected output ports. It also shows functionality of Trash
			Component. It discards everything which is sent into it. Its
			purpose is debugging - shows how many records ended in it and can
			print incoming records, if desired (option debugPrint)</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphSimpleCopyEmbeddedMetadata.grf">graphSimpleCopyEmbeddedMetadata.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph demonstrates functionality of SimpleCopy component.
			Everything brought to SimpleCopy on port 0 is duplicated onto all
			connected output ports. It also shows functionality of Trash
			Component. It discards everything which is sent into it. Its
			purpose is debugging - shows how many records ended in it and can
			print incoming records, if desired (option debugPrint). Metadata
			in this graph is embedded directly to graph instead of external
			file.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphSimpleCopyLocale.grf">graphSimpleCopyLocale.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph demonstrates functionality of SimpleCopy component.
			Everything brought to SimpleCopy on port 0 is duplicated onto all
			connected output ports. It also shows functionality of Trash
			Component. It discards everything which is sent into it. Its
			purpose is debugging - shows how many records ended in it and can
			print incoming records, if desired (option debugPrint). Metadata
			in this graph is embedded directly to graph instead of external
			file. Output metadata is the same as input except that for
			BirthDate and HireDate, locale property is defined. It allows to
			specify language or language.Country locale which is used when
			formatting output. In this example, date info on input is expected
			to be in dd/MM/yyyy format, whereas on output it should follow
			US/UK standard -&gt; (usually defined as MM/dd/YYYY).</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphSimpleLookup.grf">graphSimpleLookup.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates how to join data using reformat
			component.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphSortData.grf">graphSortData.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates usage of Sort component. It sorts data
			based on specified key. 
			</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphSortUniversal.grf">graphSortUniversal.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph illustrates usage of Sort component. It sorts data
			based on specified key. It also shows how to use parameters/global
			properties within graph. For executing see <A HREF="#Sort Universal example|outline">Sort
			Universal example.</A></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphSystemExecute.grf">graphSystemExecute.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph ilustrates usage of System Ececute Component</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphViewData.grf">graphViewData.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>This graph is a simple utility which demonstrates usage of
			parameters. It allows viewing content of particular data file (in
			delimited format). It reads in data and stores them in &quot;debug&quot;
			format.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphXLSReadWrite.grf">graphXLSReadWrite.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>In this example data are read from <TT>ORDERS.xls</TT> file,
			partitioned to 3 parts and each of thees parts are saved in
			<TT>orders.partitioned.xls</TT> file in different sheets. 
			</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=25%>
			<P><A HREF="graphXMLExtract.grf">graphXMLExtract.grf</A></P>
		</TD>
		<TD WIDTH=75%>
			<P>In this example data are read from <TT>employees.xml </TT>file.
			“Mapping” attribute describes dependencies between xml nodes
			and metadata fields. 
			</P>
		</TD>
	</TR>
</TABLE>
<P><BR><BR>
</P>
</BODY>
</HTML>