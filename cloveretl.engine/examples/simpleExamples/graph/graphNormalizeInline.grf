<?xml version="1.0" encoding="UTF-8"?>
<Graph author="avackova" created="Wed Mar 07 09:01:26 CET 2007" description="This graph demonstrates functionality of DENORMALIZER component with denormalization specified by inline Java source." guiVersion="2.9.1" id="1204548969094" licenseCode="javlinconsulting" licenseType="Commercial Pro" modified="Fri Feb 26 14:04:07 CET 2010" modifiedBy="cloveruser" name="Testing NORMALIZER" revision="1.32">
<Global>
<Metadata id="Metadata0" previewAttachmentCharset="ISO-8859-1">
<Record fieldDelimiter="|" name="customers" previewAttachmentCharset="ISO-8859-1" recordDelimiter="\n" type="delimited">
<Field name="number_of_customers" type="integer">
<attr name="description"><![CDATA[This field contains number of customers, that are listed in 'customers' field.]]></attr>
</Field>
<Field name="customers" type="string"/>
<Field name="EmployeeID" type="integer"/>
</Record>
</Metadata>
<Property fileURL="workspace.prm" id="GraphParameter0"/>
<Note alignment="1" backgroundColorB="225" backgroundColorG="255" backgroundColorR="255" folded="false" height="338" id="Note0" textColorB="0" textColorG="0" textColorR="0" textFontSize="8" title="Use of the Normalizer Component (Java)" titleColorB="0" titleColorG="0" titleColorR="0" titleFontSize="10" width="472" x="37" y="143">
<attr name="text"><![CDATA[
Graph demonstrates the use of Normalizer. Received records contain a field named "customers". Its values are strings consisting of substrings, white spaces and hyphens.

Component splits the field into several substrings without white spaces and hyphens and counts the number of such substrings. This is performed by the count() function. The count of substrings is returned by the function

In the transform() function, which is called multiple times (number of calls of the function equals to the number returned by the count() function for the input record), new output records are created. These get the substrings and assign them to one of the output fields. 

Thus, this component creates one or more output records based on one input record.

Before processing next input record, the clean() function returns variables into intitial state.

Transformation is written in Java directly in the graph. It can be seen in the Source tab. It is compiled on runtime.
]]></attr>
</Note>
</Global>
<Phase number="0">
<Node enabled="enabled" fileURL="${DATAIN_DIR}/delimited/customers.txt" guiHeight="25" guiName="INPUT1" guiWidth="50" guiX="20" guiY="20" id="INPUT1" type="DATA_READER">
<attr name="DataPolicy"><![CDATA[Strict]]></attr>
</Node>
<Node enabled="enabled" guiHeight="25" guiName="NORMALIZER" guiWidth="50" guiX="195" guiY="20" id="NORMALIZE" type="NORMALIZER">
<attr name="normalize"><![CDATA[
import org.jetel.component.normalize.DataRecordNormalize;
import org.jetel.data.*;

public class NormalizeTestInline extends DataRecordNormalize {

	String[] customers;
    int recNo;

	//As we know that first field is just a number of customers
	//(= number of records after normalization), we return its value
	//More over we check if above is true
	public int count(DataRecord source) {
		customers = source.getField(1).toString().split("\\s*-\\s*");
		recNo = (Integer)source.getField(0).getValue();
		if (customers.length != recNo){
			errorMessage = "Invalid input record";
			return SKIP;
		}
		return recNo;
	}

	public int transform(DataRecord source, DataRecord target, int idx) {
		target.getField(1).setValue(customers[idx]);
		target.getField(2).setValue(source.getField(2).getValue());
		return OK;
	}
}
]]></attr>
</Node>
<Node append="false" enabled="enabled" fileURL="${DATAOUT_DIR}/normalized.out" guiHeight="25" guiName="WRITER" guiWidth="50" guiX="370" guiY="20" id="WRITER" type="DATA_WRITER"/>
<Edge debugMode="true" fromNode="INPUT1:0" guiBendpoints="" id="INEDGE1" inPort="Port 0 (in)" metadata="Metadata0" outPort="Port 0 (output)" toNode="NORMALIZE:0"/>
<Edge debugMode="true" fromNode="NORMALIZE:0" guiBendpoints="" id="OUTEDGE" inPort="Port 0 (in)" metadata="Metadata0" outPort="Port 0 (out)" toNode="WRITER:0"/>
</Phase>
</Graph>
