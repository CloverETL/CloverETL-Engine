/*
*    jETeL/Clover - Java based ETL application framework.
*    Copyright (C) 2005-06  Javlin Consulting <info@javlinconsulting.cz>
*    
*    This library is free software; you can redistribute it and/or
*    modify it under the terms of the GNU Lesser General Public
*    License as published by the Free Software Foundation; either
*    version 2.1 of the License, or (at your option) any later version.
*    
*    This library is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    
*    Lesser General Public License for more details.
*    
*    You should have received a copy of the GNU Lesser General Public
*    License along with this library; if not, write to the Free Software
*    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*/

package org.jetel.connection.jdbc;

import java.sql.BatchUpdateException;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.StringTokenizer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.logging.Log;
import org.jetel.connection.jdbc.QueryAnalyzer.QueryType;
import org.jetel.connection.jdbc.specific.DBConnectionInstance;
import org.jetel.connection.jdbc.specific.JdbcSpecific.AutoGeneratedKeysType;
import org.jetel.data.DataRecord;
import org.jetel.exception.ComponentNotReadyException;
import org.jetel.exception.JetelException;
import org.jetel.util.string.StringUtils;

/**
 * This class represents prepared statement with CopySQLData[] object prepared to work with concrete record.
 * It can work with queries in internal clover format or with queries with place holders [?]:
 * <ul><li><i>insert into mytable [(f1,f2,...,fn)] values (val1, $field2, ...,$fieldm ) returning $key := dbfield1, $field := dbfield2</i> 
 * or <i>insert into mytable [(f1,f2,...,fn)] values (val1, $field2, ...,$fieldm ) returning $key := auto_generated, $field := infield</i> 
 * <ul><li>$field2, ...,$fieldm are interpreted as input record's fields</li>
 * <li>$key, $field are interpreted as output record's fields</li>
 * <li>fields on assignments right sides in <i>where</i> clause are interpreted as database or clover fields depending on database type 
 * ({@link org.jetel.component.DBOutputTable} and {@link org.jetel.connection.jdbc.AutoKeyGenerator})</li></ul></li>
 * <li><i>update mytable set dbField1 = $f1 where dbField2=$f2 returning $update:=update_count, $field:=infield</i> or
 * <i>delete from mytable where dbField = $f1 returning $update:=update_count, $field:=infield</i>
 *  <ul><li>$f1, $f2 , infield are interpreted as input record's fields</li>
 * <li>$update, $field are interpreted as output record's fields</li>
 * <li> field on which is mapped <i>update_count</i> is filled by number of records updated in database by current query</li></ul></li>
 * <li><i>insert into mytable [(f1,f2,...,fn)] values (val1, ?, ...,? )</i> or <i>update mytable set dbField1 = ? where dbField2=?</i>
 * <ul><li>needs to set <i>cloverFields</i> and <i>dbFields</i>, eg. <i>cloverFields={field2, ...,fieldm}</i> or 
 * <i>cloverFields={f1, f2}</i> and <i>dbFields={f1,f2,...,fn}</i> or <i>dbFields={dbField1, dbField2}</i> respectively</li>
 * <li>can be set <i>autoGeneratedColumns</i>, eg. <i>{dbField1, .., dbFieldN}</i></li></ul></li></ul>
 * 
 * @author avackova (agata.vackova@javlinconsulting.cz) ; 
 * (c) JavlinConsulting s.r.o.
 *  www.javlinconsulting.cz
 *
 * @since Nov 2, 2007
 *
 */
//Doesn't work on select query yet!!!!
public class SQLCloverStatement {
	
	public final static String UPDATE_NUMBER_FIELD_NAME = "UPDATE_COUNT";
	
	private QueryAnalyzer analyzer;
	private String query;
	private DBConnectionInstance connection;
	private PreparedStatement preparedStatement;
	private CopySQLData[] transMap;
	private String[] cloverFields;
	private String[] dbFields;
	private String[] autoGeneratedColumn;
	private int[] autoGeneratedColumnNumber;
	private String[] autoGeneratedColumnToClover;
	private int[] autoGeneratedColumnToCloverNumber;
	private DataRecord record;
	private List<DataRecord> outRecords = new ArrayList<DataRecord>();
	DataRecord tmpRecord;
	
	private AutoKeyGenerator autoKeyGenerator;
	private ResultSet generatedKeys;
	
	private String updatedNumberCloverFieldName;
	private Integer updatedNumberCloverFieldNumber = -1;
	
	private String tableName;
	private Log logger;
	private boolean returnResult;
	
	private final static Pattern TABLE_NAME_PATTERN = Pattern.compile(
			"(?:from|into|update)\\s+" + SQLUtil.DB_FIELD_PATTERN, Pattern.CASE_INSENSITIVE);
	
	/**
	 * Constructor for sql query containing db - clover mapping
	 * @see QueryAnalyzer
	 * 
	 * @param connection connection to db
	 * @param query sql query
	 * @param record record which will be filled by results from executing query
	 */
	public SQLCloverStatement(DBConnectionInstance connection, String query, DataRecord record){
		this.connection = connection;
		analyzer = new QueryAnalyzer(query);
		this.record = record;
		returnResult = query.toLowerCase().contains(QueryAnalyzer.RETURNING_KEY_WORD);
	}
	
	/**
	 * Constructor for sql query containing question marks
	 * 
	 * @param connection connection to db
	 * @param query sql query
	 * @param record record which will be filled by results from executing above query
	 * @param cloverFields clover fields to populate 
	 * @param dbFields database fields
	 * 
	 * @see org.jetel.component.DBOutputTable
	 */
	public SQLCloverStatement(DBConnectionInstance connection, String query, DataRecord record, 
			String[] cloverFields, String[] dbFields){
		this(connection, query, record);
		this.cloverFields = cloverFields;
		this.dbFields = dbFields;
	}

	/**
	 * Constructor for sql query containing question marks
	 * 
	 * @param connection connection to db
	 * @param query sql query
	 * @param record record which will be filled by results from executing above query
	 * @param cloverFields clover fields to populate 
	 * @param dbFields database fields
	 * @param autoGeneratedColumns auto generated columns to be returned
	 */
	public SQLCloverStatement(DBConnectionInstance connection, String query, DataRecord record, 
			String[] cloverFields, String[] dbFields, String[] autoGeneratedColumns){
		this(connection, query, record, cloverFields, dbFields);
		this.autoGeneratedColumn = autoGeneratedColumns;
		returnResult = autoGeneratedColumns != null && autoGeneratedColumns.length > 0;
	}
	
	/**
	 * Prepares statement for database and transMap for result set and data record
	 * 
	 * @return true if successful, false if not 
	 * @throws SQLException
	 * @throws JetelException 
	 * @throws ComponentNotReadyException
	 */
	public void prepareUpdateStatement() throws SQLException, ComponentNotReadyException, JetelException{
		//get query in form acceptable for PreparedStatement
		if (getQueryType() == QueryType.INSERT) {
			query = analyzer.getInsertQuery();
		}else{
			query = analyzer.getUpdateDeleteQuery();
		}
		List<String[]> dbCloverMap = analyzer.getDbCloverFieldMap();
		if (cloverFields == null && dbFields == null) {
			List<String> cFields = new ArrayList<String>(dbCloverMap.size());
			List<String> dFields = new ArrayList<String>(dbCloverMap.size());
			for (Iterator iterator = dbCloverMap.iterator(); iterator.hasNext();) {
				String[] mapping = (String[]) iterator.next();
				if (mapping[1] != null){//some dbFields can be mapped to constant
					cFields.add(mapping[1]);
					dFields.add(mapping[0]);
				}
				
			}
			cloverFields = cFields.toArray(new String[0]);
			dbFields = dFields.toArray(new String[0]);
		}else if (cloverFields !=null && dbFields != null) {//maybe we have to change order due to order in query
			if (dbCloverMap.size() > 0) {
				List<String> cFields = new ArrayList<String>(dbCloverMap.size());
				List<String> dFields = new ArrayList<String>(dbCloverMap.size());
				int index;
				String dbField;
				for (int i = 0; i < dbCloverMap.size(); i++) {
					dbField = dbCloverMap.get(i)[0];
					index = StringUtils.findString(dbField, dbFields);
					if (index > -1) {
						dFields.add(dbField);
						cFields.add(cloverFields[index]);
					}
				}
				cloverFields = cFields.toArray(new String[0]);
				dbFields = dFields.toArray(new String[0]);
			}else{//we don't have db fields from query --> get them from table
				String[] dFields = SQLUtil.getColumnNames(connection.getSqlConnection(), analyzer.getTable());
				String[] dFields1 = new String[dbFields.length];
				System.arraycopy(dbFields, 0, dFields1, 0, dbFields.length);
				String[] cFields = new String[cloverFields.length]; 
				System.arraycopy(cloverFields, 0, cFields, 0, cloverFields.length);
				if (dFields.length != cloverFields.length) {
					throw new ComponentNotReadyException("Different number of db fields (" + dFields.length + 
							") and clover fields (" + cFields.length + ")!!!");
				}
				int index;
				for (int i = 0; i < dFields.length; i++) {
					index = StringUtils.findString(dFields[i], dFields1);
					dbFields[i] = dFields1[index];
					cloverFields[i] = cFields[index];
				}
			}
		}
		List<Integer> dbFieldTypes;
		if (cloverFields != null && cloverFields.length > 0) {
			dbFieldTypes= SQLUtil.getFieldTypes(record.getMetadata(), cloverFields, connection.getJdbcSpecific());
		} else {
			dbFieldTypes= SQLUtil.getFieldTypes(record.getMetadata(), connection.getJdbcSpecific());
		}
		//prepare trans map
		if (cloverFields != null && cloverFields.length > 0) {
			transMap = CopySQLData.jetel2sqlTransMap(dbFieldTypes, record, cloverFields);
		} else {
			transMap = CopySQLData.jetel2sqlTransMap(dbFieldTypes, record);
		}
		//get auto generated columns from query
		if (autoGeneratedColumn == null) {
			List<String[]> cloverDbMap = analyzer.getCloverDbFieldMap();
			if (cloverDbMap.size() > 0) {
				List<String> cFields = new ArrayList<String>(cloverDbMap.size());
				List<String> dFields = new ArrayList<String>(cloverDbMap.size());
				for (Iterator iterator = cloverDbMap.iterator(); iterator.hasNext();) {
					String[] mapping = (String[]) iterator.next();
					if (mapping[0] != null && mapping[1] != null){
						if (mapping[1].equalsIgnoreCase(UPDATE_NUMBER_FIELD_NAME)) {
							updatedNumberCloverFieldName = mapping[0];
							continue;
						}
						cFields.add(mapping[0]);
						dFields.add(mapping[1]);
					}
				}
				autoGeneratedColumn = dFields.toArray(new String[dFields.size()]);
				autoGeneratedColumnToClover = cFields.toArray(new String[cFields.size()]);
			}
		}
		//create sql statement
		if (getQueryType() == QueryType.INSERT) {//with AutoKeyGenerator for insert query
			autoKeyGenerator = new AutoKeyGenerator(connection, query, autoGeneratedColumn);
			autoKeyGenerator.setLogger(logger);
			autoKeyGenerator.setFillFields(autoGeneratedColumnToClover);
			preparedStatement = autoKeyGenerator.prepareStatement();
		}else{//from connection for UPDATE, DELETE query
			preparedStatement = connection.getSqlConnection().prepareStatement(query);
		}
	}
	
	/**
	 * Resets this object. For complete reset method setInRecord must be called too.
	 * 
	 * @throws SQLException
	 */
	public void reset() throws SQLException{
		if (autoKeyGenerator != null) {
			preparedStatement = autoKeyGenerator.reset();
		}else{
			preparedStatement.close();
			preparedStatement = connection.getSqlConnection().prepareStatement(query);
		}
	}
	
	public void setInRecord(DataRecord inRecord) {
		this.record = inRecord;
		CopySQLData.resetDataRecord(transMap, record);
	}
	
	/**
	 * Fills prepared statements with data obtained from input record and executes update on database.
	 * If argument is not null sets on requested field number of updated records and  fills its requested fields from input record
	 * 
	 * @return
	 * @throws SQLException
	 */
	public int executeUpdate(DataRecord outRecord) throws SQLException{
		//fill trans map
		for (int i = 0; i < transMap.length; i++) {
			transMap[i].jetel2sql(preparedStatement);
		}
		//execute query
		int updatedRecords = preparedStatement.executeUpdate();
		//fill output record
		switch (getQueryType()) {
		case INSERT:
			fillKeyRecord(outRecord);
			break;
		case UPDATE:
		case DELETE:
			if (outRecord != null) {
				if (autoGeneratedColumnNumber == null) {//first call 
					prepareMapping(outRecord);
				}
				if (updatedNumberCloverFieldNumber != -1) {
					outRecord.getField(updatedNumberCloverFieldNumber).setValue(updatedRecords);
				}
				for (int i = 0; i < autoGeneratedColumn.length; i++) {
					outRecord.getField(autoGeneratedColumnToCloverNumber[i]).setValue(record.getField(autoGeneratedColumnNumber[i]));
				}
			}
			break;
		}
		return updatedRecords;
	}
	
	/**
	 * Initializes fields numbers arrays due to names
	 * 
	 * @param outRecord
	 */
	private void prepareMapping(DataRecord outRecord){
		//if we don't want to get anything back create empty arrays to not get NPE
		if (autoGeneratedColumn == null) {
			autoGeneratedColumn = new String[0];
		}
		if (autoGeneratedColumnToClover == null){
			autoGeneratedColumnToClover = new String[0];
		}
		//if autogenerated columns were set in constructor (not from query) we have to get output fields names from the record
		if (updatedNumberCloverFieldName == null) {
			ArrayList<String> inFields = new ArrayList<String>(Math.max(autoGeneratedColumn.length - 1,0));
			ArrayList<String> outFields = new ArrayList<String>(Math.max(autoGeneratedColumn.length - 1,0));
			for (int i = 0; i < autoGeneratedColumn.length; i++) {
				if (autoGeneratedColumn[i].equalsIgnoreCase(UPDATE_NUMBER_FIELD_NAME)) {
					updatedNumberCloverFieldName = outRecord.getField(i).getMetadata().getName();
				}else{
					inFields.add(autoGeneratedColumn[i]);
					outFields.add(outRecord.getField(i).getMetadata().getName());
				}
			}
			autoGeneratedColumn = inFields.toArray(new String[inFields.size()]);
			autoGeneratedColumnToClover = outFields.toArray(new String[outFields.size()]);
		}
		//prepare numbers from names
		updatedNumberCloverFieldNumber = outRecord.getMetadata().getFieldPosition(updatedNumberCloverFieldName);
		autoGeneratedColumnNumber = new int[autoGeneratedColumn.length];
		autoGeneratedColumnToCloverNumber = new int[autoGeneratedColumnToClover.length];
		for (int i = 0; i < autoGeneratedColumn.length; i++) {
			autoGeneratedColumnNumber[i] = record.getMetadata().getFieldPosition(autoGeneratedColumn[i]);
			autoGeneratedColumnToCloverNumber[i] = outRecord.getMetadata().getFieldPosition(autoGeneratedColumnToClover[i]);
		}
	}
	
	/**
	 * Adds set of parameters to batch and prepares output record from input record
	 * 
	 * @throws SQLException
	 */
	public void addBatch(DataRecord outRecord) throws SQLException{
		//fill trans map
		for (int i = 0; i < transMap.length; i++) {
			transMap[i].jetel2sql(preparedStatement);
		}
		//add statement to batch
		preparedStatement.addBatch();
		//prepare output record from input record
		if (outRecord != null) {
			if (autoGeneratedColumnNumber == null) {//first call 
				prepareMapping(outRecord);
			}
			tmpRecord = outRecord.duplicate();
			for (int i = 0; i < autoGeneratedColumnToClover.length; i++) {
				tmpRecord.getField(autoGeneratedColumnToCloverNumber[i]).setValue(record.getField(autoGeneratedColumnNumber[i]));
			}
			outRecords.add(tmpRecord);
		}
	}
	
	/**
	 * Submits a batch of commands to the database for execution and if all commands execute successfully, returns an 
	 * array of update counts. Fills stored records with number of updated records in database.
	 * 
	 * @return an array of update counts containing one element for each command in the batch. The elements of the 
	 * array are ordered according to the order in which commands were added to the batch.
	 * @throws SQLException
	 */
	public int[] executeBatch() throws SQLException{
		int[] updatedRecords = null;
		BatchUpdateException ex = null;
		try {
			updatedRecords = preparedStatement.executeBatch();
		} catch (BatchUpdateException e) {
			updatedRecords = e.getUpdateCounts();
			ex = e;
		}
		for (int i = 0; i < outRecords.size(); i++) {
			outRecords.get(i).getField(updatedNumberCloverFieldNumber).setValue(updatedRecords[i]);
		}
		if (ex != null) throw ex;
		return updatedRecords;
	}
	
	/**
	 * @return updated records stored by addBatch(DataRecord) method 
	 */
	public DataRecord[] getBatchResult(){
		return outRecords.toArray(new DataRecord[outRecords.size()]);
	}
	/**
	 * Empties this Statement object's current list of SQL commands. Removes all stored records.
	 * 
	 * @throws SQLException
	 */
	public void clearBatch() throws SQLException{
		preparedStatement.clearBatch();
		outRecords.clear();
	}
	 
	/**
	 * Fills record by data received from database by calling getGeneratedKeys() method
	 * 
	 * @param keyRecord record to fill 
	 * @throws SQLException
	 */
	private void fillKeyRecord(DataRecord keyRecord) throws SQLException{
		if (autoKeyGenerator == null) {
			return;
		}
		if (autoKeyGenerator.getAutoKeyType() == AutoGeneratedKeysType.NONE) {
			return;
		}
		
		generatedKeys = preparedStatement.getGeneratedKeys();
		if (generatedKeys.next()) {
			autoKeyGenerator.fillKeyRecord(record, keyRecord, generatedKeys);
		}					
	}
	
	/**
	 * @param batchUpdate
	 */
	public void setBatchUpdate(boolean batchUpdate){
        CopySQLData.setBatchUpdate(transMap,batchUpdate);
	}
	
	/**
	 * Releases this Statement object's database and JDBC resources immediately instead of waiting for this to happen 
	 * when it is automatically closed.
	 * 
	 * @throws SQLException
	 */
	public void close() throws SQLException{
		if (preparedStatement != null) {
			preparedStatement.close();
		}
	}
	
	/**
	 * @return underlying PreparedStatement object
	 */
	public PreparedStatement getStatement(){
		return preparedStatement;
	}

	/**
	 * @return sql query
	 */
	public String getQuery(){
		return query;
	}
	
	/**
	 * @return sql query as has been set by user
	 */
	public String getQuerySource(){
		return analyzer != null ? analyzer.getSource() : query;
	}
	
	/**
	 * @return logger
	 */
	public Log getLogger() {
		return logger;
	}

	/**
	 * Sets logger
	 * 
	 * @param logger
	 */
	public void setLogger(Log logger) {
		this.logger = logger;
	}

	/**
	 * @return table name from query
	 */
	public String getTableName() {
		if (tableName != null) {
			return tableName;
		}else{
			Matcher matcher = TABLE_NAME_PATTERN.matcher(query);
			if (matcher.find()) {
				tableName = matcher.group(1);
			}
		}
		return tableName;
	}

	/**
	 * Sets table name
	 * 
	 * @param tableName
	 */
	public void setTableName(String tableName) {
		this.tableName = tableName;
	}

	public QueryType getQueryType() {
		return analyzer.getQueryType();
	}

	/**
	 * @return <b>true<b> if and only if query is to return some values (<i>returning</i> clause or exist some autogenereted columns)
	 */
	public boolean returnResult() {
		return returnResult;
	}
	
}


