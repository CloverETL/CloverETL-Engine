/*
*    jETeL/Clover - Java based ETL application framework.
*    Copyright (C) 2005-06  Javlin Consulting <info@javlinconsulting.cz>
*    
*    This library is free software; you can redistribute it and/or
*    modify it under the terms of the GNU Lesser General Public
*    License as published by the Free Software Foundation; either
*    version 2.1 of the License, or (at your option) any later version.
*    
*    This library is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    
*    Lesser General Public License for more details.
*    
*    You should have received a copy of the GNU Lesser General Public
*    License along with this library; if not, write to the Free Software
*    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*/

package org.jetel.connection;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.logging.Log;
import org.jetel.data.DataField;
import org.jetel.data.DataRecord;
import org.jetel.data.RecordKey;
import org.jetel.exception.JetelException;
import org.jetel.util.DuplicateKeyMap;
import org.jetel.util.StringUtils;

/**
 * This class is prepared statement with CopySQLData[] object prepared to work with concrete record.
 * 
 * @author avackova (agata.vackova@javlinconsulting.cz) ; 
 * (c) JavlinConsulting s.r.o.
 *  www.javlinconsulting.cz
 *
 * @since Nov 2, 2007
 *
 */
//Doesn't work on select query yet!!!!
public class SqlJetelStatement {
	
	private QueryAnalyzer analyzer;
	private String query;
	private DBConnection connection;
	private PreparedStatement preparedStatement;
	private CopySQLData[] transMap;
	private String[] cloverFields;
	private String[] dbFields;
	private String[] autoGeneratedColumn;
	private String[] autoGeneratedColumnToClover;
	private DataRecord record;
	
	private AutoKeyGenerator autoKeyGenerator;
	private ResultSet generatedKeys;
	
	private String tableName;
	private Log logger;
	
	private final static String INSERT_KEY_WORD = "insert";
	
	private final static Pattern TABLE_NAME_PATTERN = Pattern.compile("(?:from|into|update)\\s+(\\w+)", Pattern.CASE_INSENSITIVE);
	
	/**
	 * Constructor for sql query containing db - clover mapping
	 * @see QueryAnalyzer
	 * 
	 * @param connection connection to db
	 * @param query sql query
	 * @param record record which will be filled by results from executing above query
	 */
	public SqlJetelStatement(DBConnection connection, String query, DataRecord record){
		this.connection = connection;
		analyzer = new QueryAnalyzer(query);
		this.record = record;
	}
	
	/**
	 * Constructor for sql query containing question marks
	 * 
	 * @param connection connection to db
	 * @param query sql query
	 * @param record record which will be filled by results from executing above query
	 * @param cloverFields clover fields to populate 
	 * @param dbFields database fields
	 * 
	 * @see org.jetel.component.DBOutputTable
	 */
	public SqlJetelStatement(DBConnection connection, String query, DataRecord record, String[] cloverFields, 
			String[] dbFields){
		this.connection = connection;
		this.query = query;
		this.record = record;
		this.cloverFields = cloverFields;
		this.dbFields = dbFields;
	}

	/**
	 * Constructor for sql query containing question marks
	 * 
	 * @param connection connection to db
	 * @param query sql query
	 * @param record record which will be filled by results from executing above query
	 * @param cloverFields clover fields to populate 
	 * @param dbFields database fields
	 * @param autoGeneratedColumns auto generated columns to be returned
	 */
	public SqlJetelStatement(DBConnection connection, String query, DataRecord record, String[] cloverFields, 
			String[] dbFields, String[] autoGeneratedColumns){
		this(connection, query, record, cloverFields, dbFields);
		this.autoGeneratedColumn = autoGeneratedColumns;
	}
	
	/**
	 * Prepares statement for database and transMap for result set and data record
	 * 
	 * @return true if successful, false if not 
	 * @throws SQLException
	 * @throws JetelException
	 */
	public boolean prepareUpdateStatement() throws SQLException, JetelException{
		//get query in form acceptable for PreparedStatement
		if (analyzer != null && cloverFields == null && dbFields == null) {
			if (analyzer.getSource().trim().toLowerCase().startsWith(INSERT_KEY_WORD)) {
				query = analyzer.getInsertQuery();
			}else{
				query = analyzer.getNotInsertQuery();
			}
			DuplicateKeyMap fieldMap = analyzer.getDbCloverFieldMap();
			dbFields = (String[])fieldMap.keySet().toArray(new String[fieldMap.keySet().size()]);
			cloverFields = (String[]) fieldMap.values().toArray(new String[fieldMap.values().size()]);
		}
		List<Integer> dbFieldTypes;
		if (tableName != null) {
			if (dbFields != null) {
				dbFieldTypes = SQLUtil.getFieldTypes(connection.getConnection().getMetaData(), tableName, dbFields);
			}else{
				dbFieldTypes = SQLUtil.getFieldTypes(connection.getConnection().getMetaData(), tableName);
			}
		}else{
			if (cloverFields != null) {
				dbFieldTypes= SQLUtil.getFieldTypes(record.getMetadata(),cloverFields);
			} else {
				dbFieldTypes= SQLUtil.getFieldTypes(record.getMetadata());
			}
		}
		//prepare trans map
		if (cloverFields != null) {
			transMap = CopySQLData.jetel2sqlTransMap(dbFieldTypes, record, cloverFields);
		} else {
			transMap = CopySQLData.jetel2sqlTransMap(dbFieldTypes, record);
		}
		//get auto generated columns from query
		if (analyzer != null) {
			HashMap<String, String> cloverDbMap = analyzer.getCloverDbFieldMap();
			if (cloverDbMap.size() > 0) {
				autoGeneratedColumn = (String[]) cloverDbMap.values().toArray(new String[cloverDbMap.values().size()]);
				autoGeneratedColumnToClover = (String[]) cloverDbMap.keySet().toArray(new String[cloverDbMap.keySet().size()]);
			}
		}
		//create sql statement
		if (autoGeneratedColumn != null) {
			String database = connection.getConnection().getMetaData().getDatabaseProductName().toLowerCase();
			if (MultiAutoKeySupported.isSupported(database)) {
				autoKeyGenerator = new MultiAutoKeyGenerator(connection, query, autoGeneratedColumn);
			} else if (SingleAutoKeySupported.isSupported(database)) {
				autoKeyGenerator = new SingleAutoKeyGenerator(connection, query, autoGeneratedColumn);
			} else {
				logger.warn("Getting generated keys not supported for " + 
						connection.getConnection().getMetaData().getDatabaseProductName() + " -> switching it off !");
				autoKeyGenerator = new AutoKeyGenerator(connection, query, autoGeneratedColumn);
			}
		}else{
			autoKeyGenerator = new AutoKeyGenerator(connection, query, null);
		}
		autoKeyGenerator.setLogger(logger);
		autoKeyGenerator.setFillFields(autoGeneratedColumnToClover);
		preparedStatement = autoKeyGenerator.prepareStatement();
		
		return autoKeyGenerator.isStatementCreatedSuccessfully();
	}
	
	/**
	 * Fills prepared statements with data obtained from input record and executes update on database
	 * 
	 * @return
	 * @throws SQLException
	 */
	public int executeUpdate() throws SQLException{
		for (int i = 0; i < transMap.length; i++) {
			transMap[i].jetel2sql(preparedStatement);
		}
		return preparedStatement.executeUpdate();
	}
	
	/**
	 * Adds set of parameters to batch
	 * 
	 * @throws SQLException
	 */
	public void addBatch() throws SQLException{
		for (int i = 0; i < transMap.length; i++) {
			transMap[i].jetel2sql(preparedStatement);
		}
		preparedStatement.addBatch();
	}
	
	/**
	 * Submits a batch of commands to the database for execution and if all commands execute successfully, returns an 
	 * array of update counts.
	 * 
	 * @return an array of update counts containing one element for each command in the batch. The elements of the 
	 * array are ordered according to the order in which commands were added to the batch.
	 * @throws SQLException
	 */
	public int[] executeBatch() throws SQLException{
		return preparedStatement.executeBatch();
	}
	
	/**
	 * Empties this Statement object's current list of SQL commands.
	 * 
	 * @throws SQLException
	 */
	public void clearBatch() throws SQLException{
		preparedStatement.clearBatch();
	}
	 
	/**
	 * Fills record by data received from database by calling getGeneratedKeys() method
	 * 
	 * @param keyRecord record to fill 
	 * @throws SQLException
	 */
	public void fillKeyRecord(DataRecord keyRecord) throws SQLException{
		if (!(autoKeyGenerator instanceof MultiAutoKeyGenerator || autoKeyGenerator instanceof SingleAutoKeyGenerator) ||
				!autoKeyGenerator.statementCreatedSuccessfully) {
			return;
		}
		
		generatedKeys = preparedStatement.getGeneratedKeys();
		if (generatedKeys.next()) {
			autoKeyGenerator.fillKeyRecord(record, keyRecord, generatedKeys);
		}					
	}
	
	/**
	 * @param batchUpdate
	 */
	public void setBatchUpdate(boolean batchUpdate){
        CopySQLData.setBatchUpdate(transMap,batchUpdate);
	}
	
	/**
	 * Releases this Statement object's database and JDBC resources immediately instead of waiting for this to happen 
	 * when it is automatically closed.
	 * 
	 * @throws SQLException
	 */
	public void close() throws SQLException{
		if (preparedStatement != null) {
			preparedStatement.close();
		}
	}
	
	/**
	 * @return underlying PreparedStatement object
	 */
	public PreparedStatement getStatement(){
		return preparedStatement;
	}

	/**
	 * @return sql query
	 */
	public String getQuery(){
		return query;
	}
	
	/**
	 * @return sql query as has been set by user
	 */
	public String getQuerySource(){
		return analyzer != null ? analyzer.getSource() : query;
	}
	
	/**
	 * @return logger
	 */
	public Log getLogger() {
		return logger;
	}

	/**
	 * Sets logger
	 * 
	 * @param logger
	 */
	public void setLogger(Log logger) {
		this.logger = logger;
	}

	/**
	 * @return table name from query
	 */
	public String getTableName() {
		if (tableName != null) {
			return tableName;
		}else{
			Matcher matcher = TABLE_NAME_PATTERN.matcher(query);
			if (matcher.find()) {
				tableName = matcher.group(1);
			}
		}
		return tableName;
	}

	/**
	 * Sets table name
	 * 
	 * @param tableName
	 */
	public void setTableName(String tableName) {
		this.tableName = tableName;
	}
	
}

/**
 * Private class for filling output record by keys got from database.
 * This base class prepares PreparedStatement exactly as in sql query
 * and does nothing with key record. Descendants of this class  have to overide
 * prepareStatement() and fillKeyRecord(DataRecord, DataRecord, ResultSet) methods.
	 * 
 * @author avackova (agata.vackova@javlinconsulting.cz) ; 
 * (c) JavlinConsulting s.r.o.
 *  www.javlinconsulting.cz
 *
 * @since Jun 13, 2007
 *
 */
class AutoKeyGenerator{
	
	protected DBConnection connection;
	protected String sqlQuery;
	protected String[] columns;
	protected String[] fillFields;
	protected Log logger;
	protected boolean statementCreatedSuccessfully = true;

	public final static String AUTOGENERATED_FIELD_NAME = "AUTO_GENERATED";

	/**
	 * @param connection connection to database
	 * @param sqlQuery sql query
	 * @param columns list of columns to return
	 */
	AutoKeyGenerator(DBConnection connection, String sqlQuery, String[] columns) {
		this.connection = connection;
		this.sqlQuery = sqlQuery;
		this.columns = columns;
	} 
	
	/**
	 * Prepares statement from which autogeneratedKeys will be taken.
	 * 
	 * @return
	 * @throws SQLException
	 */
	public PreparedStatement prepareStatement() throws SQLException{
		return connection.prepareStatement(sqlQuery);
	}
	
	/**
	 * Fills keyRecord by values from input record and result set 
	 * 
	 * @param inRecord input record
	 * @param keyRecord key record to fill
	 * @param autogeneratedKeys result set with autogenerated keys (preparedStatement.getGeneratedKeys())
	 * @return
	 * @throws SQLException
	 */
	public DataRecord fillKeyRecord(DataRecord inRecord, DataRecord keyRecord, 
			ResultSet autogeneratedKeys) throws SQLException{
		return keyRecord;
	}

	public Log getLogger() {
		return logger;
	}

	public void setLogger(Log logger) {
		this.logger = logger;
	}

	/**
	 * If it is impossible to create statement with given parameters, method prepareStatement
	 * can change value of this field to "false" and return prepared statement from its base class.
	 * 
	 * @return
	 */
	public boolean isStatementCreatedSuccessfully() {
		return statementCreatedSuccessfully;
	}
	
	String[] getFillFields() {
		return fillFields;
	}

	void setFillFields(String[] fillFields) {
		this.fillFields = fillFields;
	}

}

/**
 * This class gets from database fields requested by user.
 * 
 * @author avackova (agata.vackova@javlinconsulting.cz) ; 
 * (c) JavlinConsulting s.r.o.
 *  www.javlinconsulting.cz
 *
 * @since Jun 13, 2007
 *
 */
class MultiAutoKeyGenerator extends AutoKeyGenerator{
	
	private CopySQLData[] keyTransMap;
	private DataRecord keyRecord;

	MultiAutoKeyGenerator(DBConnection connection, String sqlQuery, String[] columns) {
		super(connection, sqlQuery, columns);
	}
	
	@Override
	public PreparedStatement prepareStatement() throws SQLException {
		if (columns == null || !sqlQuery.toLowerCase().startsWith("insert")) {
			if (logger != null) {
				logger.warn(columns == null ? "Columns are null" : "Not insert statement");
				logger.info("Getting generated keys switched off !");
			}				
			statementCreatedSuccessfully = false;
			return super.prepareStatement();
		}
		//get columns from table from INSERT STATEMENT
		int tableNameStart = StringUtils.findIdentifierBegining(sqlQuery,sqlQuery.toLowerCase().indexOf("into") + 4);
		int tableNameEnd = StringUtils.findIdentifierEnd(sqlQuery, tableNameStart);
		String table = sqlQuery.substring(tableNameStart, tableNameEnd);
		int[] columnIndexes = new int[columns.length];
		ResultSet columnInfo = connection.getConnection().getMetaData().getColumns(
				null, null, table, "%");
		int index;
		int counter = 0;
		//get columns indexes in table from theirs names
		while (columnInfo.next()){
			index = StringUtils.findString(columnInfo.getString("COLUMN_NAME"), columns);
			if (index != -1) {
				columnIndexes[index] = columnInfo.getInt("ORDINAL_POSITION");
				counter++;
			}
		}
		if (counter < columnIndexes.length) {
			statementCreatedSuccessfully = false;
			throw new IllegalArgumentException("Not all columns (" + 
					StringUtils.stringArraytoString(columns, ',') + ") found in table " + table);
		}
		statementCreatedSuccessfully = true;
		return connection.prepareStatement(sqlQuery, columnIndexes);
	}
	
	@Override
	public DataRecord fillKeyRecord(DataRecord inRecord, DataRecord keyRecord, 
			ResultSet autogeneratedKeys) throws SQLException{
		if (!statementCreatedSuccessfully) {
			return super.fillKeyRecord(inRecord, keyRecord, autogeneratedKeys);
		}
		if (this.keyRecord == null) {//first call of the method: prepare keyTransMap
			this.keyRecord = keyRecord;
			if (fillFields != null) {
				RecordKey tmp = new RecordKey(fillFields, keyRecord.getMetadata());
				tmp.init();
				keyTransMap = CopySQLData.sql2JetelTransMap(SQLUtil.getFieldTypes(tmp.generateKeyRecordMetadata()), 
						keyRecord.getMetadata(), keyRecord, fillFields);
			}else {
				keyTransMap = CopySQLData.sql2JetelTransMap(SQLUtil.getFieldTypes(keyRecord.getMetadata()), 
						keyRecord.getMetadata(), keyRecord);
			}
		}
		for (int i = 0; i < keyTransMap.length; i++) {
			keyTransMap[i].sql2jetel(autogeneratedKeys);
		}
		return keyRecord;
	}

}

/**
 * This class fills keyRecord by value from database (AUTO_INCREMENT) and values from input record
 * 
 * @author avackova (agata.vackova@javlinconsulting.cz) ; 
 * (c) JavlinConsulting s.r.o.
 *  www.javlinconsulting.cz
 *
 * @since Jun 13, 2007
 *
 */
class SingleAutoKeyGenerator extends AutoKeyGenerator{
	
	private int[][] fieldMap;
	private DataField field;
	
	private final static int KEY_RECORD_INDEX = 0;
	private final static int IN_RECORD_INDEX = 1;

	SingleAutoKeyGenerator(DBConnection connection, String sqlQuery, String[] columns) {
		super(connection, sqlQuery, columns);
	}

	@Override
	public PreparedStatement prepareStatement() throws SQLException {
		if (columns != null) {
			statementCreatedSuccessfully = true;
			return connection.prepareStatement(sqlQuery, Statement.RETURN_GENERATED_KEYS);
		}
		statementCreatedSuccessfully = false;
		if (logger != null) {
			logger.warn("Columns are null");
			logger.info("Getting generated keys switched off !");
		}				
		return super.prepareStatement();
	}
	
	@Override
	public DataRecord fillKeyRecord(DataRecord inRecord, DataRecord keyRecord, ResultSet autogeneratedKeys) throws SQLException {
		if (!statementCreatedSuccessfully) {
			return super.fillKeyRecord(inRecord, keyRecord, autogeneratedKeys);
		}
		if (fieldMap == null) {//first call: prepare fieldMap
			fieldMap = fieldMap(inRecord, keyRecord, columns);
		}
		for (int i=0; i<fieldMap.length; i++) {
			field = keyRecord.getField(fieldMap[i][KEY_RECORD_INDEX]);
			if (fieldMap[i][IN_RECORD_INDEX] == -1){
				field.setValue(autogeneratedKeys.getLong(1));
			}else{
				field.setValue(inRecord.getField(fieldMap[i][IN_RECORD_INDEX]));
			}
		}
		return keyRecord;
	}
	
	/**
	 * Prepares array of integers for mapping input record to key record.
	 * Number greater from -1 is index of input field to get value. 
	 * -1 means that, value will be got from result set.
	 * 
	 * @param inRecord
	 * @param keyRecord
	 * @param autoGeneratedColumns
	 * @return
	 */
	private int[][] fieldMap(DataRecord inRecord, DataRecord keyRecord, String[] autoGeneratedColumns) {
		int[][] result = fillFields != null ? new int[fillFields.length][2] : new int[keyRecord.getNumFields()][2];
		
		Map<String, Integer> inFieldsMap = inRecord.getMetadata().getFieldNames();
		for (int i = 0; i < result.length; i++) {
			result[i][KEY_RECORD_INDEX] = fillFields != null ? 
					keyRecord.getMetadata().getFieldPosition(fillFields[i]) : i;
			if (autoGeneratedColumns[i].equalsIgnoreCase(AUTOGENERATED_FIELD_NAME)) {
				result[i][IN_RECORD_INDEX] = -1;
			}else if (inFieldsMap.containsKey(autoGeneratedColumns[i])){
				result[i][IN_RECORD_INDEX] = inFieldsMap.get(autoGeneratedColumns[i]);
			}else{
				throw new IllegalArgumentException("Field " + StringUtils.quote(autoGeneratedColumns[i]) + " doesn't exist in input metadata");
			}
		}
		return result;
	}
}

enum MultiAutoKeySupported{
	oracle,
	db2;
//	mssql TODO
//	postgre - driver does not support auoto generated keys

	public static boolean isSupported(String driverName) {
		String driver = driverName.trim().toLowerCase();
		for (MultiAutoKeySupported supportedDatabase : MultiAutoKeySupported.values()) {
			if (driver.contains(supportedDatabase.name())) return true;
		}
		return false;
	}
}

enum SingleAutoKeySupported{
	mysql,
	informix;
//	mssql TODO
//	postgre - driver does not support auoto generated keys
	
	public static boolean isSupported(String driverName) {
		String driver = driverName.trim().toLowerCase();
		for (SingleAutoKeySupported supportedDatabase : SingleAutoKeySupported.values()) {
			if (driver.contains(supportedDatabase.name())) return true;
		}
		return false;
	}
}
