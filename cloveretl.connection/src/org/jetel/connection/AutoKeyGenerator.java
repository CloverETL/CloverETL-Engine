package org.jetel.connection;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.jetel.data.DataField;
import org.jetel.data.DataRecord;
import org.jetel.data.RecordKey;
import org.jetel.util.string.StringUtils;

/**
 * Private class for filling output record by keys got from database.
 * This base class prepares PreparedStatement exactly as in sql query
 * and does nothing with key record. Descendants of this class  have to overide
 * prepareStatement() and fillKeyRecord(DataRecord, DataRecord, ResultSet) methods.
	 * 
 * @author avackova (agata.vackova@javlinconsulting.cz) ; 
 * (c) JavlinConsulting s.r.o.
 *  www.javlinconsulting.cz
 *
 * @since Jun 13, 2007
 *
 */
public class AutoKeyGenerator{
	
	protected Connection connection;
	protected String sqlQuery;
	protected String[] columns;
	protected String[] fillFields;
	protected Log logger;
	protected boolean statementCreatedSuccessfully = true;

	public final static String AUTOGENERATED_FIELD_NAME = "AUTO_GENERATED";

	/**
	 * @param connection connection to database
	 * @param sqlQuery sql query
	 * @param columns list of columns to return
	 */
	AutoKeyGenerator(Connection connection, String sqlQuery, String[] columns) {
		this.connection = connection;
		this.sqlQuery = sqlQuery;
		this.columns = columns;
	} 
	
	/**
	 * Prepares statement from which autogeneratedKeys will be taken.
	 * 
	 * @return
	 * @throws SQLException
	 */
	public PreparedStatement prepareStatement() throws SQLException{
		return connection.prepareStatement(sqlQuery);
	}
	
	public PreparedStatement reset() throws SQLException{
		return prepareStatement();
	}
	
	/**
	 * Fills keyRecord by values from input record and result set 
	 * 
	 * @param inRecord input record
	 * @param keyRecord key record to fill
	 * @param autogeneratedKeys result set with autogenerated keys (preparedStatement.getGeneratedKeys())
	 * @return
	 * @throws SQLException
	 */
	public DataRecord fillKeyRecord(DataRecord inRecord, DataRecord keyRecord, 
			ResultSet autogeneratedKeys) throws SQLException{
		return keyRecord;
	}

	public Log getLogger() {
		return logger;
	}

	public void setLogger(Log logger) {
		this.logger = logger;
	}

	/**
	 * If it is impossible to create statement with given parameters, method prepareStatement
	 * can change value of this field to "false" and return prepared statement from its base class.
	 * 
	 * @return
	 */
	public boolean isStatementCreatedSuccessfully() {
		return statementCreatedSuccessfully;
	}
	
	String[] getFillFields() {
		return fillFields;
	}

	void setFillFields(String[] fillFields) {
		this.fillFields = fillFields;
	}

}

/**
 * This class gets from database fields requested by user.
 * 
 * @author avackova (agata.vackova@javlinconsulting.cz) ; 
 * (c) JavlinConsulting s.r.o.
 *  www.javlinconsulting.cz
 *
 * @since Jun 13, 2007
 *
 */
class MultiAutoKeyGenerator extends AutoKeyGenerator{
	
	private CopySQLData[] keyTransMap;
	private DataRecord keyRecord;
	private int[] columnIndexes;

	MultiAutoKeyGenerator(Connection connection, String sqlQuery, String[] columns) {
		super(connection, sqlQuery, columns);
	}
	
	@Override
	public PreparedStatement prepareStatement() throws SQLException {
		if (columns == null || !sqlQuery.toLowerCase().startsWith("insert")) {
			if (logger != null) {
				logger.warn(columns == null ? "Columns are null" : "Not insert statement");
				logger.info("Getting generated keys switched off !");
			}				
			statementCreatedSuccessfully = false;
			return super.prepareStatement();
		}
		//get columns from table from INSERT STATEMENT
		int tableNameStart = StringUtils.findIdentifierBegining(sqlQuery,sqlQuery.toLowerCase().indexOf("into") + 4);
		int tableNameEnd = StringUtils.findIdentifierEnd(sqlQuery, tableNameStart);
		String table = sqlQuery.substring(tableNameStart, tableNameEnd);
		columnIndexes = new int[columns.length];
		ResultSet columnInfo = connection.getMetaData().getColumns(
				null, null, table, "%");
		int index;
		int counter = 0;
		//get columns indexes in table from theirs names
		while (columnInfo.next()){
			index = StringUtils.findString(columnInfo.getString("COLUMN_NAME"), columns);
			if (index != -1) {
				columnIndexes[index] = columnInfo.getInt("ORDINAL_POSITION");
				counter++;
			}
		}
		if (counter < columnIndexes.length) {
			statementCreatedSuccessfully = false;
			throw new IllegalArgumentException("Not all columns (" + 
					StringUtils.stringArraytoString(columns, ',') + ") found in table " + table);
		}
		statementCreatedSuccessfully = true;
		return connection.prepareStatement(sqlQuery, columnIndexes);
	}
	
	public PreparedStatement reset() throws SQLException{
		if (columns == null || !sqlQuery.toLowerCase().startsWith("insert")) {
			return super.reset();
		}
		return connection.prepareStatement(sqlQuery, columnIndexes);
	}
	
	@Override
	public DataRecord fillKeyRecord(DataRecord inRecord, DataRecord keyRecord, 
			ResultSet autogeneratedKeys) throws SQLException{
		if (!statementCreatedSuccessfully) {
			return super.fillKeyRecord(inRecord, keyRecord, autogeneratedKeys);
		}
		if (this.keyRecord == null) {//first call of the method: prepare keyTransMap
			this.keyRecord = keyRecord;
			if (fillFields != null) {
				RecordKey tmp = new RecordKey(fillFields, keyRecord.getMetadata());
				tmp.init();
				keyTransMap = CopySQLData.sql2JetelTransMap(SQLUtil.getFieldTypes(tmp.generateKeyRecordMetadata()), 
						keyRecord.getMetadata(), keyRecord, fillFields);
			}else {
				keyTransMap = CopySQLData.sql2JetelTransMap(SQLUtil.getFieldTypes(keyRecord.getMetadata()), 
						keyRecord.getMetadata(), keyRecord);
			}
		}
		for (int i = 0; i < keyTransMap.length; i++) {
			keyTransMap[i].sql2jetel(autogeneratedKeys);
		}
		return keyRecord;
	}

}

/**
 * This class fills keyRecord by value from database (AUTO_INCREMENT) and values from input record
 * 
 * @author avackova (agata.vackova@javlinconsulting.cz) ; 
 * (c) JavlinConsulting s.r.o.
 *  www.javlinconsulting.cz
 *
 * @since Jun 13, 2007
 *
 */
class SingleAutoKeyGenerator extends AutoKeyGenerator{
	
	private int[][] fieldMap;
	private DataField field;
	
	private final static int KEY_RECORD_INDEX = 0;
	private final static int IN_RECORD_INDEX = 1;

	SingleAutoKeyGenerator(Connection connection, String sqlQuery, String[] columns) {
		super(connection, sqlQuery, columns);
	}

	@Override
	public PreparedStatement prepareStatement() throws SQLException {
		if (columns != null) {
			statementCreatedSuccessfully = true;
			return connection.prepareStatement(sqlQuery, Statement.RETURN_GENERATED_KEYS);
		}
		statementCreatedSuccessfully = false;
		if (logger != null) {
			logger.warn("Columns are null");
			logger.info("Getting generated keys switched off !");
		}				
		return super.prepareStatement();
	}
	
	@Override
	public PreparedStatement reset() throws SQLException {
		if (columns != null) {
			return connection.prepareStatement(sqlQuery, Statement.RETURN_GENERATED_KEYS);
		}
		return super.reset();
	}
	
	@Override
	public DataRecord fillKeyRecord(DataRecord inRecord, DataRecord keyRecord, ResultSet autogeneratedKeys) throws SQLException {
		if (!statementCreatedSuccessfully) {
			return super.fillKeyRecord(inRecord, keyRecord, autogeneratedKeys);
		}
		if (fieldMap == null) {//first call: prepare fieldMap
			fieldMap = fieldMap(inRecord, keyRecord, columns);
		}
		for (int i=0; i<fieldMap.length; i++) {
			field = keyRecord.getField(fieldMap[i][KEY_RECORD_INDEX]);
			if (fieldMap[i][IN_RECORD_INDEX] == -1){
				field.setValue(autogeneratedKeys.getLong(1));
			}else{
				field.setValue(inRecord.getField(fieldMap[i][IN_RECORD_INDEX]));
			}
		}
		return keyRecord;
	}
	
	/**
	 * Prepares array of integers for mapping input record to key record.
	 * Number greater from -1 is index of input field to get value. 
	 * -1 means that, value will be got from result set.
	 * 
	 * @param inRecord
	 * @param keyRecord
	 * @param autoGeneratedColumns
	 * @return
	 */
	private int[][] fieldMap(DataRecord inRecord, DataRecord keyRecord, String[] autoGeneratedColumns) {
		int[][] result = fillFields != null ? new int[fillFields.length][2] : new int[keyRecord.getNumFields()][2];
		
		Map<String, Integer> inFieldsMap = inRecord.getMetadata().getFieldNames();
		for (int i = 0; i < result.length; i++) {
			result[i][KEY_RECORD_INDEX] = fillFields != null ? 
					keyRecord.getMetadata().getFieldPosition(fillFields[i]) : i;
			if (autoGeneratedColumns[i].equalsIgnoreCase(AUTOGENERATED_FIELD_NAME)) {
				result[i][IN_RECORD_INDEX] = -1;
			}else if (inFieldsMap.containsKey(autoGeneratedColumns[i])){
				result[i][IN_RECORD_INDEX] = inFieldsMap.get(autoGeneratedColumns[i]);
			}else{
				throw new IllegalArgumentException("Field " + StringUtils.quote(autoGeneratedColumns[i]) + " doesn't exist in input metadata");
			}
		}
		return result;
	}
}

