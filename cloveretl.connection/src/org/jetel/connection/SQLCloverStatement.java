/*
*    jETeL/Clover - Java based ETL application framework.
*    Copyright (C) 2005-06  Javlin Consulting <info@javlinconsulting.cz>
*    
*    This library is free software; you can redistribute it and/or
*    modify it under the terms of the GNU Lesser General Public
*    License as published by the Free Software Foundation; either
*    version 2.1 of the License, or (at your option) any later version.
*    
*    This library is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    
*    Lesser General Public License for more details.
*    
*    You should have received a copy of the GNU Lesser General Public
*    License along with this library; if not, write to the Free Software
*    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*/

package org.jetel.connection;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.logging.Log;
import org.jetel.data.DataField;
import org.jetel.data.DataRecord;
import org.jetel.data.RecordKey;
import org.jetel.exception.JetelException;
import org.jetel.util.primitive.DuplicateKeyMap;
import org.jetel.util.string.StringUtils;

/**
 * This class is prepared statement with CopySQLData[] object prepared to work with concrete record.
 * 
 * @author avackova (agata.vackova@javlinconsulting.cz) ; 
 * (c) JavlinConsulting s.r.o.
 *  www.javlinconsulting.cz
 *
 * @since Nov 2, 2007
 *
 */
//Doesn't work on select query yet!!!!
public class SQLCloverStatement {
	
	private QueryAnalyzer analyzer;
	private String query;
	private Connection connection;
	private PreparedStatement preparedStatement;
	private CopySQLData[] transMap;
	private String[] cloverFields;
	private String[] dbFields;
	private String[] autoGeneratedColumn;
	private String[] autoGeneratedColumnToClover;
	private DataRecord record;
	
	private AutoKeyGenerator autoKeyGenerator;
	private ResultSet generatedKeys;
	
	private String tableName;
	private Log logger;
	
	private final static String INSERT_KEY_WORD = "insert";
	
	private final static Pattern TABLE_NAME_PATTERN = Pattern.compile("(?:from|into|update)\\s+(\\w+)", Pattern.CASE_INSENSITIVE);
	
	/**
	 * Constructor for sql query containing db - clover mapping
	 * @see QueryAnalyzer
	 * 
	 * @param connection connection to db
	 * @param query sql query
	 * @param record record which will be filled by results from executing above query
	 */
	public SQLCloverStatement(Connection connection, String query, DataRecord record){
		this.connection = connection;
		analyzer = new QueryAnalyzer(query);
		this.record = record;
	}
	
	/**
	 * Constructor for sql query containing question marks
	 * 
	 * @param connection connection to db
	 * @param query sql query
	 * @param record record which will be filled by results from executing above query
	 * @param cloverFields clover fields to populate 
	 * @param dbFields database fields
	 * 
	 * @see org.jetel.component.DBOutputTable
	 */
	public SQLCloverStatement(Connection connection, String query, DataRecord record, String[] cloverFields, 
			String[] dbFields){
		this.connection = connection;
		this.query = query;
		this.record = record;
		this.cloverFields = cloverFields;
		this.dbFields = dbFields;
	}

	/**
	 * Constructor for sql query containing question marks
	 * 
	 * @param connection connection to db
	 * @param query sql query
	 * @param record record which will be filled by results from executing above query
	 * @param cloverFields clover fields to populate 
	 * @param dbFields database fields
	 * @param autoGeneratedColumns auto generated columns to be returned
	 */
	public SQLCloverStatement(Connection connection, String query, DataRecord record, String[] cloverFields, 
			String[] dbFields, String[] autoGeneratedColumns){
		this(connection, query, record, cloverFields, dbFields);
		this.autoGeneratedColumn = autoGeneratedColumns;
	}
	
	/**
	 * Prepares statement for database and transMap for result set and data record
	 * 
	 * @return true if successful, false if not 
	 * @throws SQLException
	 * @throws JetelException
	 */
	public boolean prepareUpdateStatement() throws SQLException, JetelException{
		//get query in form acceptable for PreparedStatement
		if (analyzer != null && cloverFields == null && dbFields == null) {
			if (analyzer.getSource().trim().toLowerCase().startsWith(INSERT_KEY_WORD)) {
				query = analyzer.getInsertQuery();
			}else{
				query = analyzer.getNotInsertQuery();
			}
			DuplicateKeyMap fieldMap = analyzer.getDbCloverFieldMap();
			dbFields = (String[])fieldMap.keySet().toArray(new String[fieldMap.keySet().size()]);
			cloverFields = (String[]) fieldMap.values().toArray(new String[fieldMap.values().size()]);
		}
		List<Integer> dbFieldTypes;
		if (tableName != null) {
			if (dbFields != null) {
				dbFieldTypes = SQLUtil.getFieldTypes(connection.getMetaData(), tableName, dbFields);
			}else{
				dbFieldTypes = SQLUtil.getFieldTypes(connection.getMetaData(), tableName);
			}
		}else{
			if (cloverFields != null) {
				dbFieldTypes= SQLUtil.getFieldTypes(record.getMetadata(),cloverFields);
			} else {
				dbFieldTypes= SQLUtil.getFieldTypes(record.getMetadata());
			}
		}
		//prepare trans map
		if (cloverFields != null) {
			transMap = CopySQLData.jetel2sqlTransMap(dbFieldTypes, record, cloverFields);
		} else {
			transMap = CopySQLData.jetel2sqlTransMap(dbFieldTypes, record);
		}
		//get auto generated columns from query
		if (analyzer != null) {
			HashMap<String, String> cloverDbMap = analyzer.getCloverDbFieldMap();
			if (cloverDbMap.size() > 0) {
				autoGeneratedColumn = (String[]) cloverDbMap.values().toArray(new String[cloverDbMap.values().size()]);
				autoGeneratedColumnToClover = (String[]) cloverDbMap.keySet().toArray(new String[cloverDbMap.keySet().size()]);
			}
		}
		//create sql statement
		if (autoGeneratedColumn != null) {
			String database = connection.getMetaData().getDatabaseProductName().toLowerCase();
			if (MultiAutoKeySupported.isSupported(database)) {
				autoKeyGenerator = new MultiAutoKeyGenerator(connection, query, autoGeneratedColumn);
			} else if (SingleAutoKeySupported.isSupported(database)) {
				autoKeyGenerator = new SingleAutoKeyGenerator(connection, query, autoGeneratedColumn);
			} else {
				logger.warn("Getting generated keys not supported for " + 
						connection.getMetaData().getDatabaseProductName() + " -> switching it off !");
				autoKeyGenerator = new AutoKeyGenerator(connection, query, autoGeneratedColumn);
			}
		}else{
			autoKeyGenerator = new AutoKeyGenerator(connection, query, null);
		}
		autoKeyGenerator.setLogger(logger);
		autoKeyGenerator.setFillFields(autoGeneratedColumnToClover);
		preparedStatement = autoKeyGenerator.prepareStatement();
		
		return autoKeyGenerator.isStatementCreatedSuccessfully();
	}
	
	/**
	 * Fills prepared statements with data obtained from input record and executes update on database
	 * 
	 * @return
	 * @throws SQLException
	 */
	public int executeUpdate() throws SQLException{
		for (int i = 0; i < transMap.length; i++) {
			transMap[i].jetel2sql(preparedStatement);
		}
		return preparedStatement.executeUpdate();
	}
	
	/**
	 * Adds set of parameters to batch
	 * 
	 * @throws SQLException
	 */
	public void addBatch() throws SQLException{
		for (int i = 0; i < transMap.length; i++) {
			transMap[i].jetel2sql(preparedStatement);
		}
		preparedStatement.addBatch();
	}
	
	/**
	 * Submits a batch of commands to the database for execution and if all commands execute successfully, returns an 
	 * array of update counts.
	 * 
	 * @return an array of update counts containing one element for each command in the batch. The elements of the 
	 * array are ordered according to the order in which commands were added to the batch.
	 * @throws SQLException
	 */
	public int[] executeBatch() throws SQLException{
		return preparedStatement.executeBatch();
	}
	
	/**
	 * Empties this Statement object's current list of SQL commands.
	 * 
	 * @throws SQLException
	 */
	public void clearBatch() throws SQLException{
		preparedStatement.clearBatch();
	}
	 
	/**
	 * Fills record by data received from database by calling getGeneratedKeys() method
	 * 
	 * @param keyRecord record to fill 
	 * @throws SQLException
	 */
	public void fillKeyRecord(DataRecord keyRecord) throws SQLException{
		if (!(autoKeyGenerator instanceof MultiAutoKeyGenerator || autoKeyGenerator instanceof SingleAutoKeyGenerator) ||
				!autoKeyGenerator.statementCreatedSuccessfully) {
			return;
		}
		
		generatedKeys = preparedStatement.getGeneratedKeys();
		if (generatedKeys.next()) {
			autoKeyGenerator.fillKeyRecord(record, keyRecord, generatedKeys);
		}					
	}
	
	/**
	 * @param batchUpdate
	 */
	public void setBatchUpdate(boolean batchUpdate){
        CopySQLData.setBatchUpdate(transMap,batchUpdate);
	}
	
	/**
	 * Releases this Statement object's database and JDBC resources immediately instead of waiting for this to happen 
	 * when it is automatically closed.
	 * 
	 * @throws SQLException
	 */
	public void close() throws SQLException{
		if (preparedStatement != null) {
			preparedStatement.close();
		}
	}
	
	/**
	 * @return underlying PreparedStatement object
	 */
	public PreparedStatement getStatement(){
		return preparedStatement;
	}

	/**
	 * @return sql query
	 */
	public String getQuery(){
		return query;
	}
	
	/**
	 * @return sql query as has been set by user
	 */
	public String getQuerySource(){
		return analyzer != null ? analyzer.getSource() : query;
	}
	
	/**
	 * @return logger
	 */
	public Log getLogger() {
		return logger;
	}

	/**
	 * Sets logger
	 * 
	 * @param logger
	 */
	public void setLogger(Log logger) {
		this.logger = logger;
	}

	/**
	 * @return table name from query
	 */
	public String getTableName() {
		if (tableName != null) {
			return tableName;
		}else{
			Matcher matcher = TABLE_NAME_PATTERN.matcher(query);
			if (matcher.find()) {
				tableName = matcher.group(1);
			}
		}
		return tableName;
	}

	/**
	 * Sets table name
	 * 
	 * @param tableName
	 */
	public void setTableName(String tableName) {
		this.tableName = tableName;
	}
	
}


